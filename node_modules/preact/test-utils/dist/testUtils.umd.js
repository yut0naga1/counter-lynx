(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('preact')) :
	typeof define === 'function' && define.amd ? define(['exports', 'preact'], factory) :
	(global = global || self, factory(global.preactTestUtils = {}, global.preact));
})(this, (function (exports, preact) {
	/**
	 * Setup a rerender function that will drain the queue of pending renders
	 * @returns {() => void}
	 */
	function setupRerender() {
	  preact.options.__test__previousDebounce = preact.options.debounceRendering;
	  preact.options.debounceRendering = function (cb) {
	    return preact.options.__test__drainQueue = cb;
	  };
	  return function () {
	    return preact.options.__test__drainQueue && preact.options.__test__drainQueue();
	  };
	}
	var isThenable = function isThenable(value) {
	  return value != null && typeof value.then == 'function';
	};

	/** Depth of nested calls to `act`. */
	var actDepth = 0;

	/**
	 * Run a test function, and flush all effects and rerenders after invoking it.
	 *
	 * Returns a Promise which resolves "immediately" if the callback is
	 * synchronous or when the callback's result resolves if it is asynchronous.
	 *
	 * @param {() => void|Promise<void>} cb The function under test. This may be sync or async.
	 * @return {Promise<void>}
	 */
	function act(cb) {
	  if (++actDepth > 1) {
	    // If calls to `act` are nested, a flush happens only when the
	    // outermost call returns. In the inner call, we just execute the
	    // callback and return since the infrastructure for flushing has already
	    // been set up.
	    //
	    // If an exception occurs, the outermost `act` will handle cleanup.
	    try {
	      var _result = cb();
	      if (isThenable(_result)) {
	        return _result.then(function () {
	          --actDepth;
	        }, function (e) {
	          --actDepth;
	          throw e;
	        });
	      }
	    } catch (e) {
	      --actDepth;
	      throw e;
	    }
	    --actDepth;
	    return Promise.resolve();
	  }
	  var previousRequestAnimationFrame = preact.options.requestAnimationFrame;
	  var rerender = setupRerender();

	  /** @type {() => void} */
	  var flush, toFlush;

	  // Override requestAnimationFrame so we can flush pending hooks.
	  preact.options.requestAnimationFrame = function (fc) {
	    return flush = fc;
	  };
	  var finish = function finish() {
	    try {
	      rerender();
	      while (flush) {
	        toFlush = flush;
	        flush = null;
	        toFlush();
	        rerender();
	      }
	    } catch (e) {
	      if (!err) {
	        err = e;
	      }
	    } finally {
	      teardown();
	    }
	    preact.options.requestAnimationFrame = previousRequestAnimationFrame;
	    --actDepth;
	  };
	  var err;
	  var result;
	  try {
	    result = cb();
	  } catch (e) {
	    err = e;
	  }
	  if (isThenable(result)) {
	    return result.then(finish, function (err) {
	      finish();
	      throw err;
	    });
	  }

	  // nb. If the callback is synchronous, effects must be flushed before
	  // `act` returns, so that the caller does not have to await the result,
	  // even though React recommends this.
	  finish();
	  if (err) {
	    throw err;
	  }
	  return Promise.resolve();
	}

	/**
	 * Teardown test environment and reset preact's internal state
	 */
	function teardown() {
	  if (preact.options.__test__drainQueue) {
	    // Flush any pending updates leftover by test
	    preact.options.__test__drainQueue();
	    delete preact.options.__test__drainQueue;
	  }
	  if (typeof preact.options.__test__previousDebounce != 'undefined') {
	    preact.options.debounceRendering = preact.options.__test__previousDebounce;
	    delete preact.options.__test__previousDebounce;
	  } else {
	    preact.options.debounceRendering = undefined;
	  }
	}

	exports.act = act;
	exports.setupRerender = setupRerender;
	exports.teardown = teardown;

}));
//# sourceMappingURL=testUtils.umd.js.map
