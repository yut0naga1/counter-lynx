(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('preact'), require('preact/devtools')) :
	typeof define === 'function' && define.amd ? define(['exports', 'preact', 'preact/devtools'], factory) :
	(global = global || self, factory(global.preactDebug = {}, global.preact));
})(this, (function (exports, preact) {
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	var loggedTypeFailures = {};

	/**
	 * Reset the history of which prop type warnings have been logged.
	 */
	function resetPropWarnings() {
	  loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * Adapted from https://github.com/facebook/prop-types/blob/master/checkPropTypes.js
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  Object.keys(typeSpecs).forEach(function (typeSpecName) {
	    var error;
	    try {
	      error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	    } catch (e) {
	      error = e;
	    }
	    if (error && !(error.message in loggedTypeFailures)) {
	      loggedTypeFailures[error.message] = true;
	      console.error("Failed " + location + " type: " + error.message + (getStack && "\n" + getStack() || ''));
	    }
	  });
	}

	var ELEMENT_NODE = 1;
	var DOCUMENT_NODE = 9;
	var DOCUMENT_FRAGMENT_NODE = 11;

	/**
	 * Get human readable name of the component/dom node
	 * @param {import('./internal').VNode} vnode
	 * @param {import('./internal').VNode} vnode
	 * @returns {string}
	 */
	function getDisplayName(vnode) {
	  if (vnode.type === preact.Fragment) {
	    return 'Fragment';
	  } else if (typeof vnode.type == 'function') {
	    return vnode.type.displayName || vnode.type.name;
	  } else if (typeof vnode.type == 'string') {
	    return vnode.type;
	  }
	  return '#text';
	}

	/**
	 * Used to keep track of the currently rendered `vnode` and print it
	 * in debug messages.
	 */
	var renderStack = [];

	/**
	 * Keep track of the current owners. An owner describes a component
	 * which was responsible to render a specific `vnode`. This exclude
	 * children that are passed via `props.children`, because they belong
	 * to the parent owner.
	 *
	 * ```jsx
	 * const Foo = props => <div>{props.children}</div> // div's owner is Foo
	 * const Bar = props => {
	 *   return (
	 *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar
	 *   )
	 * }
	 * ```
	 *
	 * Note: A `vnode` may be hoisted to the root scope due to compiler
	 * optimiztions. In these cases the `_owner` will be different.
	 */
	var ownerStack = [];

	/**
	 * Get the currently rendered `vnode`
	 * @returns {import('./internal').VNode | null}
	 */
	function getCurrentVNode() {
	  return renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;
	}

	/**
	 * If the user doesn't have `@babel/plugin-transform-react-jsx-source`
	 * somewhere in his tool chain we can't print the filename and source
	 * location of a component. In that case we just omit that, but we'll
	 * print a helpful message to the console, notifying the user of it.
	 */
	var showJsxSourcePluginWarning = true;

	/**
	 * Check if a `vnode` is a possible owner.
	 * @param {import('./internal').VNode} vnode
	 */
	function isPossibleOwner(vnode) {
	  return typeof vnode.type == 'function' && vnode.type != preact.Fragment;
	}

	/**
	 * Return the component stack that was captured up to this point.
	 * @param {import('./internal').VNode} vnode
	 * @returns {string}
	 */
	function getOwnerStack(vnode) {
	  var stack = [vnode];
	  var next = vnode;
	  while (next.__o != null) {
	    stack.push(next.__o);
	    next = next.__o;
	  }
	  return stack.reduce(function (acc, owner) {
	    acc += "  in " + getDisplayName(owner);
	    var source = owner.__source;
	    if (source) {
	      acc += " (at " + source.fileName + ":" + source.lineNumber + ")";
	    } else if (showJsxSourcePluginWarning) {
	      console.warn('Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.');
	    }
	    showJsxSourcePluginWarning = false;
	    return acc += '\n';
	  }, '');
	}

	/**
	 * Setup code to capture the component trace while rendering. Note that
	 * we cannot simply traverse `vnode._parent` upwards, because we have some
	 * debug messages for `this.setState` where the `vnode` is `undefined`.
	 */
	function setupComponentStack() {
	  var oldDiff = preact.options.__b;
	  var oldDiffed = preact.options.diffed;
	  var oldRoot = preact.options.__;
	  var oldVNode = preact.options.vnode;
	  var oldRender = preact.options.__r;
	  preact.options.diffed = function (vnode) {
	    if (isPossibleOwner(vnode)) {
	      ownerStack.pop();
	    }
	    renderStack.pop();
	    if (oldDiffed) oldDiffed(vnode);
	  };
	  preact.options.__b = function (vnode) {
	    if (isPossibleOwner(vnode)) {
	      renderStack.push(vnode);
	    }
	    if (oldDiff) oldDiff(vnode);
	  };
	  preact.options.__ = function (vnode, parent) {
	    ownerStack = [];
	    if (oldRoot) oldRoot(vnode, parent);
	  };
	  preact.options.vnode = function (vnode) {
	    vnode.__o = ownerStack.length > 0 ? ownerStack[ownerStack.length - 1] : null;
	    if (oldVNode) oldVNode(vnode);
	  };
	  preact.options.__r = function (vnode) {
	    if (isPossibleOwner(vnode)) {
	      ownerStack.push(vnode);
	    }
	    if (oldRender) oldRender(vnode);
	  };
	}

	/**
	 * Assign properties from `props` to `obj`
	 * @template O, P The obj and props types
	 * @param {O} obj The object to copy properties to
	 * @param {P} props The object to copy properties from
	 * @returns {O & P}
	 */
	function assign(obj, props) {
	  for (var i in props) obj[i] = props[i];
	  return /** @type {O & P} */obj;
	}
	function isNaN(value) {
	  return value !== value;
	}

	var isWeakMapSupported = typeof WeakMap == 'function';

	/**
	 * @param {import('./internal').VNode} vnode
	 * @returns {Array<string>}
	 */
	function getDomChildren(vnode) {
	  var domChildren = [];
	  if (!vnode.__k) return domChildren;
	  vnode.__k.forEach(function (child) {
	    if (child && typeof child.type === 'function') {
	      domChildren.push.apply(domChildren, getDomChildren(child));
	    } else if (child && typeof child.type === 'string') {
	      domChildren.push(child.type);
	    }
	  });
	  return domChildren;
	}

	/**
	 * @param {import('./internal').VNode} parent
	 * @returns {string}
	 */
	function getClosestDomNodeParentName(parent) {
	  if (!parent) return '';
	  if (typeof parent.type == 'function') {
	    if (parent.__ == null) {
	      if (parent.__e != null && parent.__e.parentNode != null) {
	        return parent.__e.parentNode.localName;
	      }
	      return '';
	    }
	    return getClosestDomNodeParentName(parent.__);
	  }
	  return /** @type {string} */parent.type;
	}
	function initDebug() {
	  setupComponentStack();
	  var hooksAllowed = false;

	  /* eslint-disable no-console */
	  var oldBeforeDiff = preact.options.__b;
	  var oldDiffed = preact.options.diffed;
	  var oldVnode = preact.options.vnode;
	  var oldRender = preact.options.__r;
	  var oldCatchError = preact.options.__e;
	  var oldRoot = preact.options.__;
	  var oldHook = preact.options.__h;
	  var warnedComponents = !isWeakMapSupported ? null : {
	    useEffect: new WeakMap(),
	    useLayoutEffect: new WeakMap(),
	    lazyPropTypes: new WeakMap()
	  };
	  var deprecations = [];
	  preact.options.__e = function (error, vnode, oldVNode, errorInfo) {
	    var component = vnode && vnode.__c;
	    if (component && typeof error.then == 'function') {
	      var promise = error;
	      error = new Error("Missing Suspense. The throwing component was: " + getDisplayName(vnode));
	      var parent = vnode;
	      for (; parent; parent = parent.__) {
	        if (parent.__c && parent.__c.__c) {
	          error = promise;
	          break;
	        }
	      }

	      // We haven't recovered and we know at this point that there is no
	      // Suspense component higher up in the tree
	      if (error instanceof Error) {
	        throw error;
	      }
	    }
	    try {
	      errorInfo = errorInfo || {};
	      errorInfo.componentStack = getOwnerStack(vnode);
	      oldCatchError(error, vnode, oldVNode, errorInfo);

	      // when an error was handled by an ErrorBoundary we will nonetheless emit an error
	      // event on the window object. This is to make up for react compatibility in dev mode
	      // and thus make the Next.js dev overlay work.
	      if (typeof error.then != 'function') {
	        setTimeout(function () {
	          throw error;
	        });
	      }
	    } catch (e) {
	      throw e;
	    }
	  };
	  preact.options.__ = function (vnode, parentNode) {
	    if (!parentNode) {
	      throw new Error('Undefined parent passed to render(), this is the second argument.\n' + 'Check if the element is available in the DOM/has the correct id.');
	    }
	    var isValid;
	    switch (parentNode.nodeType) {
	      case ELEMENT_NODE:
	      case DOCUMENT_FRAGMENT_NODE:
	      case DOCUMENT_NODE:
	        isValid = true;
	        break;
	      default:
	        isValid = false;
	    }
	    if (!isValid) {
	      var componentName = getDisplayName(vnode);
	      throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + parentNode + " instead: render(<" + componentName + " />, " + parentNode + ");");
	    }
	    if (oldRoot) oldRoot(vnode, parentNode);
	  };
	  preact.options.__b = function (vnode) {
	    var type = vnode.type;
	    hooksAllowed = true;
	    if (type === undefined) {
	      throw new Error('Undefined component passed to createElement()\n\n' + 'You likely forgot to export your component or might have mixed up default and named imports' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	    } else if (type != null && typeof type == 'object') {
	      if (type.__k !== undefined && type.__e !== undefined) {
	        throw new Error("Invalid type passed to createElement(): " + type + "\n\n" + 'Did you accidentally pass a JSX literal as JSX twice?\n\n' + ("  let My" + getDisplayName(vnode) + " = " + serializeVNode(type) + ";\n") + ("  let vnode = <My" + getDisplayName(vnode) + " />;\n\n") + 'This usually happens when you export a JSX literal and not the component.' + ("\n\n" + getOwnerStack(vnode)));
	      }
	      throw new Error('Invalid type passed to createElement(): ' + (Array.isArray(type) ? 'array' : type));
	    }
	    if (vnode.ref !== undefined && typeof vnode.ref != 'function' && typeof vnode.ref != 'object' && !('$$typeof' in vnode) // allow string refs when preact-compat is installed
	    ) {
	      throw new Error("Component's \"ref\" property should be a function, or an object created " + ("by createRef(), but got [" + typeof vnode.ref + "] instead\n") + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	    }
	    if (typeof vnode.type == 'string') {
	      for (var key in vnode.props) {
	        if (key[0] === 'o' && key[1] === 'n' && typeof vnode.props[key] != 'function' && vnode.props[key] != null) {
	          throw new Error("Component's \"" + key + "\" property should be a function, " + ("but got [" + typeof vnode.props[key] + "] instead\n") + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        }
	      }
	    }

	    // Check prop-types if available
	    if (typeof vnode.type == 'function' && vnode.type.propTypes) {
	      if (vnode.type.displayName === 'Lazy' && warnedComponents && !warnedComponents.lazyPropTypes.has(vnode.type)) {
	        var m = 'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';
	        try {
	          var lazyVNode = vnode.type();
	          warnedComponents.lazyPropTypes.set(vnode.type, true);
	          console.warn(m + ("Component wrapped in lazy() is " + getDisplayName(lazyVNode)));
	        } catch (promise) {
	          console.warn(m + "We will log the wrapped component's name once it is loaded.");
	        }
	      }
	      var values = vnode.props;
	      if (vnode.type.__f) {
	        values = assign({}, values);
	        delete values.ref;
	      }
	      checkPropTypes(vnode.type.propTypes, values, 'prop', getDisplayName(vnode), function () {
	        return getOwnerStack(vnode);
	      });
	    }
	    if (oldBeforeDiff) oldBeforeDiff(vnode);
	  };
	  var renderCount = 0;
	  var currentComponent;
	  preact.options.__r = function (vnode) {
	    if (oldRender) {
	      oldRender(vnode);
	    }
	    hooksAllowed = true;
	    var nextComponent = vnode.__c;
	    if (nextComponent === currentComponent) {
	      renderCount++;
	    } else {
	      renderCount = 1;
	    }
	    if (renderCount >= 25) {
	      throw new Error("Too many re-renders. This is limited to prevent an infinite loop " + ("which may lock up your browser. The component causing this is: " + getDisplayName(vnode)));
	    }
	    currentComponent = nextComponent;
	  };
	  preact.options.__h = function (comp, index, type) {
	    if (!comp || !hooksAllowed) {
	      throw new Error('Hook can only be invoked from render methods.');
	    }
	    if (oldHook) oldHook(comp, index, type);
	  };

	  // Ideally we'd want to print a warning once per component, but we
	  // don't have access to the vnode that triggered it here. As a
	  // compromise and to avoid flooding the console with warnings we
	  // print each deprecation warning only once.
	  var warn = function warn(property, message) {
	    return {
	      get: function get() {
	        var key = 'get' + property + message;
	        if (deprecations && deprecations.indexOf(key) < 0) {
	          deprecations.push(key);
	          console.warn("getting vnode." + property + " is deprecated, " + message);
	        }
	      },
	      set: function set() {
	        var key = 'set' + property + message;
	        if (deprecations && deprecations.indexOf(key) < 0) {
	          deprecations.push(key);
	          console.warn("setting vnode." + property + " is not allowed, " + message);
	        }
	      }
	    };
	  };
	  var deprecatedAttributes = {
	    nodeName: warn('nodeName', 'use vnode.type'),
	    attributes: warn('attributes', 'use vnode.props'),
	    children: warn('children', 'use vnode.props.children')
	  };
	  var deprecatedProto = Object.create({}, deprecatedAttributes);
	  preact.options.vnode = function (vnode) {
	    var props = vnode.props;
	    if (vnode.type !== null && props != null && ('__source' in props || '__self' in props)) {
	      var newProps = vnode.props = {};
	      for (var i in props) {
	        var v = props[i];
	        if (i === '__source') vnode.__source = v;else if (i === '__self') vnode.__self = v;else newProps[i] = v;
	      }
	    }

	    // eslint-disable-next-line
	    vnode.__proto__ = deprecatedProto;
	    if (oldVnode) oldVnode(vnode);
	  };
	  preact.options.diffed = function (vnode) {
	    var type = vnode.type,
	      parent = vnode.__;
	    // Check if the user passed plain objects as children. Note that we cannot
	    // move this check into `options.vnode` because components can receive
	    // children in any shape they want (e.g.
	    // `<MyJSONFormatter>{{ foo: 123, bar: "abc" }}</MyJSONFormatter>`).
	    // Putting this check in `options.diffed` ensures that
	    // `vnode._children` is set and that we only validate the children
	    // that were actually rendered.
	    if (vnode.__k) {
	      vnode.__k.forEach(function (child) {
	        if (typeof child === 'object' && child && child.type === undefined) {
	          var keys = Object.keys(child).join(',');
	          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + keys + "}." + ("\n\n" + getOwnerStack(vnode)));
	        }
	      });
	    }
	    if (vnode.__c === currentComponent) {
	      renderCount = 0;
	    }
	    if (typeof type === 'string' && (isTableElement(type) || type === 'p' || type === 'a' || type === 'button')) {
	      // Avoid false positives when Preact only partially rendered the
	      // HTML tree. Whilst we attempt to include the outer DOM in our
	      // validation, this wouldn't work on the server for
	      // `preact-render-to-string`. There we'd otherwise flood the terminal
	      // with false positives, which we'd like to avoid.
	      var domParentName = getClosestDomNodeParentName(parent);
	      if (domParentName !== '' && isTableElement(type)) {
	        if (type === 'table' &&
	        // Tables can be nested inside each other if it's inside a cell.
	        // See https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced#nesting_tables
	        domParentName !== 'td' && isTableElement(domParentName)) {
	          console.log(domParentName, parent.__e);
	          console.error('Improper nesting of table. Your <table> should not have a table-node parent.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        } else if ((type === 'thead' || type === 'tfoot' || type === 'tbody') && domParentName !== 'table') {
	          console.error('Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        } else if (type === 'tr' && domParentName !== 'thead' && domParentName !== 'tfoot' && domParentName !== 'tbody') {
	          console.error('Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot> parent.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        } else if (type === 'td' && domParentName !== 'tr') {
	          console.error('Improper nesting of table. Your <td> should have a <tr> parent.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        } else if (type === 'th' && domParentName !== 'tr') {
	          console.error('Improper nesting of table. Your <th> should have a <tr>.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        }
	      } else if (type === 'p') {
	        var illegalDomChildrenTypes = getDomChildren(vnode).filter(function (childType) {
	          return ILLEGAL_PARAGRAPH_CHILD_ELEMENTS.test(childType);
	        });
	        if (illegalDomChildrenTypes.length) {
	          console.error('Improper nesting of paragraph. Your <p> should not have ' + illegalDomChildrenTypes.join(', ') + 'as child-elements.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        }
	      } else if (type === 'a' || type === 'button') {
	        if (getDomChildren(vnode).indexOf(type) !== -1) {
	          console.error("Improper nesting of interactive content. Your <" + type + ">" + (" should not have other " + (type === 'a' ? 'anchor' : 'button')) + ' tags as child-elements.' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));
	        }
	      }
	    }
	    hooksAllowed = false;
	    if (oldDiffed) oldDiffed(vnode);
	    if (vnode.__k != null) {
	      var keys = [];
	      for (var i = 0; i < vnode.__k.length; i++) {
	        var child = vnode.__k[i];
	        if (!child || child.key == null) continue;
	        var key = child.key;
	        if (keys.indexOf(key) !== -1) {
	          console.error('Following component has two or more children with the ' + ("same key attribute: \"" + key + "\". This may cause glitches and misbehavior ") + 'in rendering process. Component: \n\n' + serializeVNode(vnode) + ("\n\n" + getOwnerStack(vnode)));

	          // Break early to not spam the console
	          break;
	        }
	        keys.push(key);
	      }
	    }
	    if (vnode.__c != null && vnode.__c.__H != null) {
	      // Validate that none of the hooks in this component contain arguments that are NaN.
	      // This is a common mistake that can be hard to debug, so we want to catch it early.
	      var hooks = vnode.__c.__H.__;
	      if (hooks) {
	        for (var _i = 0; _i < hooks.length; _i += 1) {
	          var hook = hooks[_i];
	          if (hook.__H) {
	            for (var j = 0; j < hook.__H.length; j++) {
	              var arg = hook.__H[j];
	              if (isNaN(arg)) {
	                var componentName = getDisplayName(vnode);
	                throw new Error("Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index " + _i + " in component " + componentName + " was called with NaN.");
	              }
	            }
	          }
	        }
	      }
	    }
	  };
	}
	var setState = preact.Component.prototype.setState;
	preact.Component.prototype.setState = function (update, callback) {
	  if (this.__v == null) {
	    // `this._vnode` will be `null` during componentWillMount. But it
	    // is perfectly valid to call `setState` during cWM. So we
	    // need an additional check to verify that we are dealing with a
	    // call inside constructor.
	    if (this.state == null) {
	      console.warn("Calling \"this.setState\" inside the constructor of a component is a " + "no-op and might be a bug in your application. Instead, set " + ("\"this.state = {}\" directly.\n\n" + getOwnerStack(getCurrentVNode())));
	    }
	  }
	  return setState.call(this, update, callback);
	};
	function isTableElement(type) {
	  return type === 'table' || type === 'tfoot' || type === 'tbody' || type === 'thead' || type === 'td' || type === 'tr' || type === 'th';
	}
	var ILLEGAL_PARAGRAPH_CHILD_ELEMENTS = /^(address|article|aside|blockquote|details|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|main|menu|nav|ol|p|pre|search|section|table|ul)$/;
	var forceUpdate = preact.Component.prototype.forceUpdate;
	preact.Component.prototype.forceUpdate = function (callback) {
	  if (this.__v == null) {
	    console.warn("Calling \"this.forceUpdate\" inside the constructor of a component is a " + ("no-op and might be a bug in your application.\n\n" + getOwnerStack(getCurrentVNode())));
	  } else if (this.__P == null) {
	    console.warn("Can't call \"this.forceUpdate\" on an unmounted component. This is a no-op, " + "but it indicates a memory leak in your application. To fix, cancel all " + "subscriptions and asynchronous tasks in the componentWillUnmount method." + ("\n\n" + getOwnerStack(this.__v)));
	  }
	  return forceUpdate.call(this, callback);
	};

	/**
	 * Serialize a vnode tree to a string
	 * @param {import('./internal').VNode} vnode
	 * @returns {string}
	 */
	function serializeVNode(vnode) {
	  var props = vnode.props;
	  var name = getDisplayName(vnode);
	  var attrs = '';
	  for (var prop in props) {
	    if (props.hasOwnProperty(prop) && prop !== 'children') {
	      var value = props[prop];

	      // If it is an object but doesn't have toString(), use Object.toString
	      if (typeof value == 'function') {
	        value = "function " + (value.displayName || value.name) + "() {}";
	      }
	      value = Object(value) === value && !value.toString ? Object.prototype.toString.call(value) : value + '';
	      attrs += " " + prop + "=" + JSON.stringify(value);
	    }
	  }
	  var children = props.children;
	  return "<" + name + attrs + (children && children.length ? '>..</' + name + '>' : ' />');
	}
	preact.options.__m = function (newVNode, excessDomChildren) {
	  var type = newVNode.type;
	  var availableTypes = excessDomChildren.map(function (child) {
	    return child.localName;
	  });
	  console.error("Expected a DOM node of type " + type + " but found " + availableTypes.join(', ') + "as available DOM-node(s), this is caused by the SSR'd HTML containing different DOM-nodes compared to the hydrated one.\n\n" + getOwnerStack(newVNode));
	};

	initDebug();

	exports.resetPropWarnings = resetPropWarnings;

}));
//# sourceMappingURL=debug.umd.js.map
