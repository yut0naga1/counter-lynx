import * as __WEBPACK_EXTERNAL_MODULE__lynx_js_react_alias_rsbuild_plugin_2a0391db__ from "@lynx-js/react-alias-rsbuild-plugin";
import * as __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__ from "node:path";
import * as __WEBPACK_EXTERNAL_MODULE_node_url_e96de089__ from "node:url";
import { createRequire } from "node:module";
import { LAYERS, ReactWebpackPlugin } from "@lynx-js/react-webpack-plugin";
import { RuntimeWrapperWebpackPlugin } from "@lynx-js/runtime-wrapper-webpack-plugin";
import { LynxEncodePlugin, LynxTemplatePlugin, WebEncodePlugin } from "@lynx-js/template-webpack-plugin";
import { ReactRefreshRspackPlugin, ReactRefreshWebpackPlugin } from "@lynx-js/react-refresh-webpack-plugin";
var __webpack_modules__ = {
    "../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/internal/_accessExpressionAsString.js": function(__unused_webpack_module, exports) {
        exports._accessExpressionAsString = void 0;
        const _accessExpressionAsString = (str)=>variable(str) ? `.${str}` : `[${JSON.stringify(str)}]`;
        exports._accessExpressionAsString = _accessExpressionAsString;
        const variable = (str)=>false === reserved(str) && /^[a-zA-Z_$][a-zA-Z_$0-9]*$/g.test(str);
        const reserved = (str)=>RESERVED.has(str);
        const RESERVED = new Set([
            "break",
            "case",
            "catch",
            "class",
            "const",
            "continue",
            "debugger",
            "default",
            "delete",
            "do",
            "else",
            "enum",
            "export",
            "extends",
            "false",
            "finally",
            "for",
            "function",
            "if",
            "import",
            "in",
            "instanceof",
            "new",
            "null",
            "return",
            "super",
            "switch",
            "this",
            "throw",
            "true",
            "try",
            "typeof",
            "var",
            "void",
            "while",
            "with"
        ]);
    },
    "../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/internal/_assertGuard.js": function(__unused_webpack_module, exports, __webpack_require__) {
        exports._assertGuard = void 0;
        const TypeGuardError_1 = __webpack_require__("../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/TypeGuardError.mjs");
        const _assertGuard = (exceptionable, props, factory)=>{
            if (true === exceptionable) if (factory) throw factory(props);
            else throw new TypeGuardError_1.TypeGuardError(props);
            return false;
        };
        exports._assertGuard = _assertGuard;
    },
    "@lynx-js/react-alias-rsbuild-plugin": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__lynx_js_react_alias_rsbuild_plugin_2a0391db__;
    },
    "node:path": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__;
    },
    "node:url": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_url_e96de089__;
    },
    "../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/TypeGuardError.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            TypeGuardError: ()=>TypeGuardError
        });
        class TypeGuardError extends Error {
            method;
            path;
            expected;
            value;
            fake_expected_typed_value_;
            constructor(props){
                super(props.message || `Error on ${props.method}(): invalid type${props.path ? ` on ${props.path}` : ""}, expect to be ${props.expected}`);
                const proto = new.target.prototype;
                if (Object.setPrototypeOf) Object.setPrototypeOf(this, proto);
                else this.__proto__ = proto;
                this.method = props.method;
                this.path = props.path;
                this.expected = props.expected;
                this.value = props.value;
            }
        }
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
__webpack_require__.m = __webpack_modules__;
(()=>{
    __webpack_require__.d = (exports, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.f = {};
    __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>{
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
})();
(()=>{
    __webpack_require__.u = (chunkId)=>"" + chunkId + ".js";
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    var installedChunks = {
        980: 0
    };
    var installChunk = (data)=>{
        var __webpack_ids__ = data.__webpack_ids__;
        var __webpack_modules__ = data.__webpack_modules__;
        var __webpack_runtime__ = data.__webpack_runtime__;
        var moduleId, chunkId, i = 0;
        for(moduleId in __webpack_modules__)if (__webpack_require__.o(__webpack_modules__, moduleId)) __webpack_require__.m[moduleId] = __webpack_modules__[moduleId];
        if (__webpack_runtime__) __webpack_runtime__(__webpack_require__);
        for(; i < __webpack_ids__.length; i++){
            chunkId = __webpack_ids__[i];
            if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) installedChunks[chunkId][0]();
            installedChunks[__webpack_ids__[i]] = 0;
        }
    };
    __webpack_require__.f.j = function(chunkId, promises) {
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : void 0;
        if (0 !== installedChunkData) if (installedChunkData) promises.push(installedChunkData[1]);
        else {
            var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e)=>{
                if (0 !== installedChunks[chunkId]) installedChunks[chunkId] = void 0;
                throw e;
            });
            var promise = Promise.race([
                promise,
                new Promise((resolve)=>{
                    installedChunkData = installedChunks[chunkId] = [
                        resolve
                    ];
                })
            ]);
            promises.push(installedChunkData[1] = promise);
        }
    };
})();
var react_alias_rsbuild_plugin_ = __webpack_require__("@lynx-js/react-alias-rsbuild-plugin");
var external_node_path_ = __webpack_require__("node:path");
var external_node_url_ = __webpack_require__("node:url");
const DETECT_IMPORT_ERROR = 'react:detect-import-error';
const ALIAS_BACKGROUND_ONLY_MAIN = 'react:alias-background-only-main';
const ALIAS_BACKGROUND_ONLY_BACKGROUND = 'react:alias-background-only-background';
function applyBackgroundOnly(api) {
    api.modifyBundlerChain(async (chain)=>{
        const __dirname = external_node_path_["default"].dirname((0, external_node_url_.fileURLToPath)(import.meta.url));
        const { resolve, resolveMainThread } = await __webpack_require__.e("860").then(__webpack_require__.bind(__webpack_require__, "./src/resolve.ts"));
        const [backgroundOnly, backgroundOnlyMainThread] = await Promise.all([
            resolve('background-only'),
            resolveMainThread('background-only')
        ]);
        chain.module.rule(ALIAS_BACKGROUND_ONLY_MAIN).issuerLayer(LAYERS.MAIN_THREAD).resolve.alias.set('background-only$', backgroundOnlyMainThread);
        chain.module.rule(ALIAS_BACKGROUND_ONLY_BACKGROUND).issuerLayer(LAYERS.BACKGROUND).resolve.alias.set('background-only$', backgroundOnly);
        chain.module.rule(DETECT_IMPORT_ERROR).test(backgroundOnlyMainThread).issuerLayer(LAYERS.MAIN_THREAD).use(DETECT_IMPORT_ERROR).loader(external_node_path_["default"].resolve(__dirname, 'loaders/invalid-import-error-loader')).options({
            message: '\'background-only\' cannot be imported from a main-thread module.'
        });
    });
}
function applyCSS(api, options) {
    const { enableRemoveCSSScope, enableCSSSelector, enableCSSInvalidation, targetSdkVersion } = options;
    api.modifyRsbuildConfig((config, { mergeRsbuildConfig })=>mergeRsbuildConfig(config, {
            output: {
                injectStyles: false
            }
        }));
    const __dirname = external_node_path_["default"].dirname((0, external_node_url_.fileURLToPath)(import.meta.url));
    api.modifyBundlerChain(async function(chain, { CHAIN_ID, environment }) {
        const { CssExtractRspackPlugin, CssExtractWebpackPlugin } = await import("@lynx-js/css-extract-webpack-plugin");
        const CssExtractPlugin = 'rspack' === api.context.bundlerType ? CssExtractRspackPlugin : CssExtractWebpackPlugin;
        const cssRules = [
            CHAIN_ID.RULE.CSS,
            CHAIN_ID.RULE.SASS,
            CHAIN_ID.RULE.LESS,
            CHAIN_ID.RULE.STYLUS
        ];
        cssRules.filter((rule)=>chain.module.rules.has(rule)).forEach((ruleName)=>{
            const rule = chain.module.rule(ruleName);
            removeLightningCSS(rule);
            rule.issuerLayer(LAYERS.BACKGROUND).use(CHAIN_ID.USE.MINI_CSS_EXTRACT).loader(CssExtractPlugin.loader).end();
            const uses = rule.uses.entries();
            const ruleEntries = rule.entries();
            const cssLoaderRule = uses[CHAIN_ID.USE.CSS].entries();
            chain.module.rule(`${ruleName}:${LAYERS.MAIN_THREAD}`).merge(ruleEntries).issuerLayer(LAYERS.MAIN_THREAD).use(CHAIN_ID.USE.IGNORE_CSS).loader(external_node_path_["default"].resolve(__dirname, './loaders/ignore-css-loader')).end().uses.merge(uses).delete(CHAIN_ID.USE.MINI_CSS_EXTRACT).delete(CHAIN_ID.USE.LIGHTNINGCSS).delete(CHAIN_ID.USE.CSS).end().use(CHAIN_ID.USE.CSS).after(CHAIN_ID.USE.IGNORE_CSS).merge(cssLoaderRule).options(normalizeCssLoaderOptions(cssLoaderRule.options, true)).end();
        });
        const inlineCSSRules = [
            CHAIN_ID.RULE.CSS_INLINE,
            CHAIN_ID.RULE.SASS_INLINE,
            CHAIN_ID.RULE.LESS_INLINE,
            CHAIN_ID.RULE.STYLUS_INLINE
        ];
        inlineCSSRules.filter((rule)=>rule && chain.module.rules.has(rule)).forEach((ruleName)=>{
            const rule = chain.module.rule(ruleName);
            removeLightningCSS(rule);
        });
        function removeLightningCSS(rule) {
            if (rule.uses.has(CHAIN_ID.USE.LIGHTNINGCSS) && 'lynx' === environment.name) rule.uses.delete(CHAIN_ID.USE.LIGHTNINGCSS);
        }
        chain.plugin(CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT).tap(([options])=>[
                {
                    ...options,
                    enableRemoveCSSScope: enableRemoveCSSScope ?? true,
                    enableCSSSelector,
                    enableCSSInvalidation,
                    targetSdkVersion,
                    cssPlugins: []
                }
            ]).init((_, args)=>new CssExtractPlugin(...args)).end().end();
        chain.module.when(void 0 === enableRemoveCSSScope, (module)=>module.rule('lynx.css.scoped').test(/\.css$/).resourceQuery({
                and: [
                    /cssId/
                ]
            }).sideEffects(false));
    });
}
const normalizeCssLoaderOptions = (options, exportOnlyLocals)=>{
    if (options.modules && exportOnlyLocals) {
        let { modules } = options;
        modules = true === modules ? {
            exportOnlyLocals: true
        } : 'string' == typeof modules ? {
            mode: modules,
            exportOnlyLocals: true
        } : {
            ...modules,
            exportOnlyLocals: true
        };
        return {
            ...options,
            modules
        };
    }
    return options;
};
const PLUGIN_NAME_REACT = 'lynx:react';
const PLUGIN_NAME_TEMPLATE = 'lynx:template';
const PLUGIN_NAME_RUNTIME_WRAPPER = 'lynx:runtime-wrapper';
const PLUGIN_NAME_WEB = 'lynx:web';
const DEFAULT_DIST_PATH_INTERMEDIATE = '.rspeedy';
const DEFAULT_FILENAME_HASH = '.[contenthash:8]';
const EMPTY_HASH = '';
function applyEntry(api, options) {
    const { compat, customCSSInheritanceList, debugInfoOutside, defaultDisplayLinear, enableAccessibilityElement, enableICU, enableCSSInheritance, enableCSSInvalidation, enableCSSSelector, enableNewGesture, enableParallelElement, enableRemoveCSSScope, firstScreenSyncTiming, enableSSR, pipelineSchedulerConfig, removeDescendantSelectorScope, targetSdkVersion, extractStr: originalExtractStr, experimental_isLazyBundle } = options;
    const { config, logger } = api.useExposed(Symbol.for('rspeedy.api'));
    api.modifyBundlerChain((chain, { environment, isDev, isProd })=>{
        const entries = chain.entryPoints.entries() ?? {};
        const isLynx = 'lynx' === environment.name;
        const isWeb = 'web' === environment.name;
        chain.entryPoints.clear();
        const mainThreadChunks = [];
        Object.entries(entries).forEach(([entryName, entryPoint])=>{
            const { imports } = getChunks(entryName, entryPoint.values());
            const templateFilename = ('object' == typeof config.output?.filename ? config.output.filename.bundle ?? config.output.filename.template : config.output?.filename) ?? '[name].[platform].bundle';
            const mainThreadEntry = `${entryName}__main-thread`;
            const mainThreadName = external_node_path_["default"].posix.join(isLynx ? DEFAULT_DIST_PATH_INTERMEDIATE : '', `${entryName}/main-thread.js`);
            const backgroundName = external_node_path_["default"].posix.join(isLynx ? DEFAULT_DIST_PATH_INTERMEDIATE : '', getBackgroundFilename(entryName, environment.config, isProd, experimental_isLazyBundle));
            const backgroundEntry = entryName;
            mainThreadChunks.push(mainThreadName);
            chain.entry(mainThreadEntry).add({
                layer: LAYERS.MAIN_THREAD,
                import: imports,
                filename: mainThreadName
            }).when(isDev && !isWeb, (entry)=>{
                const require = createRequire(import.meta.url);
                entry.prepend({
                    layer: LAYERS.MAIN_THREAD,
                    import: require.resolve('@lynx-js/css-extract-webpack-plugin/runtime/hotModuleReplacement.lepus.cjs')
                });
            }).end().entry(backgroundEntry).add({
                layer: LAYERS.BACKGROUND,
                import: imports,
                filename: backgroundName
            }).when(isDev && !isWeb, (entry)=>{
                entry.prepend({
                    layer: LAYERS.BACKGROUND,
                    import: '@rspack/core/hot/dev-server'
                }).prepend({
                    layer: LAYERS.BACKGROUND,
                    import: '@lynx-js/webpack-dev-transport/client'
                }).prepend({
                    layer: LAYERS.BACKGROUND,
                    import: '@lynx-js/react/refresh'
                });
            }).end().plugin(`${PLUGIN_NAME_TEMPLATE}-${entryName}`).use(LynxTemplatePlugin, [
                {
                    dsl: 'react_nodiff',
                    chunks: [
                        mainThreadEntry,
                        backgroundEntry
                    ],
                    filename: templateFilename.replaceAll('[name]', entryName).replaceAll('[platform]', environment.name),
                    intermediate: external_node_path_["default"].posix.join(DEFAULT_DIST_PATH_INTERMEDIATE, entryName),
                    customCSSInheritanceList,
                    debugInfoOutside,
                    defaultDisplayLinear,
                    enableA11y: true,
                    enableAccessibilityElement,
                    enableICU,
                    enableCSSInheritance,
                    enableCSSInvalidation,
                    enableCSSSelector,
                    enableNewGesture,
                    enableParallelElement,
                    enableRemoveCSSScope: enableRemoveCSSScope ?? true,
                    pipelineSchedulerConfig,
                    removeDescendantSelectorScope,
                    targetSdkVersion,
                    experimental_isLazyBundle,
                    cssPlugins: []
                }
            ]).end();
        });
        const rsbuildConfig = api.getRsbuildConfig();
        const userConfig = api.getRsbuildConfig('original');
        const enableChunkSplitting = rsbuildConfig.performance?.chunkSplit?.strategy !== 'all-in-one';
        if (isLynx) {
            let inlineScripts;
            inlineScripts = experimental_isLazyBundle ? true : environment.config.output?.inlineScripts ?? !enableChunkSplitting;
            chain.plugin(PLUGIN_NAME_RUNTIME_WRAPPER).use(RuntimeWrapperWebpackPlugin, [
                {
                    injectVars (vars) {
                        const UNUSED_VARS = new Set([
                            'Card',
                            'Component',
                            'ReactLynx',
                            'Behavior'
                        ]);
                        return vars.map((name)=>{
                            if (UNUSED_VARS.has(name)) return `__${name}`;
                            return name;
                        });
                    },
                    targetSdkVersion,
                    test: /^(?!.*main-thread(?:\.[A-Fa-f0-9]*)?\.js$).*\.js$/,
                    experimental_isLazyBundle
                }
            ]).end().plugin(`${LynxEncodePlugin.name}`).use(LynxEncodePlugin, [
                {
                    inlineScripts
                }
            ]).end();
        }
        if (isWeb) chain.plugin(PLUGIN_NAME_WEB).use(WebEncodePlugin, []).end();
        let extractStr = originalExtractStr;
        if (enableChunkSplitting && originalExtractStr) {
            logger.warn('`extractStr` is changed to `false` because it is only supported in `all-in-one` chunkSplit strategy, please set `performance.chunkSplit.strategy` to `all-in-one` to use `extractStr.`');
            extractStr = false;
        }
        chain.plugin(PLUGIN_NAME_REACT).after(PLUGIN_NAME_TEMPLATE).use(ReactWebpackPlugin, [
            {
                disableCreateSelectorQueryIncompatibleWarning: compat?.disableCreateSelectorQueryIncompatibleWarning ?? false,
                firstScreenSyncTiming,
                enableSSR,
                mainThreadChunks,
                extractStr,
                experimental_isLazyBundle,
                profile: getDefaultProfile()
            }
        ]);
        function getDefaultProfile() {
            if (userConfig.performance?.profile !== void 0) return userConfig.performance.profile;
            if (isDebug()) return true;
        }
    });
}
const isDebug = ()=>{
    if (!process.env['DEBUG']) return false;
    const values = process.env['DEBUG'].toLocaleLowerCase().split(',');
    return [
        'rspeedy',
        '*'
    ].some((key)=>values.includes(key));
};
function getChunks(entryName, entryValue) {
    const chunks = [
        entryName
    ];
    const imports = [];
    for (const item of entryValue){
        if ('string' == typeof item) {
            imports.push(item);
            continue;
        }
        if (Array.isArray(item)) {
            imports.push(...imports);
            continue;
        }
        const { dependOn } = item;
        if (Array.isArray(item.import)) imports.push(...item.import);
        else imports.push(item.import);
        if (dependOn) if ('string' == typeof dependOn) chunks.unshift(dependOn);
        else chunks.unshift(...dependOn);
    }
    return {
        chunks,
        imports
    };
}
function getBackgroundFilename(entryName, config, isProd, experimental_isLazyBundle) {
    const { filename } = config.output;
    if ('string' == typeof filename.js) return filename.js.replaceAll('[name]', entryName).replaceAll('.js', '/background.js');
    return `${entryName}/background${getHash(config, isProd, experimental_isLazyBundle)}.js`;
}
function getHash(config, isProd, experimental_isLazyBundle) {
    if ('string' == typeof config.output?.filenameHash) return config.output.filenameHash ? `.[${config.output.filenameHash}]` : EMPTY_HASH;
    if (config.output?.filenameHash === false) return EMPTY_HASH;
    if (isProd || experimental_isLazyBundle) return DEFAULT_FILENAME_HASH;
    return EMPTY_HASH;
}
function applyGenerator(api, options) {
    api.modifyBundlerChain({
        order: 'pre',
        handler: (chain)=>{
            const rule = chain.module.rule("react:json-parse").test(/\.json$/).type('json').generator({
                JSONParse: false
            });
            if (!options.extractStr) rule.issuerLayer(LAYERS.MAIN_THREAD);
        }
    });
}
function applyLazy(api) {
    api.modifyBundlerChain((chain)=>{
        chain.output.library({
            type: 'commonjs'
        });
    });
}
function applyLoaders(api, options) {
    const { compat, enableRemoveCSSScope, shake, defineDCE, experimental_isLazyBundle } = options;
    api.modifyBundlerChain((chain, { CHAIN_ID })=>{
        const experiments = chain.get('experiments');
        chain.experiments({
            ...experiments,
            layers: true
        });
        const rule = chain.module.rules.get(CHAIN_ID.RULE.JS);
        const uses = rule.uses.entries() ?? {};
        const { output } = api.getRsbuildConfig();
        const inlineSourcesContent = output?.sourceMap === true || !(output?.sourceMap === false || output?.sourceMap?.js === false || output?.sourceMap?.js?.includes('nosources'));
        const backgroundRule = rule.oneOf(LAYERS.BACKGROUND);
        backgroundRule.issuerLayer(LAYERS.BACKGROUND).uses.merge(uses).end().use(LAYERS.BACKGROUND).loader(ReactWebpackPlugin.loaders.BACKGROUND).options({
            compat,
            enableRemoveCSSScope,
            isDynamicComponent: experimental_isLazyBundle,
            inlineSourcesContent,
            defineDCE
        }).end();
        const mainThreadRule = rule.oneOf(LAYERS.MAIN_THREAD);
        mainThreadRule.issuerLayer(LAYERS.MAIN_THREAD).uses.merge(uses).end().when(void 0 !== uses[CHAIN_ID.USE.SWC], (rule)=>{
            rule.uses.delete(CHAIN_ID.USE.SWC);
            const swcLoaderRule = uses[CHAIN_ID.USE.SWC].entries();
            const swcLoaderOptions = swcLoaderRule.options;
            rule.use(CHAIN_ID.USE.SWC).merge(swcLoaderRule).options({
                ...swcLoaderOptions,
                jsc: {
                    ...swcLoaderOptions.jsc,
                    target: 'es2019'
                }
            });
        }).use(LAYERS.MAIN_THREAD).loader(ReactWebpackPlugin.loaders.MAIN_THREAD).options({
            compat,
            enableRemoveCSSScope,
            inlineSourcesContent,
            isDynamicComponent: experimental_isLazyBundle,
            shake,
            defineDCE
        }).end();
        rule.uses.clear();
    });
}
const PLUGIN_NAME_REACT_REFRESH = 'lynx:react:refresh';
const refresh_require = createRequire(import.meta.url);
function applyRefresh(api) {
    api.modifyWebpackChain((chain, { CHAIN_ID, isProd })=>{
        if (!isProd) applyRefreshRules(chain, CHAIN_ID, ReactRefreshWebpackPlugin);
    });
    api.modifyBundlerChain((chain, { isProd, CHAIN_ID })=>{
        if (!isProd) {
            applyRefreshRules(chain, CHAIN_ID, ReactRefreshRspackPlugin);
            chain.resolve.alias.set('@lynx-js/react/refresh$', refresh_require.resolve('@lynx-js/react/refresh')).end();
        }
    });
}
function applyRefreshRules(chain, CHAIN_ID, ReactRefreshPlugin) {
    chain.plugin(PLUGIN_NAME_REACT_REFRESH).before(CHAIN_ID.PLUGIN.HMR).use(ReactRefreshPlugin).end().module.rule('react:refresh').issuerLayer(LAYERS.BACKGROUND).before(CHAIN_ID.RULE.JS).test(/\.[jt]sx$/).exclude.add(/node_modules/).add(external_node_path_["default"].dirname(refresh_require.resolve('@lynx-js/react/package.json'))).add(external_node_path_["default"].dirname(refresh_require.resolve('@lynx-js/react/refresh'))).add(external_node_path_["default"].dirname(refresh_require.resolve('@lynx-js/react/worklet-runtime'))).add(ReactRefreshPlugin.loader).end().use('ReactRefresh').loader(ReactRefreshPlugin.loader).options({}).end().end().end().end();
}
const isPlainObject = (obj)=>null !== obj && 'object' == typeof obj && '[object Object]' === Object.prototype.toString.call(obj);
const applySplitChunksRule = (api)=>{
    api.modifyRsbuildConfig((config, { mergeRsbuildConfig })=>{
        const userConfig = api.getRsbuildConfig('original');
        if (!userConfig.performance?.chunkSplit?.strategy) return mergeRsbuildConfig(config, {
            performance: {
                chunkSplit: {
                    strategy: 'all-in-one'
                }
            }
        });
        return config;
    });
    api.modifyBundlerChain((chain, { environment })=>{
        const { config } = environment;
        if ('split-by-experience' !== config.performance.chunkSplit.strategy) return;
        const currentConfig = chain.optimization.splitChunks.values();
        if (!isPlainObject(currentConfig)) return;
        const extraGroups = {};
        extraGroups['preact'] = {
            name: 'lib-preact',
            test: /node_modules[\\/](.*?[\\/])?(?:preact|preact[\\/]compat|preact[\\/]hooks|preact[\\/]jsx-runtime)[\\/]/,
            priority: 0
        };
        chain.optimization.splitChunks({
            ...currentConfig,
            cacheGroups: {
                ...currentConfig.cacheGroups,
                ...extraGroups
            }
        });
    });
    api.modifyRspackConfig((rspackConfig, { environment })=>{
        if ('lynx' !== environment.name) return rspackConfig;
        if (!rspackConfig.optimization) return rspackConfig;
        if (!rspackConfig.optimization.splitChunks) return rspackConfig;
        rspackConfig.optimization.splitChunks.chunks = function(chunk) {
            return !chunk.name?.includes('__main-thread');
        };
        return rspackConfig;
    });
};
function applySWC(api) {
    api.modifyRsbuildConfig((config, { mergeRsbuildConfig })=>mergeRsbuildConfig({
            tools: {
                swc: {
                    jsc: {
                        transform: {
                            useDefineForClassFields: false,
                            optimizer: {
                                simplify: true
                            }
                        },
                        parser: {
                            syntax: "typescript",
                            tsx: false,
                            decorators: true
                        }
                    }
                }
            }
        }, config));
}
function applyUseSyncExternalStore(api) {
    api.modifyBundlerChain(async (chain)=>{
        const { resolve } = await __webpack_require__.e("860").then(__webpack_require__.bind(__webpack_require__, "./src/resolve.ts"));
        const useSyncExternalStoreEntries = [
            'use-sync-external-store',
            'use-sync-external-store/with-selector',
            'use-sync-external-store/shim',
            'use-sync-external-store/shim/with-selector'
        ];
        await Promise.all(useSyncExternalStoreEntries.map((entry)=>resolve(`@lynx-js/${entry}`).then((value)=>{
                chain.resolve.alias.set(`${entry}$`, value);
            })));
    });
}
var _accessExpressionAsString = __webpack_require__("../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/internal/_accessExpressionAsString.js");
var _assertGuard = __webpack_require__("../../../node_modules/.pnpm/typia@9.7.1_typescript@5.9.2/node_modules/typia/lib/internal/_assertGuard.js");
const validateConfig = (()=>{
    const _io0 = (input, _exceptionable = true)=>(void 0 === input.compat || "object" == typeof input.compat && null !== input.compat && false === Array.isArray(input.compat) && _io1(input.compat, _exceptionable)) && (void 0 === input.customCSSInheritanceList || Array.isArray(input.customCSSInheritanceList) && input.customCSSInheritanceList.every((elem, _index1)=>"string" == typeof elem)) && (void 0 === input.debugInfoOutside || "boolean" == typeof input.debugInfoOutside) && (void 0 === input.defaultDisplayLinear || "boolean" == typeof input.defaultDisplayLinear) && (void 0 === input.enableAccessibilityElement || "boolean" == typeof input.enableAccessibilityElement) && (void 0 === input.enableICU || "boolean" == typeof input.enableICU) && (void 0 === input.enableCSSInheritance || "boolean" == typeof input.enableCSSInheritance) && (void 0 === input.enableCSSInvalidation || "boolean" == typeof input.enableCSSInvalidation) && (void 0 === input.enableCSSSelector || "boolean" == typeof input.enableCSSSelector) && (void 0 === input.enableNewGesture || "boolean" == typeof input.enableNewGesture) && (void 0 === input.enableParallelElement || "boolean" == typeof input.enableParallelElement) && (void 0 === input.enableRemoveCSSScope || "boolean" == typeof input.enableRemoveCSSScope) && (void 0 === input.firstScreenSyncTiming || "immediately" === input.firstScreenSyncTiming || "jsReady" === input.firstScreenSyncTiming) && (void 0 === input.enableSSR || "boolean" == typeof input.enableSSR) && (void 0 === input.pipelineSchedulerConfig || "number" == typeof input.pipelineSchedulerConfig) && (void 0 === input.removeDescendantSelectorScope || "boolean" == typeof input.removeDescendantSelectorScope) && (void 0 === input.shake || "object" == typeof input.shake && null !== input.shake && false === Array.isArray(input.shake) && _io4(input.shake, _exceptionable)) && (void 0 === input.defineDCE || "object" == typeof input.defineDCE && null !== input.defineDCE && false === Array.isArray(input.defineDCE) && _io5(input.defineDCE, _exceptionable)) && (void 0 === input.engineVersion || "string" == typeof input.engineVersion) && (void 0 === input.targetSdkVersion || "string" == typeof input.targetSdkVersion) && null !== input.extractStr && (void 0 === input.extractStr || "boolean" == typeof input.extractStr || "object" == typeof input.extractStr && null !== input.extractStr && false === Array.isArray(input.extractStr) && _io7(input.extractStr, _exceptionable)) && (void 0 === input.experimental_isLazyBundle || "boolean" == typeof input.experimental_isLazyBundle) && (0 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "compat",
                "customCSSInheritanceList",
                "debugInfoOutside",
                "defaultDisplayLinear",
                "enableAccessibilityElement",
                "enableICU",
                "enableCSSInheritance",
                "enableCSSInvalidation",
                "enableCSSSelector",
                "enableNewGesture",
                "enableParallelElement",
                "enableRemoveCSSScope",
                "firstScreenSyncTiming",
                "enableSSR",
                "pipelineSchedulerConfig",
                "removeDescendantSelectorScope",
                "shake",
                "defineDCE",
                "engineVersion",
                "targetSdkVersion",
                "extractStr",
                "experimental_isLazyBundle"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io1 = (input, _exceptionable = true)=>(void 0 === input.componentsPkg || Array.isArray(input.componentsPkg) && input.componentsPkg.every((elem, _index2)=>"string" == typeof elem)) && (void 0 === input.oldRuntimePkg || Array.isArray(input.oldRuntimePkg) && input.oldRuntimePkg.every((elem, _index3)=>"string" == typeof elem)) && (void 0 === input.newRuntimePkg || "string" == typeof input.newRuntimePkg) && (void 0 === input.additionalComponentAttributes || Array.isArray(input.additionalComponentAttributes) && input.additionalComponentAttributes.every((elem, _index4)=>"string" == typeof elem)) && null !== input.addComponentElement && (void 0 === input.addComponentElement || "boolean" == typeof input.addComponentElement || "object" == typeof input.addComponentElement && null !== input.addComponentElement && _io2(input.addComponentElement, _exceptionable)) && (void 0 === input.simplifyCtorLikeReactLynx2 || "boolean" == typeof input.simplifyCtorLikeReactLynx2) && (void 0 === input.removeComponentAttrRegex || "string" == typeof input.removeComponentAttrRegex) && (void 0 === input.disableDeprecatedWarning || "boolean" == typeof input.disableDeprecatedWarning) && null !== input.darkMode && (void 0 === input.darkMode || "boolean" == typeof input.darkMode || "object" == typeof input.darkMode && null !== input.darkMode && _io3(input.darkMode, _exceptionable)) && (void 0 === input.disableCreateSelectorQueryIncompatibleWarning || "boolean" == typeof input.disableCreateSelectorQueryIncompatibleWarning) && (0 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "componentsPkg",
                "oldRuntimePkg",
                "newRuntimePkg",
                "additionalComponentAttributes",
                "addComponentElement",
                "simplifyCtorLikeReactLynx2",
                "removeComponentAttrRegex",
                "disableDeprecatedWarning",
                "darkMode",
                "disableCreateSelectorQueryIncompatibleWarning"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io2 = (input, _exceptionable = true)=>"boolean" == typeof input.compilerOnly && (1 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "compilerOnly"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io3 = (input, _exceptionable = true)=>"string" == typeof input.themeExpr && (1 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "themeExpr"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io4 = (input, _exceptionable = true)=>(void 0 === input.pkgName || Array.isArray(input.pkgName) && input.pkgName.every((elem, _index5)=>"string" == typeof elem)) && (void 0 === input.retainProp || Array.isArray(input.retainProp) && input.retainProp.every((elem, _index6)=>"string" == typeof elem)) && (void 0 === input.removeCallParams || Array.isArray(input.removeCallParams) && input.removeCallParams.every((elem, _index7)=>"string" == typeof elem)) && (0 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "pkgName",
                "retainProp",
                "removeCallParams"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io5 = (input, _exceptionable = true)=>(void 0 === input.define || "object" == typeof input.define && null !== input.define && false === Array.isArray(input.define) && _io6(input.define, _exceptionable)) && (0 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "define"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _io6 = (input, _exceptionable = true)=>Object.keys(input).every((key)=>{
            const value = input[key];
            if (void 0 === value) return true;
            return "string" == typeof value;
        });
    const _io7 = (input, _exceptionable = true)=>(void 0 === input.strLength || "number" == typeof input.strLength) && (0 === Object.keys(input).length || Object.keys(input).every((key)=>{
            if ([
                "strLength"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return false;
        }));
    const _ao0 = (input, _path, _exceptionable = true)=>(void 0 === input.compat || ("object" == typeof input.compat && null !== input.compat && false === Array.isArray(input.compat) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".compat",
            expected: "(Partial<CompatVisitorConfig> & { disableCreateSelectorQueryIncompatibleWarning?: boolean; } | undefined)",
            value: input.compat
        }, _errorFactory)) && _ao1(input.compat, _path + ".compat", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".compat",
            expected: "(Partial<CompatVisitorConfig> & { disableCreateSelectorQueryIncompatibleWarning?: boolean; } | undefined)",
            value: input.compat
        }, _errorFactory)) && (void 0 === input.customCSSInheritanceList || (Array.isArray(input.customCSSInheritanceList) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".customCSSInheritanceList",
            expected: "(Array<string> | undefined)",
            value: input.customCSSInheritanceList
        }, _errorFactory)) && input.customCSSInheritanceList.every((elem, _index8)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".customCSSInheritanceList[" + _index8 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".customCSSInheritanceList",
            expected: "(Array<string> | undefined)",
            value: input.customCSSInheritanceList
        }, _errorFactory)) && (void 0 === input.debugInfoOutside || "boolean" == typeof input.debugInfoOutside || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".debugInfoOutside",
            expected: "(boolean | undefined)",
            value: input.debugInfoOutside
        }, _errorFactory)) && (void 0 === input.defaultDisplayLinear || "boolean" == typeof input.defaultDisplayLinear || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".defaultDisplayLinear",
            expected: "(boolean | undefined)",
            value: input.defaultDisplayLinear
        }, _errorFactory)) && (void 0 === input.enableAccessibilityElement || "boolean" == typeof input.enableAccessibilityElement || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableAccessibilityElement",
            expected: "(boolean | undefined)",
            value: input.enableAccessibilityElement
        }, _errorFactory)) && (void 0 === input.enableICU || "boolean" == typeof input.enableICU || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableICU",
            expected: "(boolean | undefined)",
            value: input.enableICU
        }, _errorFactory)) && (void 0 === input.enableCSSInheritance || "boolean" == typeof input.enableCSSInheritance || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableCSSInheritance",
            expected: "(boolean | undefined)",
            value: input.enableCSSInheritance
        }, _errorFactory)) && (void 0 === input.enableCSSInvalidation || "boolean" == typeof input.enableCSSInvalidation || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableCSSInvalidation",
            expected: "(boolean | undefined)",
            value: input.enableCSSInvalidation
        }, _errorFactory)) && (void 0 === input.enableCSSSelector || "boolean" == typeof input.enableCSSSelector || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableCSSSelector",
            expected: "(boolean | undefined)",
            value: input.enableCSSSelector
        }, _errorFactory)) && (void 0 === input.enableNewGesture || "boolean" == typeof input.enableNewGesture || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableNewGesture",
            expected: "(boolean | undefined)",
            value: input.enableNewGesture
        }, _errorFactory)) && (void 0 === input.enableParallelElement || "boolean" == typeof input.enableParallelElement || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableParallelElement",
            expected: "(boolean | undefined)",
            value: input.enableParallelElement
        }, _errorFactory)) && (void 0 === input.enableRemoveCSSScope || "boolean" == typeof input.enableRemoveCSSScope || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableRemoveCSSScope",
            expected: "(boolean | undefined)",
            value: input.enableRemoveCSSScope
        }, _errorFactory)) && (void 0 === input.firstScreenSyncTiming || "immediately" === input.firstScreenSyncTiming || "jsReady" === input.firstScreenSyncTiming || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".firstScreenSyncTiming",
            expected: "(\"immediately\" | \"jsReady\" | undefined)",
            value: input.firstScreenSyncTiming
        }, _errorFactory)) && (void 0 === input.enableSSR || "boolean" == typeof input.enableSSR || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".enableSSR",
            expected: "(boolean | undefined)",
            value: input.enableSSR
        }, _errorFactory)) && (void 0 === input.pipelineSchedulerConfig || "number" == typeof input.pipelineSchedulerConfig || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".pipelineSchedulerConfig",
            expected: "(number | undefined)",
            value: input.pipelineSchedulerConfig
        }, _errorFactory)) && (void 0 === input.removeDescendantSelectorScope || "boolean" == typeof input.removeDescendantSelectorScope || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".removeDescendantSelectorScope",
            expected: "(boolean | undefined)",
            value: input.removeDescendantSelectorScope
        }, _errorFactory)) && (void 0 === input.shake || ("object" == typeof input.shake && null !== input.shake && false === Array.isArray(input.shake) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".shake",
            expected: "(Partial<ShakeVisitorConfig> | undefined)",
            value: input.shake
        }, _errorFactory)) && _ao4(input.shake, _path + ".shake", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".shake",
            expected: "(Partial<ShakeVisitorConfig> | undefined)",
            value: input.shake
        }, _errorFactory)) && (void 0 === input.defineDCE || ("object" == typeof input.defineDCE && null !== input.defineDCE && false === Array.isArray(input.defineDCE) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".defineDCE",
            expected: "(Partial<DefineDceVisitorConfig> | undefined)",
            value: input.defineDCE
        }, _errorFactory)) && _ao5(input.defineDCE, _path + ".defineDCE", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".defineDCE",
            expected: "(Partial<DefineDceVisitorConfig> | undefined)",
            value: input.defineDCE
        }, _errorFactory)) && (void 0 === input.engineVersion || "string" == typeof input.engineVersion || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".engineVersion",
            expected: "(string | undefined)",
            value: input.engineVersion
        }, _errorFactory)) && (void 0 === input.targetSdkVersion || "string" == typeof input.targetSdkVersion || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".targetSdkVersion",
            expected: "(string | undefined)",
            value: input.targetSdkVersion
        }, _errorFactory)) && (null !== input.extractStr || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".extractStr",
            expected: "(Partial<ExtractStrConfig> | boolean | undefined)",
            value: input.extractStr
        }, _errorFactory)) && (void 0 === input.extractStr || "boolean" == typeof input.extractStr || ("object" == typeof input.extractStr && null !== input.extractStr && false === Array.isArray(input.extractStr) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".extractStr",
            expected: "(Partial<ExtractStrConfig> | boolean | undefined)",
            value: input.extractStr
        }, _errorFactory)) && _ao7(input.extractStr, _path + ".extractStr", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".extractStr",
            expected: "(Partial<ExtractStrConfig> | boolean | undefined)",
            value: input.extractStr
        }, _errorFactory)) && (void 0 === input.experimental_isLazyBundle || "boolean" == typeof input.experimental_isLazyBundle || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".experimental_isLazyBundle",
            expected: "(boolean | undefined)",
            value: input.experimental_isLazyBundle
        }, _errorFactory)) && (0 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "compat",
                "customCSSInheritanceList",
                "debugInfoOutside",
                "defaultDisplayLinear",
                "enableAccessibilityElement",
                "enableICU",
                "enableCSSInheritance",
                "enableCSSInvalidation",
                "enableCSSSelector",
                "enableNewGesture",
                "enableParallelElement",
                "enableRemoveCSSScope",
                "firstScreenSyncTiming",
                "enableSSR",
                "pipelineSchedulerConfig",
                "removeDescendantSelectorScope",
                "shake",
                "defineDCE",
                "engineVersion",
                "targetSdkVersion",
                "extractStr",
                "experimental_isLazyBundle"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao1 = (input, _path, _exceptionable = true)=>(void 0 === input.componentsPkg || (Array.isArray(input.componentsPkg) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".componentsPkg",
            expected: "(Array<string> | undefined)",
            value: input.componentsPkg
        }, _errorFactory)) && input.componentsPkg.every((elem, _index9)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".componentsPkg[" + _index9 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".componentsPkg",
            expected: "(Array<string> | undefined)",
            value: input.componentsPkg
        }, _errorFactory)) && (void 0 === input.oldRuntimePkg || (Array.isArray(input.oldRuntimePkg) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".oldRuntimePkg",
            expected: "(Array<string> | undefined)",
            value: input.oldRuntimePkg
        }, _errorFactory)) && input.oldRuntimePkg.every((elem, _index10)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".oldRuntimePkg[" + _index10 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".oldRuntimePkg",
            expected: "(Array<string> | undefined)",
            value: input.oldRuntimePkg
        }, _errorFactory)) && (void 0 === input.newRuntimePkg || "string" == typeof input.newRuntimePkg || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".newRuntimePkg",
            expected: "(string | undefined)",
            value: input.newRuntimePkg
        }, _errorFactory)) && (void 0 === input.additionalComponentAttributes || (Array.isArray(input.additionalComponentAttributes) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".additionalComponentAttributes",
            expected: "(Array<string> | undefined)",
            value: input.additionalComponentAttributes
        }, _errorFactory)) && input.additionalComponentAttributes.every((elem, _index11)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".additionalComponentAttributes[" + _index11 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".additionalComponentAttributes",
            expected: "(Array<string> | undefined)",
            value: input.additionalComponentAttributes
        }, _errorFactory)) && (null !== input.addComponentElement || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".addComponentElement",
            expected: "(AddComponentElementConfig | boolean | undefined)",
            value: input.addComponentElement
        }, _errorFactory)) && (void 0 === input.addComponentElement || "boolean" == typeof input.addComponentElement || ("object" == typeof input.addComponentElement && null !== input.addComponentElement || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".addComponentElement",
            expected: "(AddComponentElementConfig | boolean | undefined)",
            value: input.addComponentElement
        }, _errorFactory)) && _ao2(input.addComponentElement, _path + ".addComponentElement", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".addComponentElement",
            expected: "(AddComponentElementConfig | boolean | undefined)",
            value: input.addComponentElement
        }, _errorFactory)) && (void 0 === input.simplifyCtorLikeReactLynx2 || "boolean" == typeof input.simplifyCtorLikeReactLynx2 || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".simplifyCtorLikeReactLynx2",
            expected: "(boolean | undefined)",
            value: input.simplifyCtorLikeReactLynx2
        }, _errorFactory)) && (void 0 === input.removeComponentAttrRegex || "string" == typeof input.removeComponentAttrRegex || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".removeComponentAttrRegex",
            expected: "(string | undefined)",
            value: input.removeComponentAttrRegex
        }, _errorFactory)) && (void 0 === input.disableDeprecatedWarning || "boolean" == typeof input.disableDeprecatedWarning || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".disableDeprecatedWarning",
            expected: "(boolean | undefined)",
            value: input.disableDeprecatedWarning
        }, _errorFactory)) && (null !== input.darkMode || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".darkMode",
            expected: "(DarkModeConfig | boolean | undefined)",
            value: input.darkMode
        }, _errorFactory)) && (void 0 === input.darkMode || "boolean" == typeof input.darkMode || ("object" == typeof input.darkMode && null !== input.darkMode || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".darkMode",
            expected: "(DarkModeConfig | boolean | undefined)",
            value: input.darkMode
        }, _errorFactory)) && _ao3(input.darkMode, _path + ".darkMode", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".darkMode",
            expected: "(DarkModeConfig | boolean | undefined)",
            value: input.darkMode
        }, _errorFactory)) && (void 0 === input.disableCreateSelectorQueryIncompatibleWarning || "boolean" == typeof input.disableCreateSelectorQueryIncompatibleWarning || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".disableCreateSelectorQueryIncompatibleWarning",
            expected: "(boolean | undefined)",
            value: input.disableCreateSelectorQueryIncompatibleWarning
        }, _errorFactory)) && (0 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "componentsPkg",
                "oldRuntimePkg",
                "newRuntimePkg",
                "additionalComponentAttributes",
                "addComponentElement",
                "simplifyCtorLikeReactLynx2",
                "removeComponentAttrRegex",
                "disableDeprecatedWarning",
                "darkMode",
                "disableCreateSelectorQueryIncompatibleWarning"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao2 = (input, _path, _exceptionable = true)=>("boolean" == typeof input.compilerOnly || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".compilerOnly",
            expected: "boolean",
            value: input.compilerOnly
        }, _errorFactory)) && (1 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "compilerOnly"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao3 = (input, _path, _exceptionable = true)=>("string" == typeof input.themeExpr || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".themeExpr",
            expected: "string",
            value: input.themeExpr
        }, _errorFactory)) && (1 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "themeExpr"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao4 = (input, _path, _exceptionable = true)=>(void 0 === input.pkgName || (Array.isArray(input.pkgName) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".pkgName",
            expected: "(Array<string> | undefined)",
            value: input.pkgName
        }, _errorFactory)) && input.pkgName.every((elem, _index12)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".pkgName[" + _index12 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".pkgName",
            expected: "(Array<string> | undefined)",
            value: input.pkgName
        }, _errorFactory)) && (void 0 === input.retainProp || (Array.isArray(input.retainProp) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".retainProp",
            expected: "(Array<string> | undefined)",
            value: input.retainProp
        }, _errorFactory)) && input.retainProp.every((elem, _index13)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".retainProp[" + _index13 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".retainProp",
            expected: "(Array<string> | undefined)",
            value: input.retainProp
        }, _errorFactory)) && (void 0 === input.removeCallParams || (Array.isArray(input.removeCallParams) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".removeCallParams",
            expected: "(Array<string> | undefined)",
            value: input.removeCallParams
        }, _errorFactory)) && input.removeCallParams.every((elem, _index14)=>"string" == typeof elem || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + ".removeCallParams[" + _index14 + "]",
                expected: "string",
                value: elem
            }, _errorFactory)) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".removeCallParams",
            expected: "(Array<string> | undefined)",
            value: input.removeCallParams
        }, _errorFactory)) && (0 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "pkgName",
                "retainProp",
                "removeCallParams"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao5 = (input, _path, _exceptionable = true)=>(void 0 === input.define || ("object" == typeof input.define && null !== input.define && false === Array.isArray(input.define) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".define",
            expected: "(Record<string, string> | undefined)",
            value: input.define
        }, _errorFactory)) && _ao6(input.define, _path + ".define", _exceptionable) || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".define",
            expected: "(Record<string, string> | undefined)",
            value: input.define
        }, _errorFactory)) && (0 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "define"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const _ao6 = (input, _path, _exceptionable = true)=>false === _exceptionable || Object.keys(input).every((key)=>{
            const value = input[key];
            if (void 0 === value) return true;
            return "string" == typeof value || _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "string",
                value: value
            }, _errorFactory);
        });
    const _ao7 = (input, _path, _exceptionable = true)=>(void 0 === input.strLength || "number" == typeof input.strLength || _assertGuard._assertGuard(_exceptionable, {
            method: "typia.createAssertEquals",
            path: _path + ".strLength",
            expected: "(number | undefined)",
            value: input.strLength
        }, _errorFactory)) && (0 === Object.keys(input).length || false === _exceptionable || Object.keys(input).every((key)=>{
            if ([
                "strLength"
            ].some((prop)=>key === prop)) return true;
            const value = input[key];
            if (void 0 === value) return true;
            return _assertGuard._assertGuard(_exceptionable, {
                method: "typia.createAssertEquals",
                path: _path + _accessExpressionAsString._accessExpressionAsString(key),
                expected: "undefined",
                value: value
            }, _errorFactory);
        }));
    const __is = (input, _exceptionable = true)=>void 0 === input || "object" == typeof input && null !== input && false === Array.isArray(input) && _io0(input, true);
    let _errorFactory;
    return (input, errorFactory = ({ path, expected, value })=>{
        if ('undefined' === expected) {
            const errorMessage = `Unknown property: \`${path}\` in the configuration of pluginReactLynx`;
            return new Error(errorMessage);
        }
        return new Error([
            `Invalid config on pluginReactLynx: \`${path}\`.`,
            `  - Expect to be ${expected}`,
            `  - Got: ${whatIs(value)}`,
            ''
        ].join('\n'));
    })=>{
        if (false === __is(input)) {
            _errorFactory = errorFactory;
            ((input, _path, _exceptionable = true)=>void 0 === input || ("object" == typeof input && null !== input && false === Array.isArray(input) || _assertGuard._assertGuard(true, {
                    method: "typia.createAssertEquals",
                    path: _path + "",
                    expected: "(PluginReactLynxOptions | undefined)",
                    value: input
                }, _errorFactory)) && _ao0(input, _path + "", true) || _assertGuard._assertGuard(true, {
                    method: "typia.createAssertEquals",
                    path: _path + "",
                    expected: "(PluginReactLynxOptions | undefined)",
                    value: input
                }, _errorFactory))(input, "$input", true);
        }
        return input;
    };
})();
function whatIs(value) {
    return Object.prototype.toString.call(value).replace(/^\[object\s+([a-z]+)\]$/i, '$1').toLowerCase();
}
function pluginReactLynx(userOptions) {
    validateConfig(userOptions);
    const engineVersion = userOptions?.engineVersion ?? userOptions?.targetSdkVersion ?? '3.2';
    const defaultOptions = {
        compat: void 0,
        customCSSInheritanceList: void 0,
        debugInfoOutside: true,
        defaultDisplayLinear: true,
        enableAccessibilityElement: false,
        enableICU: false,
        enableCSSInheritance: false,
        enableCSSInvalidation: true,
        enableCSSSelector: true,
        enableNewGesture: false,
        enableParallelElement: true,
        enableRemoveCSSScope: true,
        firstScreenSyncTiming: 'immediately',
        enableSSR: false,
        pipelineSchedulerConfig: 0x00010000,
        removeDescendantSelectorScope: true,
        shake: void 0,
        defineDCE: void 0,
        targetSdkVersion: '',
        engineVersion: '',
        extractStr: false,
        experimental_isLazyBundle: false
    };
    const resolvedOptions = Object.assign(defaultOptions, userOptions, {
        targetSdkVersion: engineVersion,
        engineVersion
    });
    return [
        (0, react_alias_rsbuild_plugin_.pluginReactAlias)({
            lazy: resolvedOptions.experimental_isLazyBundle,
            LAYERS: LAYERS
        }),
        {
            name: 'lynx:react',
            pre: [
                'lynx:rsbuild:plugin-api'
            ],
            setup (api) {
                applyCSS(api, resolvedOptions);
                applyEntry(api, resolvedOptions);
                applyBackgroundOnly(api);
                applyGenerator(api, resolvedOptions);
                applyLoaders(api, resolvedOptions);
                applyRefresh(api);
                applySplitChunksRule(api);
                applySWC(api);
                applyUseSyncExternalStore(api);
                api.modifyRsbuildConfig((config, { mergeRsbuildConfig })=>{
                    const userConfig = api.getRsbuildConfig('original');
                    if (void 0 === userConfig.source?.include) config = mergeRsbuildConfig(config, {
                        source: {
                            include: [
                                /\.(?:js|mjs|cjs)$/
                            ]
                        }
                    });
                    if (void 0 === userConfig.output?.inlineScripts) config = mergeRsbuildConfig(config, {
                        output: {
                            inlineScripts: true
                        }
                    });
                    config = mergeRsbuildConfig({
                        tools: {
                            rspack: {
                                output: {
                                    iife: false
                                }
                            }
                        }
                    }, config);
                    return config;
                });
                if (resolvedOptions.experimental_isLazyBundle) applyLazy(api);
                const rspeedyAPIs = api.useExposed(Symbol.for('rspeedy.api'));
                const require = createRequire(import.meta.url);
                const { version } = require('../package.json');
                rspeedyAPIs.debug(()=>{
                    const webpackPluginPath = require.resolve('@lynx-js/react-webpack-plugin');
                    return `Using @lynx-js/react-webpack-plugin v${version} at ${webpackPluginPath}`;
                });
            }
        }
    ];
}
export { LAYERS, pluginReactLynx };
