import * as __WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__ from "node:fs";
import * as __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__ from "node:path";
import * as __WEBPACK_EXTERNAL_MODULE_node_process_786449bf__ from "node:process";
import * as __WEBPACK_EXTERNAL_MODULE_node_readline_91c31510__ from "node:readline";
import * as __WEBPACK_EXTERNAL_MODULE_node_tty_c64aab7e__ from "node:tty";
import * as __WEBPACK_EXTERNAL_MODULE_node_util_1b29d436__ from "node:util";
var __webpack_modules__ = {
    "node:fs": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_fs_5ea92f0c__;
    },
    "node:path": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__;
    },
    "node:process": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_process_786449bf__;
    },
    "node:readline": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_readline_91c31510__;
    },
    "node:tty": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_tty_c64aab7e__;
    },
    "node:util": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_util_1b29d436__;
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
__webpack_require__.m = __webpack_modules__;
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.f = {};
    __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>{
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
})();
(()=>{
    __webpack_require__.u = (chunkId)=>"" + chunkId + ".js";
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    var installedChunks = {
        980: 0
    };
    var installChunk = (data)=>{
        var __webpack_ids__ = data.__webpack_ids__;
        var __webpack_modules__ = data.__webpack_modules__;
        var __webpack_runtime__ = data.__webpack_runtime__;
        var moduleId, chunkId, i = 0;
        for(moduleId in __webpack_modules__)if (__webpack_require__.o(__webpack_modules__, moduleId)) __webpack_require__.m[moduleId] = __webpack_modules__[moduleId];
        if (__webpack_runtime__) __webpack_runtime__(__webpack_require__);
        for(; i < __webpack_ids__.length; i++){
            chunkId = __webpack_ids__[i];
            if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) installedChunks[chunkId][0]();
            installedChunks[__webpack_ids__[i]] = 0;
        }
    };
    __webpack_require__.f.j = function(chunkId, promises) {
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : void 0;
        if (0 !== installedChunkData) if (installedChunkData) promises.push(installedChunkData[1]);
        else {
            var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e)=>{
                if (0 !== installedChunks[chunkId]) installedChunks[chunkId] = void 0;
                throw e;
            });
            var promise = Promise.race([
                promise,
                new Promise((resolve)=>{
                    installedChunkData = installedChunks[chunkId] = [
                        resolve
                    ];
                })
            ]);
            promises.push(installedChunkData[1] = promise);
        }
    };
})();
function generateDevUrls(api, entry, schemaFn, port) {
    const { dev: { assetPrefix } } = api.getNormalizedConfig();
    const { config } = api.useExposed(Symbol.for('rspeedy.api'));
    if ('string' != typeof assetPrefix) {
        const errorMsg = 'dev.assetPrefix is not string, skip printing QRCode';
        throw new Error(errorMsg);
    }
    const defaultFilename = '[name].[platform].bundle';
    const { filename } = config.output ?? {};
    let name;
    name = filename ? 'object' == typeof filename ? filename.bundle ?? filename.template ?? defaultFilename : filename : defaultFilename;
    const customSchema = schemaFn(new URL(name.replace('[name]', entry).replace('[platform]', 'lynx'), assetPrefix.replaceAll('<port>', String(port))).toString());
    return 'string' == typeof customSchema ? {
        default: customSchema
    } : customSchema;
}
const gExistingShortcuts = new WeakSet();
async function registerConsoleShortcuts(options) {
    const [{ default: showQRCode }] = await Promise.all([
        Promise.all([
            __webpack_require__.e("373"),
            __webpack_require__.e("640"),
            __webpack_require__.e("204")
        ]).then(__webpack_require__.bind(__webpack_require__, "./src/showQRCode.ts"))
    ]);
    const currentEntry = options.entries[0];
    const devUrls = generateDevUrls(options.api, currentEntry, options.schema, options.port);
    const value = Object.values(devUrls)[0];
    await options.onPrint?.(value);
    showQRCode(value);
    gExistingShortcuts.add(options);
    loop(options, value, devUrls);
    function off() {
        gExistingShortcuts.delete(options);
    }
    return off;
}
async function loop(options, value, devUrls) {
    const [{ autocomplete, select, selectKey, isCancel, cancel }, { default: showQRCode }] = await Promise.all([
        __webpack_require__.e("373").then(__webpack_require__.bind(__webpack_require__, "../../../node_modules/.pnpm/@clack+prompts@1.0.0-alpha.4/node_modules/@clack/prompts/dist/index.mjs")),
        Promise.all([
            __webpack_require__.e("373"),
            __webpack_require__.e("640"),
            __webpack_require__.e("204")
        ]).then(__webpack_require__.bind(__webpack_require__, "./src/showQRCode.ts"))
    ]);
    const selectFn = (length)=>length > 5 ? autocomplete : select;
    let currentEntry = options.entries[0];
    let currentSchema = Object.keys(devUrls)[0];
    while(!isCancel(value)){
        const name = await selectKey({
            message: 'Usage',
            options: [
                {
                    value: 'r',
                    label: 'Switch entries'
                },
                {
                    value: 'a',
                    label: 'Switch schema'
                },
                {
                    value: 'h',
                    label: 'Help'
                },
                ...Object.values(options.customShortcuts ?? {}),
                {
                    value: 'q',
                    label: 'Quit'
                }
            ],
            initialValue: 'q'
        });
        if (isCancel(name) || 'q' === name || !gExistingShortcuts.has(options)) break;
        if ('r' === name) {
            const selection = await selectFn(options.entries.length)({
                message: 'Select entry',
                options: options.entries.map((entry)=>({
                        value: entry,
                        label: entry,
                        hint: generateDevUrls(options.api, entry, options.schema, options.port)[currentSchema]
                    })),
                initialValue: currentEntry
            });
            if (isCancel(selection)) break;
            currentEntry = selection;
            value = getCurrentUrl();
        } else if ('a' === name) {
            const devUrls = generateDevUrls(options.api, currentEntry, options.schema, options.port);
            const selection = await selectFn(Object.keys(devUrls).length)({
                message: 'Select schema',
                options: Object.entries(devUrls).map(([name, url])=>({
                        value: name,
                        label: name,
                        hint: url
                    })),
                initialValue: currentSchema
            });
            if (isCancel(selection)) break;
            currentSchema = selection;
            value = getCurrentUrl();
        } else if (options.customShortcuts?.[name]) await options.customShortcuts[name].action?.();
        await options.onPrint?.(value);
        showQRCode(value);
    }
    if (gExistingShortcuts.has(options)) await exit(1);
    function getCurrentUrl() {
        return generateDevUrls(options.api, currentEntry, options.schema, options.port)[currentSchema];
    }
    function exit(code) {
        cancel('exiting...');
        const { exit } = options.api.useExposed(Symbol.for('rspeedy.api'));
        return exit(code);
    }
}
function pluginQRCode(options) {
    const defaultPluginOptions = {
        schema: (url)=>({
                http: url
            })
    };
    const { schema } = Object.assign({}, defaultPluginOptions, options);
    return {
        name: 'lynx:rsbuild:qrcode',
        pre: [
            'lynx:rsbuild:api'
        ],
        setup (api) {
            api.onAfterStartProdServer(async ({ environments, port })=>{
                await main(environments['lynx'], port);
            });
            let printedQRCode = false;
            api.onDevCompileDone(async ({ stats, environments })=>{
                if (!api.context.devServer) return;
                if (stats.hasErrors()) return;
                if (printedQRCode) return;
                printedQRCode = true;
                await main(environments['lynx'], api.context.devServer.port);
            });
            api.modifyRsbuildConfig((config)=>{
                const originalPrintUrl = config.server?.printUrls;
                if (false === originalPrintUrl || 'function' == typeof originalPrintUrl) return;
                config.server ??= {};
                config.server.printUrls = false;
            });
            async function main(environmentContext, port) {
                if (!environmentContext) return;
                const entries = Object.keys(environmentContext.entry);
                if (0 === entries.length) return;
                const unregister = await registerConsoleShortcuts({
                    entries,
                    api,
                    port,
                    schema
                });
                api.onCloseDevServer(unregister);
            }
        }
    };
}
export { pluginQRCode };
