export const __webpack_id__ = "vendors-node_modules_pnpm_javascript-stringify_2_1_0_node_modules_javascript-stringify_dist_i-562fbc";
export const __webpack_ids__ = [
    "vendors-node_modules_pnpm_javascript-stringify_2_1_0_node_modules_javascript-stringify_dist_i-562fbc"
];
export const __webpack_modules__ = {
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/array.js": function(__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.arrayToString = void 0;
        const arrayToString = (array, space, next)=>{
            const values = array.map(function(value, index) {
                const result = next(value, index);
                if (void 0 === result) return String(result);
                return space + result.split("\n").join(`\n${space}`);
            }).join(space ? ",\n" : ",");
            const eol = space && values ? "\n" : "";
            return `[${eol}${values}${eol}]`;
        };
        exports.arrayToString = arrayToString;
    },
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.FunctionParser = exports.dedentFunction = exports.functionToString = exports.USED_METHOD_KEY = void 0;
        const quote_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js");
        const METHOD_NAMES_ARE_QUOTED = '"' === ({
            " " () {}
        })[" "].toString().charAt(0);
        const FUNCTION_PREFIXES = {
            Function: "function ",
            GeneratorFunction: "function* ",
            AsyncFunction: "async function ",
            AsyncGeneratorFunction: "async function* "
        };
        const METHOD_PREFIXES = {
            Function: "",
            GeneratorFunction: "*",
            AsyncFunction: "async ",
            AsyncGeneratorFunction: "async *"
        };
        const TOKENS_PRECEDING_REGEXPS = new Set("case delete else in instanceof new return throw typeof void , ; : + - ! ~ & | ^ * / % < > ? =".split(" "));
        exports.USED_METHOD_KEY = new WeakSet();
        const functionToString = (fn, space, next, key)=>{
            const name = "string" == typeof key ? key : void 0;
            if (void 0 !== name) exports.USED_METHOD_KEY.add(fn);
            return new FunctionParser(fn, space, next, name).stringify();
        };
        exports.functionToString = functionToString;
        function dedentFunction(fnString) {
            let found;
            for (const line of fnString.split("\n").slice(1)){
                const m = /^[\s\t]+/.exec(line);
                if (!m) return fnString;
                const [str] = m;
                if (void 0 === found) found = str;
                else if (str.length < found.length) found = str;
            }
            return found ? fnString.split(`\n${found}`).join("\n") : fnString;
        }
        exports.dedentFunction = dedentFunction;
        class FunctionParser {
            constructor(fn, indent, next, key){
                this.fn = fn;
                this.indent = indent;
                this.next = next;
                this.key = key;
                this.pos = 0;
                this.hadKeyword = false;
                this.fnString = Function.prototype.toString.call(fn);
                this.fnType = fn.constructor.name;
                this.keyQuote = void 0 === key ? "" : quote_1.quoteKey(key, next);
                this.keyPrefix = void 0 === key ? "" : `${this.keyQuote}:${indent ? " " : ""}`;
                this.isMethodCandidate = void 0 === key ? false : "" === this.fn.name || this.fn.name === key;
            }
            stringify() {
                const value = this.tryParse();
                if (!value) return `${this.keyPrefix}void ${this.next(this.fnString)}`;
                return dedentFunction(value);
            }
            getPrefix() {
                if (this.isMethodCandidate && !this.hadKeyword) return METHOD_PREFIXES[this.fnType] + this.keyQuote;
                return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
            }
            tryParse() {
                if ("}" !== this.fnString[this.fnString.length - 1]) return this.keyPrefix + this.fnString;
                if (this.fn.name) {
                    const result = this.tryStrippingName();
                    if (result) return result;
                }
                const prevPos = this.pos;
                if ("class" === this.consumeSyntax()) return this.fnString;
                this.pos = prevPos;
                if (this.tryParsePrefixTokens()) {
                    const result = this.tryStrippingName();
                    if (result) return result;
                    let offset = this.pos;
                    switch(this.consumeSyntax("WORD_LIKE")){
                        case "WORD_LIKE":
                            if (this.isMethodCandidate && !this.hadKeyword) offset = this.pos;
                        case "()":
                            if ("=>" === this.fnString.substr(this.pos, 2)) return this.keyPrefix + this.fnString;
                            this.pos = offset;
                        case '"':
                        case "'":
                        case "[]":
                            return this.getPrefix() + this.fnString.substr(this.pos);
                    }
                }
            }
            tryStrippingName() {
                if (METHOD_NAMES_ARE_QUOTED) return;
                let start = this.pos;
                const prefix = this.fnString.substr(this.pos, this.fn.name.length);
                if (prefix === this.fn.name) {
                    this.pos += prefix.length;
                    if ("()" === this.consumeSyntax() && "{}" === this.consumeSyntax() && this.pos === this.fnString.length) {
                        if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) start += prefix.length;
                        return this.getPrefix() + this.fnString.substr(start);
                    }
                }
                this.pos = start;
            }
            tryParsePrefixTokens() {
                let posPrev = this.pos;
                this.hadKeyword = false;
                switch(this.fnType){
                    case "AsyncFunction":
                        if ("async" !== this.consumeSyntax()) return false;
                        posPrev = this.pos;
                    case "Function":
                        if ("function" === this.consumeSyntax()) this.hadKeyword = true;
                        else this.pos = posPrev;
                        return true;
                    case "AsyncGeneratorFunction":
                        if ("async" !== this.consumeSyntax()) return false;
                    case "GeneratorFunction":
                        let token = this.consumeSyntax();
                        if ("function" === token) {
                            token = this.consumeSyntax();
                            this.hadKeyword = true;
                        }
                        return "*" === token;
                }
            }
            consumeSyntax(wordLikeToken) {
                const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/);
                if (!m) return;
                const [token, match] = m;
                this.consumeWhitespace();
                if (match) return wordLikeToken || match;
                switch(token){
                    case "(":
                        return this.consumeSyntaxUntil("(", ")");
                    case "[":
                        return this.consumeSyntaxUntil("[", "]");
                    case "{":
                        return this.consumeSyntaxUntil("{", "}");
                    case "`":
                        return this.consumeTemplate();
                    case '"':
                        return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
                    case "'":
                        return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
                }
                return token;
            }
            consumeSyntaxUntil(startToken, endToken) {
                let isRegExpAllowed = true;
                for(;;){
                    const token = this.consumeSyntax();
                    if (token === endToken) return startToken + endToken;
                    if (!token || ")" === token || "]" === token || "}" === token) return;
                    if ("/" === token && isRegExpAllowed && this.consumeMatch(/^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/)) {
                        isRegExpAllowed = false;
                        this.consumeWhitespace();
                    } else isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);
                }
            }
            consumeMatch(re) {
                const m = re.exec(this.fnString.substr(this.pos));
                if (m) this.pos += m[0].length;
                return m;
            }
            consumeRegExp(re, token) {
                const m = re.exec(this.fnString.substr(this.pos));
                if (!m) return;
                this.pos += m[0].length;
                this.consumeWhitespace();
                return token;
            }
            consumeTemplate() {
                for(;;){
                    this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/);
                    if ("`" === this.fnString[this.pos]) {
                        this.pos++;
                        this.consumeWhitespace();
                        return "`";
                    }
                    if ("${" === this.fnString.substr(this.pos, 2)) {
                        this.pos += 2;
                        this.consumeWhitespace();
                        if (this.consumeSyntaxUntil("{", "}")) continue;
                    }
                    return;
                }
            }
            consumeWhitespace() {
                this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
            }
        }
        exports.FunctionParser = FunctionParser;
    },
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/index.js": function(__unused_webpack_module, exports, __webpack_require__) {
        exports.stringify = void 0;
        const stringify_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/stringify.js");
        const quote_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js");
        const ROOT_SENTINEL = Symbol("root");
        function stringify(value, replacer, indent, options = {}) {
            const space = "string" == typeof indent ? indent : " ".repeat(indent || 0);
            const path = [];
            const stack = new Set();
            const tracking = new Map();
            const unpack = new Map();
            let valueCount = 0;
            const { maxDepth = 100, references = false, skipUndefinedProperties = false, maxValues = 100000 } = options;
            const valueToString = replacerToString(replacer);
            const onNext = (value, key)=>{
                if (++valueCount > maxValues) return;
                if (skipUndefinedProperties && void 0 === value) return;
                if (path.length > maxDepth) return;
                if (void 0 === key) return valueToString(value, space, onNext, key);
                path.push(key);
                const result = builder(value, key === ROOT_SENTINEL ? void 0 : key);
                path.pop();
                return result;
            };
            const builder = references ? (value, key)=>{
                if (null !== value && ("object" == typeof value || "function" == typeof value || "symbol" == typeof value)) {
                    if (tracking.has(value)) {
                        unpack.set(path.slice(1), tracking.get(value));
                        return valueToString(void 0, space, onNext, key);
                    }
                    tracking.set(value, path.slice(1));
                }
                return valueToString(value, space, onNext, key);
            } : (value, key)=>{
                if (stack.has(value)) return;
                stack.add(value);
                const result = valueToString(value, space, onNext, key);
                stack.delete(value);
                return result;
            };
            const result = onNext(value, ROOT_SENTINEL);
            if (unpack.size) {
                const sp = space ? " " : "";
                const eol = space ? "\n" : "";
                let wrapper = `var x${sp}=${sp}${result};${eol}`;
                for (const [key, value] of unpack.entries()){
                    const keyPath = quote_1.stringifyPath(key, onNext);
                    const valuePath = quote_1.stringifyPath(value, onNext);
                    wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
                }
                return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
            }
            return result;
        }
        exports.stringify = stringify;
        function replacerToString(replacer) {
            if (!replacer) return stringify_1.toString;
            return (value, space, next, key)=>replacer(value, space, (value)=>stringify_1.toString(value, space, next, key), key);
        }
    },
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/object.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.objectToString = void 0;
        const quote_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js");
        const function_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js");
        const array_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/array.js");
        const objectToString = (value, space, next, key)=>{
            if ("function" == typeof Buffer && Buffer.isBuffer(value)) return `Buffer.from(${next(value.toString("base64"))}, 'base64')`;
            if ("object" == typeof global && value === global) return globalToString(value, space, next, key);
            const toString = OBJECT_TYPES[Object.prototype.toString.call(value)];
            return toString ? toString(value, space, next, key) : void 0;
        };
        exports.objectToString = objectToString;
        const rawObjectToString = (obj, indent, next, key)=>{
            const eol = indent ? "\n" : "";
            const space = indent ? " " : "";
            const values = Object.keys(obj).reduce(function(values, key) {
                const fn = obj[key];
                const result = next(fn, key);
                if (void 0 === result) return values;
                const value = result.split("\n").join(`\n${indent}`);
                if (function_1.USED_METHOD_KEY.has(fn)) {
                    values.push(`${indent}${value}`);
                    return values;
                }
                values.push(`${indent}${quote_1.quoteKey(key, next)}:${space}${value}`);
                return values;
            }, []).join(`,${eol}`);
            if ("" === values) return "{}";
            return `{${eol}${values}${eol}}`;
        };
        const globalToString = (value, space, next)=>`Function(${next("return this")})()`;
        const OBJECT_TYPES = {
            "[object Array]": array_1.arrayToString,
            "[object Object]": rawObjectToString,
            "[object Error]": (error, space, next)=>`new Error(${next(error.message)})`,
            "[object Date]": (date)=>`new Date(${date.getTime()})`,
            "[object String]": (str, space, next)=>`new String(${next(str.toString())})`,
            "[object Number]": (num)=>`new Number(${num})`,
            "[object Boolean]": (bool)=>`new Boolean(${bool})`,
            "[object Set]": (set, space, next)=>`new Set(${next(Array.from(set))})`,
            "[object Map]": (map, space, next)=>`new Map(${next(Array.from(map))})`,
            "[object RegExp]": String,
            "[object global]": globalToString,
            "[object Window]": globalToString
        };
    },
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js": function(__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.stringifyPath = exports.quoteKey = exports.isValidVariableName = exports.IS_VALID_IDENTIFIER = exports.quoteString = void 0;
        const ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        const META_CHARS = new Map([
            [
                "\b",
                "\\b"
            ],
            [
                "\t",
                "\\t"
            ],
            [
                "\n",
                "\\n"
            ],
            [
                "\f",
                "\\f"
            ],
            [
                "\r",
                "\\r"
            ],
            [
                "'",
                "\\'"
            ],
            [
                '"',
                '\\"'
            ],
            [
                "\\",
                "\\\\"
            ]
        ]);
        function escapeChar(char) {
            return META_CHARS.get(char) || `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`;
        }
        function quoteString(str) {
            return `'${str.replace(ESCAPABLE, escapeChar)}'`;
        }
        exports.quoteString = quoteString;
        const RESERVED_WORDS = new Set("break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "));
        exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
        function isValidVariableName(name) {
            return "string" == typeof name && !RESERVED_WORDS.has(name) && exports.IS_VALID_IDENTIFIER.test(name);
        }
        exports.isValidVariableName = isValidVariableName;
        function quoteKey(key, next) {
            return isValidVariableName(key) ? key : next(key);
        }
        exports.quoteKey = quoteKey;
        function stringifyPath(path, next) {
            let result = "";
            for (const key of path)if (isValidVariableName(key)) result += `.${key}`;
            else result += `[${next(key)}]`;
            return result;
        }
        exports.stringifyPath = stringifyPath;
    },
    "../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/stringify.js": function(__unused_webpack_module, exports, __webpack_require__) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.toString = void 0;
        const quote_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js");
        const object_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/object.js");
        const function_1 = __webpack_require__("../../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js");
        const PRIMITIVE_TYPES = {
            string: quote_1.quoteString,
            number: (value)=>Object.is(value, -0) ? "-0" : String(value),
            boolean: String,
            symbol: (value, space, next)=>{
                const key = Symbol.keyFor(value);
                if (void 0 !== key) return `Symbol.for(${next(key)})`;
                return `Symbol(${next(value.description)})`;
            },
            bigint: (value, space, next)=>`BigInt(${next(String(value))})`,
            undefined: String,
            object: object_1.objectToString,
            function: function_1.functionToString
        };
        const toString = (value, space, next, key)=>{
            if (null === value) return "null";
            return PRIMITIVE_TYPES[typeof value](value, space, next, key);
        };
        exports.toString = toString;
    }
};
