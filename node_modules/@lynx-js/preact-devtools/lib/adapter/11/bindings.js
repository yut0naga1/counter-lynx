import { HookType } from "../shared/hooks";
// Internal.flags bitfield constants
export const TYPE_TEXT = 1 << 0;
export const TYPE_ELEMENT = 1 << 1;
export const TYPE_CLASS = 1 << 2;
export const TYPE_FUNCTION = 1 << 3;
/** Signals this internal has a _parentDom prop that should change the parent
 * DOM node of it's children */
export const TYPE_ROOT = 1 << 4;
/** Any type of internal representing DOM */
export const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;
/** Any type of component */
export const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;
export function isComponent(internal) {
    return (internal.flags & TYPE_COMPONENT) > 0;
}
export function isInternal(x) {
    return (x !== null &&
        typeof x === "object" &&
        (typeof x.__v === "number" || typeof x._vnodeId === "number"));
}
export function isTextInternal(internal) {
    return (internal.flags & TYPE_TEXT) > 0;
}
export function getComponentHooks(internal) {
    const data = internal.data;
    if (data == null)
        return null;
    return data.__hooks || data.__H || null;
}
export function isSuspenseVNode(internal) {
    const c = getComponent(internal);
    // FYI: Mangling of `_childDidSuspend` is not stable in Preact < 10.3.0
    return c != null && !!(c._childDidSuspend || c.__c);
}
export function getSuspenseStateKey(c) {
    if ("_suspended" in c.state) {
        return "_suspended";
    }
    else if ("__e" in c.state) {
        return "__e";
    }
    // This is a bit whacky, but property name mangling is unsafe in
    // Preact <10.4.9
    const keys = Object.keys(c.state);
    if (keys.length > 0) {
        return keys[0];
    }
    return null;
}
// Mangle accessors
// When serializing props we're dealing with vnodes instead of
// internal objects
export function getPropsVNodeDisplayName(vnode, config) {
    const { type } = vnode;
    if (typeof type === "function") {
        if (type === config.Fragment)
            return "Fragment";
        // Context is a special case :((
        // See: https://reactjs.org/docs/context.html#contextdisplayname
        // Consumer
        const ct = type.contextType;
        if (ct && ct.Consumer === type && ct.displayName) {
            return `${ct.displayName}.Consumer`;
        }
        // Provider
        const ctx = type._contextRef || type.__;
        if (ctx && ctx.displayName) {
            return `${ctx.displayName}.Provider`;
        }
        if (type.prototype &&
            (typeof type.prototype.__c === "function" ||
                typeof type.prototype._childDidSuspend === "function")) {
            return "Suspense";
        }
        else if ("__P" in vnode.props || "_parentDom" in vnode.props) {
            return "Portal";
        }
        return type.displayName || type.name || "Anonymous";
    }
    else if (typeof type === "string") {
        return vnode.type;
    }
    return "#text";
}
export function getDisplayName(internal, config) {
    const { flags, type } = internal;
    if (flags & TYPE_COMPONENT) {
        if (type === config.Fragment)
            return "Fragment";
        // Context is a special case :((
        // See: https://reactjs.org/docs/context.html#contextdisplayname
        // Consumer
        const ct = type.contextType;
        if (ct && ct.Consumer === type && ct.displayName) {
            return `${ct.displayName}.Consumer`;
        }
        // Provider
        const ctx = type._contextRef || type.__;
        if (ctx && ctx.displayName) {
            return `${ctx.displayName}.Provider`;
        }
        if (isSuspenseVNode(internal)) {
            return "Suspense";
        }
        else if (isPortal(internal)) {
            return "Portal";
        }
        return type.displayName || type.name || "Anonymous";
    }
    else if (flags & TYPE_ELEMENT) {
        return internal.type;
    }
    return "#text";
}
export function getActualChildren(internal) {
    return internal._children || internal.__k || [];
}
export function getComponent(node) {
    return node._component || node.__c || null;
}
export function isElement(node) {
    return (node.flags & TYPE_ELEMENT) > 0;
}
export function getNextState(c) {
    return c._nextState || c.__s || null;
}
export function setNextState(c, value) {
    return (c._nextState = c.__s = value);
}
export function getDom(internal) {
    return internal._dom || internal.__e || null;
}
/**
 * Get the direct parent of a `vnode`
 */
export function getVNodeParent(internal) {
    return internal._parent || internal.__ || null;
}
/**
 * Check if a `vnode` is the root of a tree
 */
export function isRoot(internal, config) {
    return getVNodeParent(internal) == null && internal.type === config.Fragment;
}
export function getStatefulHooks(internal) {
    const hooks = getComponentHooks(internal);
    return hooks !== null ? hooks._list || hooks.__ || null : null;
}
export function isUseReducerOrState(hookState) {
    return !!hookState._internal || !!hookState.__i;
}
export function getStatefulHookValue(hookState) {
    if (hookState !== null) {
        const value = hookState._value || hookState.__ || null;
        if (value !== null && Array.isArray(value)) {
            return value[0];
        }
    }
    return null;
}
export function getHookState(internal, index, type) {
    const c = getComponent(internal);
    if (c === null)
        return [];
    const list = getStatefulHooks(internal);
    if (list && list[index]) {
        // useContext
        if (type === HookType.useContext) {
            const context = list[index]._context || list[index].__c || list[index].c;
            const provider = c.context[context._id] || c.context[context.__c];
            return provider
                ? provider.props.value
                : context._defaultValue || context.__;
        }
        const value = getPendingHookValue(list[index]);
        if (type === HookType.useRef) {
            return value[0].current;
        }
        else if (type === HookType.useErrorBoundary && !value) {
            return "__preact_empty__";
        }
        return value;
    }
    return [];
}
export function getPendingHookValue(state) {
    return state._value !== undefined ? state._value : state.__;
}
export function setPendingHookValue(state, value) {
    if ("_value" in state) {
        state._value = value;
    }
    else {
        state.__ = value;
    }
}
export function createSuspenseState(vnode, suspended) {
    const c = getComponent(vnode);
    const key = getSuspenseStateKey(c);
    if (c && key) {
        return { [key]: suspended };
    }
    return {};
}
export function getSuspendedState(internal) {
    const c = getComponent(internal);
    if (c) {
        const key = getSuspenseStateKey(c);
        if (key) {
            return !!c._nextState[key];
        }
    }
    return null;
}
const getInstance = (x) => x;
export function isPortal(internal) {
    return "__P" in internal.props || "_parentDom" in internal.props;
}
export function getVNodeId(vnode) {
    return vnode._vnodeId || vnode.__v || 0;
}
export const bindingsV11 = {
    isRoot,
    getDisplayName,
    getPropsVNodeDisplayName,
    getActualChildren,
    getDom,
    isTextVNode: isTextInternal,
    getInstance,
    createSuspenseState,
    getComponent,
    getComponentHooks,
    getHookState,
    getPendingHookValue,
    setPendingHookValue,
    getVNodeParent,
    isComponent,
    isElement,
    isSuspenseVNode,
    isVNode: isInternal,
    getSuspendedState,
    setNextState,
    isPortal,
    getStatefulHookValue,
    getStatefulHooks,
    isUseReducerOrState,
    getRenderReasonPost() {
        return null;
    },
};
