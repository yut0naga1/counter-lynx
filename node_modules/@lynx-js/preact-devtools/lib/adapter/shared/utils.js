export function getSignalTextName(name) {
    return name === "_st" ? "__TextSignal" : name;
}
export function traverse(vnode, fn, bindings) {
    fn(vnode);
    const children = bindings.getActualChildren(vnode);
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child != null) {
            traverse(child, fn, bindings);
            fn(child);
        }
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
export function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
export function newRootData(id, node) {
    return { id, node };
}
export function sortRoots(searchRoot, roots) {
    const map = new Map();
    const walking = new Set();
    walking.add(searchRoot);
    for (let i = 0; i < roots.length; i++) {
        let node = roots[i].node;
        // Update root map. Note that multiple roots can point
        // to the same container node
        if (!map.has(node)) {
            map.set(node, []);
        }
        map.get(node).push(roots[i].id);
        while (node !== null && node !== searchRoot) {
            if (walking.has(node))
                break;
            walking.add(node);
            node = node.parentNode;
        }
    }
    const stack = [searchRoot];
    let out = [];
    let item;
    while ((item = stack.pop()) !== undefined) {
        if (!walking.has(item))
            continue;
        if (item.nodeName !== "IFRAME") {
            const len = item.childNodes.length;
            for (let i = 0; i < len; i++) {
                stack.push(item.childNodes[len - i - 1]);
            }
        }
        const found = map.get(item);
        if (found !== undefined) {
            out = out.concat(found);
        }
    }
    return out;
}
