import { parseStackTrace } from "errorstacks";
import { h } from "preact";
import { parseProps, } from "../../view/components/sidebar/inspect/parseProps";
import { isEditable, serialize } from "./serialize";
import { flattenChildren } from "../../view/components/tree/windowing";
export var HookType;
(function (HookType) {
    HookType[HookType["useState"] = 1] = "useState";
    HookType[HookType["useReducer"] = 2] = "useReducer";
    HookType[HookType["useEffect"] = 3] = "useEffect";
    HookType[HookType["useLayoutEffect"] = 4] = "useLayoutEffect";
    HookType[HookType["useRef"] = 5] = "useRef";
    HookType[HookType["useImperativeHandle"] = 6] = "useImperativeHandle";
    HookType[HookType["useMemo"] = 7] = "useMemo";
    HookType[HookType["useCallback"] = 8] = "useCallback";
    HookType[HookType["useContext"] = 9] = "useContext";
    HookType[HookType["useErrorBoundary"] = 10] = "useErrorBoundary";
    HookType[HookType["useDebugValue"] = 11] = "useDebugValue";
    HookType[HookType["custom"] = 99] = "custom";
    HookType[HookType["devtoolsParent"] = 9999] = "devtoolsParent";
})(HookType || (HookType = {}));
let hookLog = [];
let inspectingHooks = false;
let ancestorName = "unknown";
const debugValues = new Map();
let debugNames = [];
export function addHookName(name) {
    if (!inspectingHooks)
        return;
    debugNames.push(String(name));
}
export function addDebugValue(value) {
    if (!inspectingHooks)
        return;
    const last = hookLog.pop();
    const location = last.stack
        .reverse()
        .slice(0, -1)
        .map(x => (x.name === "root" ? x.name : `${x.location}.${x.name}`))
        .join(".");
    debugValues.set(location, value);
}
let ignoreNext = false;
export function addHookStack(type) {
    if (!inspectingHooks || ignoreNext) {
        ignoreNext = false;
        return;
    }
    // Ignore next useState call coming from useErrorBoundary
    if (type === HookType.useErrorBoundary) {
        ignoreNext = true;
    }
    // By default browser limit stack trace length to 10 entries
    const oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1000;
    const err = new Error();
    let stack = err.stack ? parseStackTrace(err.stack) : [];
    const ancestorIdx = stack.findIndex(x => x.name === ancestorName);
    if (ancestorIdx > -1 && stack.length > 0) {
        // Remove `addHookStack` + `options._hook` + `getHookState` from stack
        let trim = type === HookType.useDebugValue ? 2 : 3;
        // These hooks are implemented with other hooks
        if (type === HookType.useState ||
            type === HookType.useImperativeHandle ||
            type === HookType.useCallback ||
            type === HookType.useRef) {
            trim += 1;
        }
        // Lynx has one more `call at call (native)` stack, we need `- 1` here
        stack = stack.slice(trim, ancestorIdx - 1);
    }
    const normalized = [];
    // To easy mappings we'll rotate all positional data.
    for (let i = 0; i < stack.length; i++) {
        if (i === stack.length - 1) {
            normalized.push({ name: "root", location: "root" });
            continue;
        }
        const frame = stack[i];
        const next = stack[i + 1];
        normalized.push({
            name: frame.name,
            // file://view2/.rspeedy/main/background.ed172d51.js -> /.rspeedy/main/background.ed172d51.js
            location: `${next.fileName.replace(/^file:\/\/[^/]*/, "")}:${next.line}:${next.column}`,
        });
    }
    hookLog.push({ type, stack: normalized });
    // Restore original stack trace limit
    Error.stackTraceLimit = oldLimit;
}
export function parseHookData(config, data, vnode, userHookNames, bindings) {
    const tree = new Map();
    const root = {
        children: [],
        depth: 0,
        name: "root",
        editable: false,
        id: "root",
        type: "object",
        value: null,
        meta: null,
    };
    tree.set("root", root);
    const out = [root];
    data.forEach((hook, hookIdx) => {
        const type = HookType[hook.type];
        let parentId = "root";
        for (let i = hook.stack.length - 2; i >= 0; i--) {
            const frame = hook.stack[i];
            const isNative = i === 0;
            const id = `${parentId}.${frame.location}.${frame.name}`;
            if (!tree.has(id)) {
                let value = "__preact_empty__";
                let editable = false;
                let children = [];
                let nodeType = "undefined";
                const depth = hook.stack.length - i - 1;
                let name = isNative ? type : frame.name;
                if (isNative &&
                    userHookNames.length > 0 &&
                    (hook.type === HookType.useState ||
                        hook.type === HookType.useRef ||
                        hook.type === HookType.useMemo ||
                        hook.type === HookType.useReducer)) {
                    name = `${name} ${userHookNames.pop()}`;
                }
                if (debugValues.has(id)) {
                    value = serialize(config, bindings, debugValues.get(id));
                }
                const hookValueTree = [];
                if (isNative) {
                    const s = bindings.getHookState(vnode, hookIdx, hook.type);
                    const rawValue = Array.isArray(s) ? s[0] : s;
                    value = serialize(config, bindings, rawValue);
                    // The user should be able to click through the value
                    // properties if the value is an object. We parse it
                    // separately and append it as children to our hook node
                    if (typeof rawValue === "object" &&
                        !(rawValue instanceof preactDevtoolsCtx.Node)) {
                        const valueTree = parseProps(value, id, 8, 1, name);
                        children = valueTree.get(id).children;
                        const flat = flattenChildren(valueTree, id, () => false).slice(1);
                        for (let j = 0; j < flat.length; j++) {
                            const data = valueTree.get(flat[j]);
                            hookValueTree.push(data);
                        }
                        if (hookValueTree.length > 1) {
                            nodeType = hookValueTree[0].type;
                        }
                    }
                    editable =
                        (hook.type === HookType.useState ||
                            hook.type === HookType.useReducer) &&
                            isEditable(rawValue);
                }
                const item = {
                    children,
                    depth,
                    editable,
                    id,
                    name,
                    type: nodeType,
                    meta: isNative
                        ? {
                            index: hookIdx,
                            type,
                        }
                        : frame.name,
                    value,
                    index: hookIdx,
                };
                tree.set(id, item);
                out.push(item);
                if (tree.has(parentId)) {
                    tree.get(parentId).children.push(id);
                }
                if (hookValueTree.length) {
                    hookValueTree.forEach(v => {
                        tree.set(v.id, v);
                        out.push(v);
                    });
                }
            }
            parentId = id;
        }
    });
    return out;
}
export function inspectHooks(config, options, vnode, helpers) {
    inspectingHooks = true;
    hookLog = [];
    debugValues.clear();
    debugNames = [];
    ancestorName = parseStackTrace(new Error().stack)[0].name;
    const c = helpers.getComponent(vnode);
    const isClass = vnode.type.prototype && vnode.type.prototype.render;
    // Disable hook effects
    options._skipEffects = options.__s = true;
    const prevConsole = {};
    // Temporarily disable all console methods to not confuse users
    // It sucks that we need to do this :/
    for (const method in console) {
        try {
            prevConsole[method] = console[method];
            console[method] = () => undefined;
        }
        catch (error) {
            // Ignore errors here
        }
    }
    let pendingValues = null;
    let statefulHooks = null;
    try {
        // Call render on a dummy component, so that any possible
        // state changes or effect are not written to our original
        // component.
        const hooks = helpers.getComponentHooks(vnode);
        if (hooks === null)
            return [];
        statefulHooks = helpers.getStatefulHooks(vnode);
        if (statefulHooks !== null) {
            pendingValues = statefulHooks.map(s => helpers.getPendingHookValue(s));
        }
        const dummy = {
            props: c.props,
            context: c.context,
            state: {},
            __hooks: hooks,
            __H: hooks,
            __v: null,
        };
        // Force preact to reset internal hooks index
        const renderHook = options.__r || options._render;
        if (renderHook) {
            const dummyVNode = h("div", null);
            // Note: A "div" normally won't have the _component property set,
            // but we can get away with that for the devtools
            // This is only needed for Preact 10.x
            dummyVNode._component = dummy;
            dummyVNode.__c = dummy;
            dummy.__v = dummyVNode;
            // Preact V11 for hook names
            dummyVNode.data = {
                __hooks: hooks,
                __H: hooks,
            };
            renderHook(dummyVNode, null);
        }
        if (isClass) {
            c.render.call(dummy, dummy.props, dummy.state);
        }
        else {
            // Preact V11 doesn't create classes anymore
            if (c.constructor === Object) {
                vnode.type.call(dummy, dummy.props, dummy.context);
            }
            else {
                c.constructor.call(dummy, dummy.props, dummy.context);
            }
        }
        // Signals need this, otherwise they end up in an incosnistent state
        const diffedHook = options.diffed;
        if (diffedHook)
            diffedHook(vnode);
    }
    catch (error) {
        // We don't care about any errors here. We only need
        // the hook call sites
    }
    finally {
        // Restore hook state
        if (pendingValues !== null && statefulHooks !== null) {
            pendingValues.forEach((original, i) => {
                if (original !== undefined) {
                    helpers.setPendingHookValue(statefulHooks[i], original);
                }
            });
        }
        // Restore original console
        for (const method in prevConsole) {
            try {
                console[method] = prevConsole[method];
            }
            catch (error) {
                // Ignore errors
            }
        }
        options._skipEffects = options.__s = false;
    }
    const parsed = hookLog.length
        ? parseHookData(config, hookLog, vnode, [...debugNames].reverse(), helpers)
        : null;
    debugNames = [];
    inspectingHooks = false;
    ancestorName = "unknown";
    hookLog = [];
    return parsed;
}
