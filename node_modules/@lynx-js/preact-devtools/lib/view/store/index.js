import { signal, effect, computed } from "@preact/signals";
import { createSearchStore } from "./search";
import { createFilterStore } from "./filter";
import { flattenChildren } from "../components/tree/windowing";
import { createSelectionStore } from "./selection";
import { createCollapser } from "./collapser";
import { Panel } from "./types";
import { createProfiler } from "../components/profiler/data/commits";
import { parseObjectState, filterCollapsed } from "./props";
export function createStore() {
    const listeners = [];
    const notify = (name, data) => {
        listeners.forEach(fn => fn && fn(name, data));
    };
    const debugMode = signal(!!__DEBUG__);
    const nodes = signal(new Map());
    const roots = signal([]);
    // Toggle
    const isPicking = signal(false);
    const filterState = createFilterStore(notify);
    // List
    const collapsed = signal(new Set());
    const collapser = createCollapser(collapsed);
    const nodeList = computed(() => {
        return roots.value
            .map(root => {
            const items = flattenChildren(nodes.value, root, id => collapser.collapsed.value.has(id));
            if (filterState.filterRoot.value) {
                return items.slice(1);
            }
            return items;
        })
            .reduce((acc, val) => acc.concat(val), []);
    });
    // Sidebar
    const sidebar = {
        props: {
            uncollapsed: signal([]),
            items: signal([]),
        },
        state: {
            uncollapsed: signal([]),
            items: signal([]),
        },
        context: {
            uncollapsed: signal([]),
            items: signal([]),
        },
        hooks: {
            uncollapsed: signal([]),
            items: signal([]),
        },
        signals: {
            uncollapsed: signal([]),
            items: signal([]),
        },
    };
    const inspectData = signal(null);
    effect(() => {
        const props = inspectData.value ? inspectData.value.props : null;
        sidebar.props.items.value = parseObjectState(props, sidebar.props.uncollapsed.value);
        const state = inspectData.value ? inspectData.value.state : null;
        sidebar.state.items.value = parseObjectState(state, sidebar.state.uncollapsed.value);
        const context = inspectData.value ? inspectData.value.context : null;
        sidebar.context.items.value = parseObjectState(context, sidebar.context.uncollapsed.value);
        const signals = inspectData.value ? inspectData.value.signals : null;
        sidebar.signals.items.value = parseObjectState(signals, sidebar.signals.uncollapsed.value);
    });
    const supportsHooks = signal(false);
    effect(() => {
        if (supportsHooks) {
            const items = inspectData.value && inspectData.value.hooks
                ? inspectData.value.hooks
                : [];
            sidebar.hooks.items.value = filterCollapsed(items, sidebar.hooks.uncollapsed.value).slice(1);
        }
    });
    const selection = createSelectionStore(nodeList);
    const stats = signal(null);
    return {
        supports: {
            hooks: supportsHooks,
        },
        stats: {
            isRecording: signal(false),
            data: stats,
        },
        debugMode,
        activePanel: signal(Panel.ELEMENTS),
        profiler: createProfiler(),
        notify,
        nodeList,
        inspectData,
        isPicking,
        roots,
        nodes,
        collapser,
        search: createSearchStore(nodes, nodeList),
        filter: filterState,
        selection,
        theme: signal("auto"),
        sidebar,
        clear() {
            roots.value = [];
            nodes.value = new Map();
            selection.selected.value = -1;
            collapser.collapsed.value = new Set();
            stats.value = null;
            inspectData.value = null;
        },
        subscribe(fn) {
            const idx = listeners.push(fn);
            return () => (listeners[idx] = null);
        },
        emit: notify,
    };
}
