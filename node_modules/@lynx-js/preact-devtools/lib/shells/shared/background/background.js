import { debug } from "../../../debug";
import { setPopupStatus } from "../popup/popup";
import { ContentScriptName, DevtoolsPanelName, DevtoolsToClient, } from "../../../constants";
import { BackgroundEmitter } from "./emitter";
/**
 * Collection of potential targets to connect to by tabId.
 */
const targets = new Map();
async function addToTarget(tabId, port) {
    if (!targets.has(tabId)) {
        targets.set(tabId, BackgroundEmitter());
        await chrome.scripting.unregisterContentScripts();
        await chrome.scripting.registerContentScripts([
            {
                id: "@preact-devtools/hook",
                js: ["./installHook.js"],
                matches: ["<all_urls>"],
                persistAcrossSessions: true,
                runAt: "document_start",
                world: chrome.scripting.ExecutionWorld.MAIN,
            },
        ]);
    }
    const target = targets.get(tabId);
    target.on(port.name, m => port.postMessage(m));
    port.onMessage.addListener(m => target.emit(port.name, m));
    port.onDisconnect.addListener(() => {
        debug("disconnect", port.name);
        target.emit(port.name, {
            type: "disconnect",
            data: null,
            source: DevtoolsToClient,
        });
        target.off(port.name);
    });
}
/**
 * Handle initial connection from content-script.
 */
async function handleContentScriptConnection(port) {
    const tabId = port.sender?.tab?.id;
    if (tabId) {
        await addToTarget(tabId, port);
        setPopupStatus(tabId, true);
    }
}
/**
 * Handle initial connection from devtools panel.
 */
function handleDevtoolsConnection(port) {
    function initialListener(message) {
        if (message.type !== "init") {
            return;
        }
        const { tabId } = message;
        addToTarget(tabId, port);
        port.onMessage.removeListener(initialListener);
        if (targets.get(tabId)?.connected().includes(ContentScriptName)) {
            port.postMessage({ type: "init", data: null });
        }
    }
    port.onMessage.addListener(initialListener);
}
/**
 * Each port will have a name that was specified during connection via
 * `chrome.runtime.connect()`. We leverage that to call the correct
 * handler.
 *
 * TODO: Allow 1:n connections
 */
const connectionHandlers = {
    [ContentScriptName]: handleContentScriptConnection,
    [DevtoolsPanelName]: handleDevtoolsConnection,
};
chrome.runtime.onConnect.addListener(port => {
    const handler = connectionHandlers[port.name];
    debug(`[${port.sender?.tab?.id}] %cBackground: %cconnecting ${port.name}`, "color: yellow;font-weight:bold", "color: inherit");
    handler && handler(port);
});
