import { EventEmitter } from 'eventemitter3';
/**
 * An implementation of `Event` interface, that wraps a given event object.
 * @see https://dom.spec.whatwg.org/#event
 *
 * @public
 */
export interface Event<T extends string> {
    /**
     * The type os this event.
     * @see https://dom.spec.whatwg.org/#dom-event-type
     */
    type: T;
    /** @internal */
    target: WebSocketImpl;
}
interface WebSocketEvent {
    id: number;
}
export interface WebSocketMessageEvent extends WebSocketEvent {
    type: 'text'; /** | 'binary' | 'blob' */
    data: string; /** | ArrayBuffer */
}
export interface WebSocketClosedEvent extends WebSocketEvent {
    code: number;
    reason: string;
    wasClean: boolean;
}
export interface WebSocketOpenEvent extends WebSocketEvent {
    protocol: string;
}
export interface WebSocketFailedEvent extends WebSocketEvent {
    message: string;
}
/**
 * The `ReadyState` describe the state of a `WebSocket` connection.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
 * @public
 */
export declare enum ReadyState {
    /** Socket has been created. The connection is not yet open. */
    CONNECTING = 0,
    /** The connection is open and ready to communicate. */
    OPEN = 1,
    /** The connection is in the process of closing. */
    CLOSING = 2,
    /** The connection is closed or couldn't be opened. */
    CLOSED = 3
}
export interface GlobalWebSocketEvent {
    websocketMessage: (event: WebSocketMessageEvent) => void;
    websocketClosed: (event: WebSocketClosedEvent) => void;
    websocketOpen: (event: WebSocketOpenEvent) => void;
    websocketFailed: (event: WebSocketFailedEvent) => void;
}
export declare const GlobalEventEmitter: EventEmitter<GlobalWebSocketEvent>;
/**
 * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
 */
export declare enum CloseCode {
    NORMAL = 1000,
    ABNORMAL = 1006
}
export interface LynxWebSocketModule {
    connect(url: string, protocols: string[], options: {
        headers?: Record<string, string>;
    }, socketID: number): void;
    send(message: string, socketID: number): void;
    ping(socketID: number): void;
    close(code: number, reason: string, socketID: number): void;
}
/**
 * The `EventMap` describe the events that {@link @lynx-js/websocket#WebSocket} may fire.
 *
 * @public
 */
export type EventMap = {
    /**
     * The `message` event is fired when data is received through a {@link @lynx-js/websocket#WebSocket}.
     */
    message: Event<'message'> & {
        readonly data: string;
    };
    /**
     * The `open` event is fired when a connection with a {@link @lynx-js/websocket#WebSocket} is opened.
     */
    open: Event<'open'>;
    /**
     * The `close` event is fired when a connection with a {@link @lynx-js/websocket#WebSocket} is closed.
     */
    close: Event<'close'> & {
        readonly code: number;
        readonly reason: string;
    };
    /**
     * The `error` event is fired when a connection with a {@link @lynx-js/websocket#WebSocket} has been closed due to an error (some data couldn't be sent for example).
     */
    error: Event<'error'> & {
        readonly message: string;
    };
};
/**
 * @internal
 */
export declare class WebSocketImpl extends EventEmitter {
    #private;
    private websocketModule;
    url: string;
    readyState: ReadyState;
    protocol: string | undefined;
    constructor(websocketModule: LynxWebSocketModule | undefined, url: string, protocols?: string | string[], options?: {
        headers?: Record<string, string>;
    });
    addEventListener<T extends keyof EventMap>(type: T, callback?: null | ((event: EventMap[T]) => void)): void;
    removeEventListener<T extends keyof EventMap>(type: T, callback: (event: EventMap[T]) => void): this;
    dispatchEvent<T extends keyof EventMap>(event: Event<T>): boolean;
    send(data: string | ArrayBuffer): void;
    ping(): void;
    close(code?: number, reason?: string): void;
    get onmessage(): ((event: EventMap["message"]) => void) | null;
    set onmessage(callback: ((event: EventMap['message']) => void) | null);
    get onopen(): ((event: EventMap["open"]) => void) | null;
    set onopen(callback: ((event: EventMap['open']) => void) | null);
    get onclose(): ((event: EventMap["close"]) => void) | null;
    set onclose(callback: ((event: EventMap['close']) => void) | null);
    get onerror(): ((event: EventMap["error"]) => void) | null;
    set onerror(callback: ((event: EventMap['error']) => void) | null);
}
export {};
