// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
var _a;
import { EventEmitter } from 'eventemitter3';
/**
 * The `ReadyState` describe the state of a `WebSocket` connection.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
 * @public
 */
export var ReadyState;
(function (ReadyState) {
    /** Socket has been created. The connection is not yet open. */
    ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
    /** The connection is open and ready to communicate. */
    ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
    /** The connection is in the process of closing. */
    ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
    /** The connection is closed or couldn't be opened. */
    ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
})(ReadyState || (ReadyState = {}));
export const GlobalEventEmitter = lynx
    .getJSModule('GlobalEventEmitter');
/**
 * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
 */
export var CloseCode;
(function (CloseCode) {
    CloseCode[CloseCode["NORMAL"] = 1000] = "NORMAL";
    CloseCode[CloseCode["ABNORMAL"] = 1006] = "ABNORMAL";
})(CloseCode || (CloseCode = {}));
/**
 * @internal
 */
export class WebSocketImpl extends EventEmitter {
    websocketModule;
    url;
    readyState = ReadyState.CONNECTING;
    protocol;
    static #nextWebSocketId = 1;
    #socketID = _a.#nextWebSocketId++;
    constructor(websocketModule, url, protocols, options = {}) {
        super();
        this.websocketModule = websocketModule;
        this.url = url;
        if (!websocketModule) {
            lynx.reportError(new Error(`WebSocket is not found. Please use Lynx >= 2.16 or consider using a polyfill.`), { level: 'warning' });
            return;
        }
        if (typeof protocols === 'string') {
            protocols = [protocols];
        }
        if (!Array.isArray(protocols)) {
            protocols = [];
        }
        this.#registerEvents();
        this.websocketModule?.connect(url, protocols, options, this.#socketID);
    }
    addEventListener(type, callback) {
        if (!callback) {
            return;
        }
        this.addListener(type, callback);
        return;
    }
    removeEventListener(type, callback) {
        return this.removeListener(type, callback);
    }
    dispatchEvent(event) {
        return this.emit(event.type, event);
    }
    send(data) {
        if (this.readyState === ReadyState.CONNECTING) {
            throw new Error('INVALID_STATE_ERR');
        }
        if (this.readyState === ReadyState.CLOSING
            || this.readyState === ReadyState.CLOSED) {
            return;
        }
        if (typeof data === 'string') {
            this.websocketModule?.send(data, this.#socketID);
            return;
        }
        // TODO: support binary data
        throw new Error('Unsupported data type');
    }
    ping() {
        if (this.readyState === ReadyState.CONNECTING) {
            throw new Error('INVALID_STATE_ERR');
        }
        if (this.readyState === ReadyState.CLOSING
            || this.readyState === ReadyState.CLOSED) {
            return;
        }
        this.websocketModule?.ping(this.#socketID);
    }
    close(code, reason) {
        if (this.readyState === ReadyState.CLOSING
            || this.readyState === ReadyState.CLOSED) {
            return;
        }
        this.readyState = ReadyState.CLOSING;
        this.#close(code, reason);
    }
    #close(code, reason) {
        // See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
        const statusCode = typeof code === 'number' ? code : CloseCode.NORMAL;
        const closeReason = typeof reason === 'string' ? reason : '';
        this.websocketModule?.close(statusCode, closeReason, this.#socketID);
    }
    #registerEvents() {
        /* eslint-disable @typescript-eslint/unbound-method */
        GlobalEventEmitter.addListener('websocketMessage', this.#onMessage, this);
        GlobalEventEmitter.addListener('websocketOpen', this.#onOpen, this);
        GlobalEventEmitter.addListener('websocketClosed', this.#onClosed, this);
        GlobalEventEmitter.addListener('websocketFailed', this.#onFailed, this);
        /* eslint-enable @typescript-eslint/unbound-method */
    }
    #unregisterEvents() {
        /* eslint-disable @typescript-eslint/unbound-method */
        GlobalEventEmitter.removeListener('websocketMessage', this.#onMessage);
        GlobalEventEmitter.removeListener('websocketOpen', this.#onOpen);
        GlobalEventEmitter.removeListener('websocketClosed', this.#onClosed);
        GlobalEventEmitter.removeListener('websocketFailed', this.#onFailed);
        /* eslint-enable @typescript-eslint/unbound-method */
    }
    #previousOnMessage = null;
    get onmessage() {
        return this.#previousOnMessage;
    }
    set onmessage(callback) {
        if (this.#previousOnMessage) {
            this.removeEventListener('message', this.#previousOnMessage);
        }
        this.addEventListener('message', callback);
        this.#previousOnMessage = callback;
    }
    #onMessage(event) {
        if (event.id !== this.#socketID) {
            return;
        }
        const data = event.data;
        switch (event.type) {
            case 'text':
                break;
            // TODO: support binary data
        }
        this.dispatchEvent(this.#createWebSocketEvent('message', { data }));
    }
    #previousOnOpen = null;
    get onopen() {
        return this.#previousOnOpen;
    }
    set onopen(callback) {
        if (this.#previousOnOpen) {
            this.removeEventListener('open', this.#previousOnOpen);
        }
        this.addEventListener('open', callback);
        this.#previousOnOpen = callback;
    }
    #onOpen(event) {
        if (event.id !== this.#socketID) {
            return;
        }
        this.readyState = ReadyState.OPEN;
        this.protocol = event.protocol;
        this.dispatchEvent(this.#createWebSocketEvent('open'));
    }
    #previousOnClose = null;
    get onclose() {
        return this.#previousOnClose;
    }
    set onclose(callback) {
        if (this.#previousOnClose) {
            this.removeEventListener('close', this.#previousOnClose);
        }
        this.addEventListener('close', callback);
        this.#previousOnClose = callback;
    }
    #onClosed(event) {
        if (event.id !== this.#socketID) {
            return;
        }
        this.readyState = ReadyState.CLOSED;
        this.dispatchEvent(this.#createWebSocketEvent('close', {
            code: event.code,
            reason: event.reason,
        }));
        this.#unregisterEvents();
    }
    #previousOnError = null;
    get onerror() {
        return this.#previousOnError;
    }
    set onerror(callback) {
        if (this.#previousOnError) {
            this.removeEventListener('error', this.#previousOnError);
        }
        this.addEventListener('error', callback);
        this.#previousOnError = callback;
    }
    #onFailed(event) {
        if (event.id !== this.#socketID) {
            return;
        }
        this.readyState = ReadyState.CLOSED;
        this.dispatchEvent(this.#createWebSocketEvent('error', {
            message: event.message,
        }));
        this.dispatchEvent(this.#createWebSocketEvent('close', {
            code: CloseCode.ABNORMAL,
            reason: event.message,
        }));
        this.#unregisterEvents();
    }
    #createWebSocketEvent(type, data) {
        return Object.assign({ type, target: this }, data);
    }
}
_a = WebSocketImpl;
//# sourceMappingURL=WebSocketImpl.js.map