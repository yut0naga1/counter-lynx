import { createRequire } from "node:module";
import node_path from "node:path";
var __webpack_modules__ = {
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const debug = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const { safeRe: re, t } = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const parseOptions = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js");
        const { compareIdentifiers } = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js");
        class SemVer {
            constructor(version, options){
                options = parseOptions(options);
                if (version instanceof SemVer) if (!!options.loose === version.loose && !!options.includePrerelease === version.includePrerelease) return version;
                else version = version.version;
                else if ('string' != typeof version) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
                if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
                debug('SemVer', version, options);
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
                if (!m) throw new TypeError(`Invalid Version: ${version}`);
                this.raw = version;
                this.major = +m[1];
                this.minor = +m[2];
                this.patch = +m[3];
                if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
                if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
                if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
                if (m[4]) this.prerelease = m[4].split('.').map((id)=>{
                    if (/^[0-9]+$/.test(id)) {
                        const num = +id;
                        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
                    }
                    return id;
                });
                else this.prerelease = [];
                this.build = m[5] ? m[5].split('.') : [];
                this.format();
            }
            format() {
                this.version = `${this.major}.${this.minor}.${this.patch}`;
                if (this.prerelease.length) this.version += `-${this.prerelease.join('.')}`;
                return this.version;
            }
            toString() {
                return this.version;
            }
            compare(other) {
                debug('SemVer.compare', this.version, this.options, other);
                if (!(other instanceof SemVer)) {
                    if ('string' == typeof other && other === this.version) return 0;
                    other = new SemVer(other, this.options);
                }
                if (other.version === this.version) return 0;
                return this.compareMain(other) || this.comparePre(other);
            }
            compareMain(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
            }
            comparePre(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                if (this.prerelease.length && !other.prerelease.length) return -1;
                if (!this.prerelease.length && other.prerelease.length) return 1;
                if (!this.prerelease.length && !other.prerelease.length) return 0;
                let i = 0;
                do {
                    const a = this.prerelease[i];
                    const b = other.prerelease[i];
                    debug('prerelease compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            compareBuild(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                let i = 0;
                do {
                    const a = this.build[i];
                    const b = other.build[i];
                    debug('build compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            inc(release, identifier, identifierBase) {
                if (release.startsWith('pre')) {
                    if (!identifier && false === identifierBase) throw new Error('invalid increment argument: identifier is empty');
                    if (identifier) {
                        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                        if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
                    }
                }
                switch(release){
                    case 'premajor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor = 0;
                        this.major++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'preminor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prepatch':
                        this.prerelease.length = 0;
                        this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prerelease':
                        if (0 === this.prerelease.length) this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'release':
                        if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
                        this.prerelease.length = 0;
                        break;
                    case 'major':
                        if (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) this.major++;
                        this.minor = 0;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'minor':
                        if (0 !== this.patch || 0 === this.prerelease.length) this.minor++;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'patch':
                        if (0 === this.prerelease.length) this.patch++;
                        this.prerelease = [];
                        break;
                    case 'pre':
                        {
                            const base = Number(identifierBase) ? 1 : 0;
                            if (0 === this.prerelease.length) this.prerelease = [
                                base
                            ];
                            else {
                                let i = this.prerelease.length;
                                while(--i >= 0)if ('number' == typeof this.prerelease[i]) {
                                    this.prerelease[i]++;
                                    i = -2;
                                }
                                if (-1 === i) {
                                    if (identifier === this.prerelease.join('.') && false === identifierBase) throw new Error('invalid increment argument: identifier already exists');
                                    this.prerelease.push(base);
                                }
                            }
                            if (identifier) {
                                let prerelease = [
                                    identifier,
                                    base
                                ];
                                if (false === identifierBase) prerelease = [
                                    identifier
                                ];
                                if (0 === compareIdentifiers(this.prerelease[0], identifier)) {
                                    if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
                                } else this.prerelease = prerelease;
                            }
                            break;
                        }
                    default:
                        throw new Error(`invalid increment argument: ${release}`);
                }
                this.raw = this.format();
                if (this.build.length) this.raw += `+${this.build.join('.')}`;
                return this;
            }
        }
        module.exports = SemVer;
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const SemVer = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
        module.exports = compare;
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const compare = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
        module.exports = gte;
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js": function(module) {
        const SEMVER_SPEC_VERSION = '2.0.0';
        const MAX_LENGTH = 256;
        const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        const MAX_SAFE_COMPONENT_LENGTH = 16;
        const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        const RELEASE_TYPES = [
            'major',
            'premajor',
            'minor',
            'preminor',
            'patch',
            'prepatch',
            'prerelease'
        ];
        module.exports = {
            MAX_LENGTH,
            MAX_SAFE_COMPONENT_LENGTH,
            MAX_SAFE_BUILD_LENGTH,
            MAX_SAFE_INTEGER,
            RELEASE_TYPES,
            SEMVER_SPEC_VERSION,
            FLAG_INCLUDE_PRERELEASE: 1,
            FLAG_LOOSE: 2
        };
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js": function(module) {
        const debug = 'object' == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
        module.exports = debug;
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js": function(module) {
        const numeric = /^[0-9]+$/;
        const compareIdentifiers = (a, b)=>{
            const anum = numeric.test(a);
            const bnum = numeric.test(b);
            if (anum && bnum) {
                a *= 1;
                b *= 1;
            }
            return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
        module.exports = {
            compareIdentifiers,
            rcompareIdentifiers
        };
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js": function(module) {
        const looseOption = Object.freeze({
            loose: true
        });
        const emptyOpts = Object.freeze({});
        const parseOptions = (options)=>{
            if (!options) return emptyOpts;
            if ('object' != typeof options) return looseOption;
            return options;
        };
        module.exports = parseOptions;
    },
    "../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js": function(module, exports, __webpack_require__) {
        const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const debug = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        exports = module.exports = {};
        const re = exports.re = [];
        const safeRe = exports.safeRe = [];
        const src = exports.src = [];
        const safeSrc = exports.safeSrc = [];
        const t = exports.t = {};
        let R = 0;
        const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        const safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        const makeSafeRegex = (value)=>{
            for (const [token, max] of safeRegexReplacements)value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
            return value;
        };
        const createToken = (name, value, isGlobal)=>{
            const safe = makeSafeRegex(value);
            const index = R++;
            debug(name, index, value);
            t[name] = index;
            src[index] = value;
            safeSrc[index] = safe;
            re[index] = new RegExp(value, isGlobal ? 'g' : void 0);
            safeRe[index] = new RegExp(safe, isGlobal ? 'g' : void 0);
        };
        createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
        createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
        createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
        createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
        createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
        createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
        createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
        createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
        createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
        createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
        createToken('FULL', `^${src[t.FULLPLAIN]}$`);
        createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
        createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
        createToken('GTLT', '((?:<|>)?=?)');
        createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
        createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
        createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
        createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COERCEPLAIN', `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
        createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
        createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + "(?:$|[^\\d])");
        createToken('COERCERTL', src[t.COERCE], true);
        createToken('COERCERTLFULL', src[t.COERCEFULL], true);
        createToken('LONETILDE', '(?:~>?)');
        createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
        exports.tildeTrimReplace = '$1~';
        createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
        createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('LONECARET', '(?:\\^)');
        createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
        exports.caretTrimReplace = '$1^';
        createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
        createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
        createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
        createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
        exports.comparatorTrimReplace = '$1$2$3';
        createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*\$`);
        createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*\$`);
        createToken('STAR', '(<|>)?=?\\s*\\*');
        createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
        createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
var gte = __webpack_require__("../../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js");
var gte_default = /*#__PURE__*/ __webpack_require__.n(gte);
const S_PLUGIN_REACT_ALIAS = Symbol.for('@lynx-js/plugin-react-alias');
function pluginReactAlias(options) {
    const { LAYERS, lazy, rootPath } = options ?? {};
    return {
        name: 'lynx:react-alias',
        setup (api) {
            const require = createRequire(import.meta.url);
            const reactLynxPkg = require.resolve('@lynx-js/react/package.json', {
                paths: [
                    rootPath ?? api.context.rootPath
                ]
            });
            const { version } = require(reactLynxPkg);
            const reactLynxDir = node_path.dirname(reactLynxPkg);
            const resolve = createLazyResolver(rootPath ?? api.context.rootPath, lazy ? [
                'lazy',
                'import'
            ] : [
                'import'
            ]);
            const resolvePreact = createLazyResolver(reactLynxDir, [
                'import'
            ]);
            api.modifyRsbuildConfig((config, { mergeRsbuildConfig })=>mergeRsbuildConfig(config, {
                    source: {
                        include: [
                            reactLynxDir
                        ]
                    }
                }));
            api.modifyBundlerChain(async (chain, { isProd, environment })=>{
                if (Object.hasOwn(environment, S_PLUGIN_REACT_ALIAS)) return;
                Object.defineProperty(environment, S_PLUGIN_REACT_ALIAS, {
                    value: true
                });
                const [jsxRuntimeBackground, jsxRuntimeMainThread, jsxDevRuntimeBackground, jsxDevRuntimeMainThread, reactLepusBackground, reactLepusMainThread, reactCompat] = await Promise.all([
                    resolve('@lynx-js/react/jsx-runtime'),
                    resolve('@lynx-js/react/lepus/jsx-runtime'),
                    resolve('@lynx-js/react/jsx-dev-runtime'),
                    resolve('@lynx-js/react/lepus/jsx-dev-runtime'),
                    resolve('@lynx-js/react'),
                    resolve('@lynx-js/react/lepus'),
                    gte_default()(version, '0.111.9999') ? resolve('@lynx-js/react/compat') : Promise.resolve(null)
                ]);
                const jsxRuntime = {
                    background: jsxRuntimeBackground,
                    mainThread: jsxRuntimeMainThread
                };
                const jsxDevRuntime = {
                    background: jsxDevRuntimeBackground,
                    mainThread: jsxDevRuntimeMainThread
                };
                const reactLepus = {
                    background: reactLepusBackground,
                    mainThread: reactLepusMainThread
                };
                chain.module.rule('react:jsx-runtime:main-thread').issuerLayer(LAYERS.MAIN_THREAD).resolve.alias.set('react/jsx-runtime', jsxRuntime.mainThread).set('react/jsx-dev-runtime', jsxDevRuntime.mainThread).set('@lynx-js/react/jsx-runtime', jsxRuntime.mainThread).set('@lynx-js/react/jsx-dev-runtime', jsxDevRuntime.mainThread).set('@lynx-js/react/lepus$', reactLepus.mainThread).set('@lynx-js/react/lepus/jsx-runtime', jsxRuntime.mainThread).set('@lynx-js/react/lepus/jsx-dev-runtime', jsxDevRuntime.mainThread).end().end().end().rule('react:jsx-runtime:background').issuerLayer(LAYERS.BACKGROUND).resolve.alias.set('react/jsx-runtime', jsxRuntime.background).set('react/jsx-dev-runtime', jsxDevRuntime.background).set('@lynx-js/react/jsx-runtime', jsxRuntime.background).set('@lynx-js/react/jsx-dev-runtime', jsxDevRuntime.background).set('@lynx-js/react/lepus$', reactLepus.background).end().end().end().end();
                const transformedEntries = [
                    'experimental/lazy/import',
                    'internal',
                    'legacy-react-runtime',
                    'runtime-components',
                    'worklet-runtime/bindings'
                ];
                await Promise.all(transformedEntries.map((entry)=>`@lynx-js/react/${entry}`).map((entry)=>resolve(entry).then((value)=>{
                        chain.resolve.alias.set(`${entry}$`, value);
                    })));
                if (isProd) {
                    chain.resolve.alias.set('@lynx-js/react/debug$', false);
                    chain.resolve.alias.set('@lynx-js/preact-devtools$', false);
                }
                chain.resolve.alias.set('react$', reactLepus.background).set('@lynx-js/react$', reactLepus.background);
                if (reactCompat) chain.resolve.alias.set('@lynx-js/react/compat$', reactCompat);
                const preactEntries = [
                    'preact',
                    'preact/compat',
                    'preact/debug',
                    'preact/devtools',
                    'preact/hooks',
                    'preact/test-utils',
                    'preact/jsx-runtime',
                    'preact/jsx-dev-runtime',
                    'preact/compat',
                    'preact/compat/client',
                    'preact/compat/server',
                    'preact/compat/jsx-runtime',
                    'preact/compat/jsx-dev-runtime',
                    'preact/compat/scheduler'
                ];
                await Promise.all(preactEntries.map((entry)=>resolvePreact(entry).then((value)=>{
                        chain.resolve.alias.set(`${entry}$`, value);
                    })));
            });
        }
    };
}
function createLazyResolver(directory, conditionNames) {
    let lazyExports;
    let resolverLazy;
    return async (request)=>{
        if (!lazyExports) lazyExports = {};
        if (void 0 === lazyExports[request]) {
            if (!resolverLazy) {
                const { ResolverFactory } = await import("unrs-resolver");
                const resolver = new ResolverFactory({
                    conditionNames
                });
                resolverLazy = (dir, req)=>resolver.sync(dir, req);
            }
            const resolveResult = resolverLazy(directory, request);
            if (resolveResult.error) throw new Error(resolveResult.error);
            if (!resolveResult.path) throw new Error(`Failed to resolve ${request}`);
            lazyExports[request] = resolveResult.path;
        }
        return lazyExports[request];
    };
}
export { createLazyResolver, pluginReactAlias };
