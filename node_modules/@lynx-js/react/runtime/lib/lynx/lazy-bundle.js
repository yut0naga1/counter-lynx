// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
/**
 * To make code below works
 * const App1 = lazy(() => import("./x").then(({App1}) => ({default: App1})))
 * const App2 = lazy(() => import("./x").then(({App2}) => ({default: App2})))
 * @internal
 */
export const makeSyncThen = function (result) {
    return function (onF, _onR) {
        if (onF) {
            let ret;
            try {
                ret = onF(result);
            }
            catch (e) {
                // if (onR) {
                //   return Promise.resolve(onR(e));
                // }
                return Promise.reject(e);
            }
            if (ret && typeof ret.then === 'function' /* `thenable` object */) {
                // lazy(() =>
                //   import("./x").then(() => new Promise(...))
                // )
                // Calling `then` and passing a callback is standard behavior
                // but in Lepus runtime the callback will never be called
                // So can be simplified to code below
                return ret;
                // TODO(hongzhiyuan.hzy): Avoid warning that cannot be turned-off, so the warning is commented
                // lynx.reportError(
                //   new Error(
                //     'You returned a Promise in promise-chain of lazy-bundle import (eg. `import("./x").then(() => new Promise(...))`), which will cause related Component unavailable at first-screen, '
                //   ),
                //   { level: "warning" }
                // );
            }
            const p = Promise.resolve(ret);
            const then = makeSyncThen(ret);
            p.then = then;
            return p;
        }
        return this;
    };
};
/**
 * Load dynamic component from source. Designed to be used with `lazy`.
 * @param source - where dynamic component template.js locates
 * @returns
 * @public
 */
export const loadLazyBundle = /*#__PURE__*/ (() => {
    lynx.loadLazyBundle = loadLazyBundle;
    function loadLazyBundle(source) {
        if (__LEPUS__) {
            const query = __QueryComponent(source);
            let result;
            try {
                result = query.evalResult;
            }
            catch (e) {
                // Here we cannot return a rejected promise
                // (which will eventually be an unhandled rejection and cause unnecessary redbox)
                // But we still need a object in shape of Promise
                // So we return a Promise which will never resolve or reject,
                // which fit our principle "lepus run only once at first-screen" better
                return new Promise(() => { });
            }
            const r = Promise.resolve(result);
            // Why we should modify the implementation of `then`?
            // We should make it `sync` so lepus first-screen render can use result above instantly
            // We also should keep promise shape
            r.then = makeSyncThen(result);
            return r;
        }
        else if (__JS__) {
            const resolver = withSyncResolvers();
            const callback = result => {
                const { code, detail } = result;
                if (code === 0) {
                    const { schema } = detail;
                    const exports = lynxCoreInject.tt.getDynamicComponentExports(schema);
                    // `code === 0` means that the lazy bundle has been successfully parsed. However,
                    // its javascript files may still fail to run, which would prevent the retrieval of the exports object.
                    if (exports) {
                        resolver.resolve(exports);
                        return;
                    }
                }
                resolver.reject(new Error('Lazy bundle load failed: ' + JSON.stringify(result)));
            };
            if (typeof lynx.QueryComponent === 'function') {
                lynx.QueryComponent(source, callback);
            }
            else {
                lynx.getNativeLynx().QueryComponent(source, callback);
            }
            if (resolver.result !== null) {
                const p = Promise.resolve(resolver.result);
                p.then = makeSyncThen(resolver.result);
                return p;
            }
            else if (resolver.error === null) {
                return new Promise((_resolve, _reject) => {
                    resolver.resolve = _resolve;
                    resolver.reject = _reject;
                });
            }
            else {
                return Promise.reject(resolver.error);
            }
        }
        throw new Error('unreachable');
    }
    return loadLazyBundle;
})();
function withSyncResolvers() {
    'background-only';
    const resolver = {
        resolve: (result) => {
            resolver.result = result;
        },
        reject: (error) => {
            resolver.error = error;
        },
        result: null,
        error: null,
    };
    return resolver;
}
//# sourceMappingURL=lazy-bundle.js.map