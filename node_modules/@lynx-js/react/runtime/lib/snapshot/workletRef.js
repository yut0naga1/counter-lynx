// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { onWorkletCtxUpdate, runWorkletCtx, updateWorkletRef as update } from '@lynx-js/react/worklet-runtime/bindings';
import { isMainThreadHydrating } from '../lifecycle/patch/isMainThreadHydrating.js';
let mtRefQueue = [];
export function applyRefQueue() {
    const queue = mtRefQueue;
    mtRefQueue = [];
    for (let i = 0; i < queue.length; i += 2) {
        const worklet = queue[i];
        const element = queue[i + 1];
        if ('_wvid' in worklet) {
            update(worklet, element);
        }
        else if ('_wkltId' in worklet) {
            worklet._unmount = runWorkletCtx(worklet, [{ elementRefptr: element }]);
        }
    }
}
function addToRefQueue(worklet, element) {
    mtRefQueue.push(worklet, element);
}
export function workletUnRef(value) {
    if ('_wvid' in value) {
        update(value, null);
    }
    else if ('_wkltId' in value) {
        if (typeof value._unmount == 'function') {
            value._unmount();
        }
        else {
            runWorkletCtx(value, [null]);
        }
    }
}
export function updateWorkletRef(snapshot, expIndex, oldValue, elementIndex, _workletType) {
    if (!snapshot.__elements) {
        return;
    }
    if (oldValue && snapshot.__worklet_ref_set?.has(oldValue)) {
        workletUnRef(oldValue);
        snapshot.__worklet_ref_set?.delete(oldValue);
    }
    const value = snapshot.__values[expIndex];
    if (value === null || value === undefined) {
        // do nothing
    }
    else if (value._wvid) {
        const element = snapshot.__elements[elementIndex];
        addToRefQueue(value, element);
    }
    else if (value._wkltId) {
        const element = snapshot.__elements[elementIndex];
        onWorkletCtxUpdate(value, oldValue, isMainThreadHydrating, element);
        addToRefQueue(value, element);
        /* v8 ignore next 3 */
    }
    else if (value._type === '__LEPUS__' || value._lepusWorkletHash) {
        // for pre-0.99 compatibility
        // During the initial render, we will not update the WorkletRef because the background thread is not ready yet.
    }
    else {
        throw new Error('MainThreadRef: main-thread:ref must be of type MainThreadRef or main-thread function.');
    }
    if (value) {
        snapshot.__worklet_ref_set ??= new Set();
        snapshot.__worklet_ref_set.add(value);
    }
    // Add an arbitrary attribute to avoid this element being layout-only
    __SetAttribute(snapshot.__elements[elementIndex], 'has-react-ref', true);
}
//# sourceMappingURL=workletRef.js.map