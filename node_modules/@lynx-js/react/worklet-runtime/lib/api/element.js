// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { Animation } from './animation/animation.js';
import { KeyframeEffect } from './animation/effect.js';
let willFlush = false;
let shouldFlush = true;
export function setShouldFlush(value) {
    shouldFlush = value;
}
export class Element {
    // @ts-expect-error set in constructor
    element;
    constructor(element) {
        // In Lynx versions prior to and including 2.15,
        // a crash occurs when printing or transferring refCounted across threads.
        // Bypass this problem by hiding the element object.
        Object.defineProperty(this, 'element', {
            get() {
                return element;
            },
        });
    }
    setAttribute(name, value) {
        __SetAttribute(this.element, name, value);
        this.flushElementTree();
    }
    setStyleProperty(name, value) {
        __AddInlineStyle(this.element, name, value);
        this.flushElementTree();
    }
    setStyleProperties(styles) {
        for (const key in styles) {
            __AddInlineStyle(this.element, key, styles[key]);
        }
        this.flushElementTree();
    }
    getAttribute(attributeName) {
        return __GetAttributeByName(this.element, attributeName);
    }
    getAttributeNames() {
        return __GetAttributeNames(this.element);
    }
    querySelector(selector) {
        const ref = __QuerySelector(this.element, selector, {});
        return ref ? new Element(ref) : null;
    }
    querySelectorAll(selector) {
        return __QuerySelectorAll(this.element, selector, {}).map((element) => {
            return new Element(element);
        });
    }
    animate(keyframes, options) {
        const normalizedOptions = typeof options === 'number' ? { duration: options } : options ?? {};
        return new Animation(new KeyframeEffect(this, keyframes, normalizedOptions));
    }
    invoke(methodName, params) {
        return new Promise((resolve, reject) => {
            __InvokeUIMethod(this.element, methodName, params ?? {}, (res) => {
                if (res.code === 0) {
                    resolve(res.data);
                }
                else {
                    reject(new Error('UI method invoke: ' + JSON.stringify(res)));
                }
            });
            this.flushElementTree();
        });
    }
    flushElementTree() {
        if (willFlush || !shouldFlush) {
            return;
        }
        willFlush = true;
        void Promise.resolve().then(() => {
            willFlush = false;
            __FlushElementTree();
        });
    }
}
//# sourceMappingURL=element.js.map