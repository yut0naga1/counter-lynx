// Copyright 2025 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { RuntimeGlobals as LynxRuntimeGlobals } from '@lynx-js/webpack-runtime-globals';
import { createLynxCacheEventsRuntimeModule } from './LynxCacheEventsRuntimeModule.js';
import { createLynxCacheEventsSetupListRuntimeModule } from './LynxCacheEventsSetupListRuntimeModule.js';
/**
 * A webpack plugin that cache Lynx native events until the BTS chunk is fully loaded, and replay them when the BTS chunk is ready.
 *
 * @public
 */
export class LynxCacheEventsPlugin {
    options;
    constructor(options) {
        this.options = options;
    }
    /**
     * `defaultOptions` is the default options that the {@link LynxCacheEventsPlugin} uses.
     *
     * @example
     * `defaultOptions` can be used to change part of the option and keep others as the default value.
     *
     * ```js
     * // webpack.config.js
     * import { LynxCacheEventsPlugin } from '@lynx-js/cache-events-webpack-plugin'
     * export default {
     *   plugins: [
     *     new LynxCacheEventsPlugin({
     *       ...LynxCacheEventsPlugin.defaultOptions,
     *       setupListTransformer: (setupList) => setupList,
     *     }),
     *   ],
     * }
     * ```
     *
     * @public
     */
    static defaultOptions = Object
        .freeze({
        setupListTransformer: (setupList) => setupList,
    });
    /**
     * The entry point of a webpack plugin.
     * @param compiler - the webpack compiler
     */
    apply(compiler) {
        new LynxCacheEventsPluginImpl(compiler, Object.assign({}, LynxCacheEventsPlugin.defaultOptions, this.options));
    }
}
export class LynxCacheEventsPluginImpl {
    name = 'LynxCacheEventsPlugin';
    options;
    static chunkLoadingValue = 'lynx';
    constructor(compiler, options) {
        this.options = options;
        if (compiler.options.output.chunkLoading
            !== LynxCacheEventsPluginImpl.chunkLoadingValue) {
            return;
        }
        const { RuntimeGlobals } = compiler.webpack;
        compiler.hooks.thisCompilation.tap(this.name, compilation => {
            const handler = (chunk, runtimeRequirements) => {
                const globalChunkLoading = compilation.outputOptions.chunkLoading;
                const isEnabledForChunk = (chunk) => {
                    const options = chunk.getEntryOptions();
                    const chunkLoading = options && options.chunkLoading !== undefined
                        ? options.chunkLoading
                        : globalChunkLoading;
                    return chunkLoading === LynxCacheEventsPluginImpl.chunkLoadingValue;
                };
                if (!isEnabledForChunk(chunk))
                    return;
                runtimeRequirements.add(LynxRuntimeGlobals.lynxCacheEventsSetupList);
                runtimeRequirements.add(LynxRuntimeGlobals.lynxCacheEvents);
            };
            compilation.hooks.runtimeRequirementInTree
                .for(RuntimeGlobals.startup)
                .tap(this.name, handler);
            const onceForChunkSet = {
                [LynxRuntimeGlobals.lynxAsyncChunkIds]: new WeakSet(),
                [LynxRuntimeGlobals.lynxCacheEvents]: new WeakSet(),
                [LynxRuntimeGlobals.lynxCacheEventsSetupList]: new WeakSet(),
            };
            const LynxCacheEventsSetupListRuntimeModule = createLynxCacheEventsSetupListRuntimeModule(compiler.webpack);
            const LynxCacheEventsRuntimeModule = createLynxCacheEventsRuntimeModule(compiler.webpack);
            compilation.hooks.runtimeRequirementInTree.for(LynxRuntimeGlobals.lynxCacheEventsSetupList).tap(this.name, (chunk) => {
                // Only add the LynxCacheEventsSetupListRuntimeModule once
                if (onceForChunkSet[LynxRuntimeGlobals.lynxCacheEventsSetupList].has(chunk)) {
                    return;
                }
                onceForChunkSet[LynxRuntimeGlobals.lynxCacheEventsSetupList].add(chunk);
                if (chunk.name?.includes('__main-thread')) {
                    return;
                }
                compilation.addRuntimeModule(chunk, new LynxCacheEventsSetupListRuntimeModule(this.options.setupListTransformer));
            });
            compilation.hooks.runtimeRequirementInTree.for(LynxRuntimeGlobals.lynxCacheEvents).tap(this.name, (chunk, set) => {
                // Only add the LynxCacheEventsRuntimeModule once
                if (onceForChunkSet[LynxRuntimeGlobals.lynxCacheEvents].has(chunk)) {
                    return;
                }
                onceForChunkSet[LynxRuntimeGlobals.lynxCacheEvents].add(chunk);
                if (chunk.name?.includes('__main-thread')) {
                    return;
                }
                set.add(LynxRuntimeGlobals.lynxCacheEventsSetupList);
                compilation.addRuntimeModule(chunk, new LynxCacheEventsRuntimeModule());
            });
        });
    }
}
//# sourceMappingURL=LynxCacheEventsPlugin.js.map