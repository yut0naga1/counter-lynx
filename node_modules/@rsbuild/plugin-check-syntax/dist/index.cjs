"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module['default'];
        } : function() {
            return module;
        };
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = function(exports1, definition) {
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = function(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };
})();
(()=>{
    __webpack_require__.r = function(exports1) {
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    pluginCheckSyntax: ()=>pluginCheckSyntax,
    PLUGIN_CHECK_SYNTAX_NAME: ()=>PLUGIN_CHECK_SYNTAX_NAME,
    CheckSyntaxRspackPlugin: ()=>CheckSyntaxRspackPlugin,
    CheckSyntax: ()=>CheckSyntax
});
const external_node_path_namespaceObject = require("node:path");
const external_node_fs_namespaceObject = require("node:fs");
var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_namespaceObject);
const external_acorn_namespaceObject = require("acorn");
const external_browserslist_to_es_version_namespaceObject = require("browserslist-to-es-version");
const external_picocolors_namespaceObject = require("picocolors");
var external_picocolors_default = /*#__PURE__*/ __webpack_require__.n(external_picocolors_namespaceObject);
const external_source_map_namespaceObject = require("source-map");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class ECMASyntaxError extends Error {
    constructor(message, options){
        super(message), _define_property(this, "source", void 0), _define_property(this, "output", void 0);
        this.source = options.source;
        this.output = options.output;
    }
}
function checkIsExclude(path, exclude) {
    if (!exclude) return false;
    const excludes = Array.isArray(exclude) ? exclude : [
        exclude
    ];
    const normalizedPath = path.replace(/\\/g, '/');
    return excludes.some((reg)=>reg.test(normalizedPath));
}
function displayCodePointer(code, pos) {
    const SUB_LEN = 80;
    const start = Math.max(pos - SUB_LEN / 2, 0);
    const subCode = code.slice(start, start + SUB_LEN);
    const arrowPos = pos - start;
    const arrowLine = external_picocolors_default().yellow('^'.padStart(arrowPos + 11, ' '));
    return `${subCode}\n${arrowLine}`;
}
async function generateError({ err, code, filepath, rootPath, exclude }) {
    let error = await tryGenerateErrorFromSourceMap({
        err,
        filepath,
        rootPath
    });
    if (!error) {
        const path = filepath.replace(rootPath, '');
        error = new ECMASyntaxError(err.message, {
            source: {
                path,
                line: err.loc.line,
                column: err.loc.column,
                code: displayCodePointer(code, err.pos)
            }
        });
    }
    if (checkIsExclude(error.source.path, exclude)) return null;
    return error;
}
function makeCodeFrame(lines, highlightIndex) {
    const startLine = Math.max(highlightIndex - 3, 0);
    const endLine = Math.min(highlightIndex + 4, lines.length - 1);
    const ret = [];
    for(let i = startLine; i < endLine; i++)if (i === highlightIndex) {
        const lineNumber = `> ${i + 1}`.padStart(6, ' ');
        ret.push(external_picocolors_default().yellow(`${lineNumber} | ${lines[i]}`));
    } else {
        const lineNumber = ` ${i + 1}`.padStart(6, ' ');
        ret.push(external_picocolors_default().gray(`${lineNumber} | ${lines[i]}`));
    }
    return `\n${ret.join('\n')}`;
}
async function tryGenerateErrorFromSourceMap({ err, filepath, rootPath }) {
    const sourceMapPath = `${filepath}.map`;
    if (!external_node_fs_default().existsSync(sourceMapPath)) return null;
    try {
        var _JSON_parse_sourcesContent, _JSON_parse;
        const sourcemap = await external_node_fs_default().promises.readFile(sourceMapPath, 'utf-8');
        const consumer = await new external_source_map_namespaceObject.SourceMapConsumer(sourcemap);
        const sm = consumer.originalPositionFor({
            line: err.loc.line,
            column: err.loc.column
        });
        if (!sm.source) return null;
        const { sources } = consumer;
        const smIndex = sources.indexOf(sm.source);
        const smContent = null === (_JSON_parse = JSON.parse(sourcemap)) || void 0 === _JSON_parse ? void 0 : null === (_JSON_parse_sourcesContent = _JSON_parse.sourcesContent) || void 0 === _JSON_parse_sourcesContent ? void 0 : _JSON_parse_sourcesContent[smIndex];
        if (!smContent) return null;
        const path = sm.source.replace(/webpack:\/\/(tmp)?/g, '');
        const relativeFilepath = filepath.replace(rootPath, '');
        const rawLines = smContent.split(/\r?\n/g);
        const highlightLine = (sm.line ?? 1) - 1;
        return new ECMASyntaxError(err.message, {
            source: {
                path,
                line: sm.line ?? 0,
                column: sm.column ?? 0,
                code: makeCodeFrame(rawLines, highlightLine)
            },
            output: {
                path: relativeFilepath,
                line: err.loc.line,
                column: err.loc.column
            }
        });
    } catch (e) {
        return null;
    }
}
const external_htmlparser2_namespaceObject = require("htmlparser2");
async function generateHtmlScripts(filepath) {
    const html = await external_node_fs_default().promises.readFile(filepath, 'utf-8');
    return getHtmlScripts(html);
}
function getHtmlScripts(html) {
    const inlineScripts = [];
    let currentScript = null;
    const parser = new external_htmlparser2_namespaceObject.Parser({
        onopentag (name, attrs) {
            if ("script" === name && !attrs.src && (!attrs.type || "application/javascript" === attrs.type || "text/javascript" === attrs.type)) currentScript = '';
        },
        ontext (text) {
            if (null !== currentScript) currentScript += text;
        },
        onclosetag (tagname) {
            if ("script" === tagname && currentScript) inlineScripts.push(currentScript.trim());
            currentScript = null;
        }
    });
    parser.write(html);
    parser.end();
    return inlineScripts;
}
function checkSyntax_define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const HTML_REGEX = /\.html$/;
const JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
class CheckSyntax {
    async check(filepath, code) {
        if (code) return await this.tryParse(filepath, code);
        if (HTML_REGEX.test(filepath)) {
            const htmlScripts = await generateHtmlScripts(filepath);
            await Promise.all(htmlScripts.map(async (script)=>{
                if (!checkIsExclude(filepath, this.exclude)) await this.tryParse(filepath, script);
            }));
        }
        if (JS_REGEX.test(filepath)) {
            const jsScript = await external_node_fs_default().promises.readFile(filepath, 'utf-8');
            await this.tryParse(filepath, jsScript);
        }
    }
    async tryParse(filepath, code) {
        try {
            (0, external_acorn_namespaceObject.parse)(code, {
                ecmaVersion: this.ecmaVersion
            });
        } catch (_) {
            const err = _;
            const error = await generateError({
                err,
                code,
                filepath,
                exclude: this.exclude,
                rootPath: this.rootPath
            });
            if (error) this.errors.push(error);
        }
    }
    constructor(options){
        checkSyntax_define_property(this, "errors", []);
        checkSyntax_define_property(this, "ecmaVersion", void 0);
        checkSyntax_define_property(this, "targets", void 0);
        checkSyntax_define_property(this, "rootPath", void 0);
        checkSyntax_define_property(this, "exclude", void 0);
        checkSyntax_define_property(this, "excludeOutput", void 0);
        checkSyntax_define_property(this, "excludeErrorLogs", void 0);
        if (!options) throw new Error('[CheckSyntaxRspackPlugin] `options` is required.');
        const { targets, ecmaVersion } = options;
        if (!targets && !ecmaVersion) throw new Error('[CheckSyntaxRspackPlugin] `targets` or `ecmaVersion` option is required');
        this.targets = targets;
        this.ecmaVersion = ecmaVersion || (0, external_browserslist_to_es_version_namespaceObject.browserslistToESVersion)(targets);
        this.exclude = options.exclude;
        this.excludeOutput = options.excludeOutput;
        this.rootPath = options.rootPath || '';
        this.excludeErrorLogs = options.excludeErrorLogs || [];
    }
}
const external_process_namespaceObject = require("process");
const external_os_namespaceObject = require("os");
const external_tty_namespaceObject = require("tty");
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : external_process_namespaceObject.argv) {
    const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
}
var { env } = external_process_namespaceObject;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
function envForceColor() {
    if ("FORCE_COLOR" in env) {
        if ("true" === env.FORCE_COLOR) return 1;
        if ("false" === env.FORCE_COLOR) return 0;
        return 0 === env.FORCE_COLOR.length ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (0 === level) return false;
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (void 0 !== noFlagForceColor) flagForceColor = noFlagForceColor;
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (0 === forceColor) return 0;
    if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
        if (hasFlag("color=256")) return 2;
    }
    if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
    if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
    const min = forceColor || 0;
    if ("dumb" === env.TERM) return min;
    if ("win32" === external_process_namespaceObject.platform) {
        const osRelease = external_os_namespaceObject.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
        return 1;
    }
    if ("CI" in env) {
        if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) return 3;
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "BUILDKITE",
            "DRONE"
        ].some((sign)=>sign in env) || "codeship" === env.CI_NAME) return 1;
        return min;
    }
    if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    if ("truecolor" === env.COLORTERM) return 3;
    if ("xterm-kitty" === env.TERM) return 3;
    if ("TERM_PROGRAM" in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch(env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) return 2;
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
    if ("COLORTERM" in env) return 1;
    return min;
}
function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
var supportsColor = {
    stdout: createSupportsColor({
        isTTY: external_tty_namespaceObject.isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: external_tty_namespaceObject.isatty(2)
    })
};
var supports_color_default = supportsColor;
var colorLevel = supports_color_default.stdout ? supports_color_default.stdout.level : 0;
var errorStackRegExp = /at\s.*:\d+:\d+[\s\)]*$/;
var anonymousErrorStackRegExp = /at\s.*\(<anonymous>\)$/;
var isErrorStackMessage = (message)=>errorStackRegExp.test(message) || anonymousErrorStackRegExp.test(message);
var formatter = (open, close, replace = open)=>colorLevel >= 2 ? (input)=>{
        let string = "" + input;
        let index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    } : String;
var replaceClose = (string, close, replace, index)=>{
    let start = string.substring(0, index) + replace;
    let end = string.substring(index + close.length);
    let nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
var bold = formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m");
var red = formatter("\x1B[31m", "\x1B[39m");
var green = formatter("\x1B[32m", "\x1B[39m");
var yellow = formatter("\x1B[33m", "\x1B[39m");
var magenta = formatter("\x1B[35m", "\x1B[39m");
var cyan = formatter("\x1B[36m", "\x1B[39m");
var gray = formatter("\x1B[90m", "\x1B[39m");
var startColor = [
    189,
    255,
    243
];
var endColor = [
    74,
    194,
    154
];
var isWord = (char)=>!/[\s\n]/.test(char);
var gradient = (message)=>{
    if (colorLevel < 3) return 2 === colorLevel ? bold(cyan(message)) : message;
    let chars = [
        ...message
    ];
    let steps = chars.filter(isWord).length;
    let r = startColor[0];
    let g = startColor[1];
    let b = startColor[2];
    let rStep = (endColor[0] - r) / steps;
    let gStep = (endColor[1] - g) / steps;
    let bStep = (endColor[2] - b) / steps;
    let output = "";
    for (let char of chars){
        if (isWord(char)) {
            r += rStep;
            g += gStep;
            b += bStep;
        }
        output += `\x1B[38;2;${Math.round(r)};${Math.round(g)};${Math.round(b)}m${char}\x1B[39m`;
    }
    return bold(output);
};
var LOG_LEVEL = {
    error: 0,
    warn: 1,
    info: 2,
    log: 3,
    verbose: 4
};
var LOG_TYPES = {
    error: {
        label: "error",
        level: "error",
        color: red
    },
    warn: {
        label: "warn",
        level: "warn",
        color: yellow
    },
    info: {
        label: "info",
        level: "info",
        color: cyan
    },
    start: {
        label: "start",
        level: "info",
        color: cyan
    },
    ready: {
        label: "ready",
        level: "info",
        color: green
    },
    success: {
        label: "success",
        level: "info",
        color: green
    },
    log: {
        level: "log"
    },
    debug: {
        label: "debug",
        level: "verbose",
        color: magenta
    }
};
var createLogger = (options = {})=>{
    let maxLevel = options.level || "log";
    let log = (type, message, ...args)=>{
        if (LOG_LEVEL[LOG_TYPES[type].level] > LOG_LEVEL[maxLevel]) return;
        if (null == message) return console.log();
        let logType = LOG_TYPES[type];
        let label = "";
        let text = "";
        if ("label" in logType) {
            label = (logType.label || "").padEnd(7);
            label = bold(logType.color ? logType.color(label) : label);
        }
        if (message instanceof Error) {
            if (message.stack) {
                let [name, ...rest] = message.stack.split("\n");
                if (name.startsWith("Error: ")) name = name.slice(7);
                text = `${name}
${gray(rest.join("\n"))}`;
            } else text = message.message;
        } else if ("error" === logType.level && "string" == typeof message) {
            let lines = message.split("\n");
            text = lines.map((line)=>isErrorStackMessage(line) ? gray(line) : line).join("\n");
        } else text = `${message}`;
        console.log(label.length ? `${label} ${text}` : text, ...args);
    };
    let logger2 = {
        greet: (message)=>log("log", gradient(message))
    };
    Object.keys(LOG_TYPES).forEach((key)=>{
        logger2[key] = (...args)=>log(key, ...args);
    });
    Object.defineProperty(logger2, "level", {
        get: ()=>maxLevel,
        set (val) {
            maxLevel = val;
        }
    });
    logger2.override = (customLogger)=>{
        Object.assign(logger2, customLogger);
    };
    return logger2;
};
var logger = createLogger();
function printErrors(errors, ecmaVersion, excludeErrorLogs) {
    if (0 === errors.length) {
        logger.success('[@rsbuild/plugin-check-syntax] Syntax check passed.');
        return;
    }
    const errs = errors.map((error)=>({
            source: `${error.source.path}:${error.source.line}:${error.source.column}`,
            output: error.output ? `${error.output.path}:${error.output.line}:${error.output.column}` : void 0,
            reason: error.message,
            code: error.source.code
        }));
    const longest = Math.max(...Object.keys(errs[0]).map((err)=>err.length));
    const expectedVersion = external_picocolors_default().yellow(`ecmaVersion <= ${ecmaVersion}`);
    logger.error(`[@rsbuild/plugin-check-syntax] Find some syntax that does not match "${expectedVersion}":\n`);
    errs.forEach((err, index)=>{
        console.log(external_picocolors_default().bold(external_picocolors_default().red(`  ERROR ${index + 1}`)));
        printMain(err, longest, excludeErrorLogs);
    });
    throw new Error(`[@rsbuild/plugin-check-syntax] The current build fails due to an incompatible syntax, which can be fixed in the following ways:

  - If you want to downgrade the syntax, you can compile the specified module through the \`source.include\` config.
  - If you don't want to downgrade the syntax, you can adjust the project's browserslist to match the syntax, or set the \`ecmaVersion\` option.
  - If you don't want to check the syntax of specified files, you can use the \`exclude\` option to exclude the files to be checked.\n`);
}
function printMain(error, longest, excludeErrorLogs) {
    const fillWhiteSpace = (s, longest)=>{
        if (s.length < longest) {
            const rightPadding = ' '.repeat(longest - s.length);
            return s + rightPadding;
        }
        return s;
    };
    for (const [key, content] of Object.entries(error)){
        if (!content || excludeErrorLogs.includes(key)) continue;
        const title = external_picocolors_default().magenta(`${fillWhiteSpace(`${key}:`, longest + 1)}`);
        console.info(`  ${title}  ${content}`);
    }
    console.info('');
}
const CheckSyntaxPlugin_HTML_REGEX = /\.html$/;
const CheckSyntaxPlugin_JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
class CheckSyntaxRspackPlugin extends CheckSyntax {
    apply(compiler) {
        if (compiler.options.context && !this.rootPath) this.rootPath = compiler.options.context;
        compiler.hooks.afterEmit.tapPromise(CheckSyntaxRspackPlugin.name, async (compilation)=>{
            const outputPath = compilation.outputOptions.path || 'dist';
            const emittedAssets = compilation.getAssets().filter((a)=>a.source).map((a)=>{
                const resourcePath = a.name.split('?')[0];
                const file = (0, external_node_path_namespaceObject.resolve)(outputPath, resourcePath);
                if (!checkIsExclude(file, this.excludeOutput)) return file;
                return '';
            });
            const files = emittedAssets.filter((assets)=>CheckSyntaxPlugin_HTML_REGEX.test(assets) || CheckSyntaxPlugin_JS_REGEX.test(assets));
            await Promise.all(files.map(async (file)=>{
                await this.check(file);
            }));
            printErrors(this.errors, this.ecmaVersion, this.excludeErrorLogs);
        });
    }
}
const PLUGIN_CHECK_SYNTAX_NAME = 'rsbuild:check-syntax';
function pluginCheckSyntax(options = {}) {
    return {
        name: PLUGIN_CHECK_SYNTAX_NAME,
        setup (api) {
            api.modifyBundlerChain(async (chain, { isDev, target, environment })=>{
                if (isDev || 'web' !== target) return;
                const { rootPath } = api.context;
                const targets = options.targets ?? environment.browserslist;
                chain.plugin(CheckSyntaxRspackPlugin.name).use(CheckSyntaxRspackPlugin, [
                    {
                        targets,
                        rootPath,
                        ...'object' == typeof options ? options : {}
                    }
                ]);
            });
        }
    };
}
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});
