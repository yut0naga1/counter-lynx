"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    RsdoctorRspackPlugin: ()=>RsdoctorRspackPlugin
});
const sdk_namespaceObject = require("@rsdoctor/sdk");
const plugins_namespaceObject = require("@rsdoctor/core/plugins");
const build_utils_namespaceObject = require("@rsdoctor/core/build-utils");
const types_namespaceObject = require("@rsdoctor/types");
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
const external_constants_js_namespaceObject = require("./constants.js");
const external_lodash_namespaceObject = require("lodash");
const common_namespaceObject = require("@rsdoctor/utils/common");
const logger_namespaceObject = require("@rsdoctor/utils/logger");
const graph_namespaceObject = require("@rsdoctor/graph");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class RsdoctorRspackPlugin {
    apply(compiler) {
        (0, logger_namespaceObject.time)('RsdoctorRspackPlugin.apply');
        try {
            var _compiler_webpack_experiments;
            if (!this._bootstrapTask) this._bootstrapTask = this.sdk.bootstrap();
            if (compiler.options.name) this.sdk.setName(compiler.options.name);
            (0, plugins_namespaceObject.setSDK)(this.sdk);
            compiler.hooks.afterPlugins.tap(external_constants_js_namespaceObject.pluginTapPostOptions, this.afterPlugins.bind(this, compiler));
            compiler.hooks.done.tapPromise({
                ...external_constants_js_namespaceObject.pluginTapPostOptions,
                stage: external_constants_js_namespaceObject.pluginTapPostOptions.stage + 100
            }, this.done.bind(this, compiler));
            new plugins_namespaceObject.InternalSummaryPlugin(this).apply(compiler);
            if (this.options.features.loader) {
                new build_utils_namespaceObject.Loader.ProbeLoaderPlugin().apply(compiler);
                this.sdk.addClientRoutes([
                    types_namespaceObject.Manifest.RsdoctorManifestClientRoutes.WebpackLoaders
                ]);
                if (!common_namespaceObject.Loader.isVue(compiler)) new plugins_namespaceObject.InternalLoaderPlugin(this).apply(compiler);
            }
            if (this.options.features.plugins) new plugins_namespaceObject.InternalPluginsPlugin(this).apply(compiler);
            if (this.options.features.bundle) {
                new plugins_namespaceObject.InternalBundlePlugin(this).apply(compiler);
                new plugins_namespaceObject.InternalBundleTagPlugin(this).apply(compiler);
            }
            if (this.options.features.resolver) logger_namespaceObject.logger.info(logger_namespaceObject.chalk.yellow('Rspack currently does not support Resolver capabilities.'));
            new plugins_namespaceObject.InternalRulesPlugin(this).apply(compiler);
            new plugins_namespaceObject.InternalErrorReporterPlugin(this).apply(compiler);
            const RsdoctorRspackNativePlugin = null == (_compiler_webpack_experiments = compiler.webpack.experiments) ? void 0 : _compiler_webpack_experiments.RsdoctorPlugin;
            if (RsdoctorRspackNativePlugin) {
                var _this_options_experiments;
                logger_namespaceObject.logger.debug('[RspackNativePlugin] Enabled');
                const enableNativePlugin = null == (_this_options_experiments = this.options.experiments) ? void 0 : _this_options_experiments.enableNativePlugin;
                new RsdoctorRspackNativePlugin({
                    moduleGraphFeatures: 'boolean' == typeof enableNativePlugin ? enableNativePlugin : (null == enableNativePlugin ? void 0 : enableNativePlugin.moduleGraph) || false,
                    chunkGraphFeatures: 'boolean' == typeof enableNativePlugin ? enableNativePlugin : (null == enableNativePlugin ? void 0 : enableNativePlugin.chunkGraph) || false,
                    sourceMapFeatures: {
                        cheap: false,
                        module: false
                    }
                }).apply(compiler);
            }
        } finally{
            (0, logger_namespaceObject.timeEnd)('RsdoctorRspackPlugin.apply');
        }
    }
    ensureModulesChunksGraphApplied(compiler) {
        (0, plugins_namespaceObject.ensureModulesChunksGraphFn)(compiler, this);
    }
    getRspackConfig(compiler) {
        (0, logger_namespaceObject.time)('RsdoctorRspackPlugin.getRspackConfig');
        try {
            var _compiler_webpack, _compiler_webpack1;
            if (compiler.isChild()) return;
            const { plugins, infrastructureLogging, ...rest } = compiler.options;
            const _rest = (0, external_lodash_namespaceObject.cloneDeep)(rest);
            (0, plugins_namespaceObject.makeRulesSerializable)(_rest.module.defaultRules);
            (0, plugins_namespaceObject.makeRulesSerializable)(_rest.module.rules);
            const configuration = {
                ..._rest,
                plugins: plugins.map((e)=>null == e ? void 0 : e.constructor.name)
            };
            const rspackVersion = null == (_compiler_webpack = compiler.webpack) ? void 0 : _compiler_webpack.rspackVersion;
            const webpackVersion = null == (_compiler_webpack1 = compiler.webpack) ? void 0 : _compiler_webpack1.version;
            this.sdk.reportConfiguration({
                name: rspackVersion ? 'rspack' : 'webpack',
                version: rspackVersion || webpackVersion || 'unknown',
                config: configuration,
                root: (0, sdk_namespaceObject.findRoot)() || ''
            });
            this.sdk.setOutputDir(external_path_default().resolve(this.options.output.reportDir || compiler.outputPath, `./${types_namespaceObject.Constants.RsdoctorOutputFolder}`));
        } finally{
            (0, logger_namespaceObject.timeEnd)('RsdoctorRspackPlugin.getRspackConfig');
        }
    }
    constructor(options){
        _define_property(this, "name", external_constants_js_namespaceObject.pluginTapName);
        _define_property(this, "sdk", void 0);
        _define_property(this, "isRsdoctorPlugin", void 0);
        _define_property(this, "_bootstrapTask", void 0);
        _define_property(this, "browserIsOpened", false);
        _define_property(this, "modulesGraph", void 0);
        _define_property(this, "options", void 0);
        _define_property(this, "outsideInstance", void 0);
        _define_property(this, "afterPlugins", (compiler)=>{
            (0, logger_namespaceObject.time)('RsdoctorRspackPlugin.afterPlugins');
            try {
                this.getRspackConfig(compiler);
            } finally{
                (0, logger_namespaceObject.timeEnd)('RsdoctorRspackPlugin.afterPlugins');
            }
        });
        _define_property(this, "done", async (compiler)=>{
            (0, logger_namespaceObject.time)('RsdoctorRspackPlugin.done');
            try {
                await this.sdk.bootstrap();
                this.sdk.addClientRoutes([
                    types_namespaceObject.Manifest.RsdoctorManifestClientRoutes.Overall
                ]);
                if (this.outsideInstance && 'parent' in this.sdk) this.sdk.parent.master.setOutputDir(external_path_default().resolve(this.options.output.reportDir || compiler.outputPath, `./${types_namespaceObject.Constants.RsdoctorOutputFolder}`));
                this.sdk.setOutputDir(external_path_default().resolve(this.options.output.reportDir || compiler.outputPath, `./${types_namespaceObject.Constants.RsdoctorOutputFolder}`));
                await this.sdk.writeStore();
                if (!this.options.disableClientServer) if (this.options.mode === types_namespaceObject.SDK.IMode[types_namespaceObject.SDK.IMode.brief]) {
                    const outputFilePath = external_path_default().resolve(this.sdk.outputDir, this.options.brief.reportHtmlName || 'rsdoctor-report.html');
                    console.log(`${logger_namespaceObject.chalk.green('[RSDOCTOR] generated brief report')}: ${outputFilePath}`);
                    (0, sdk_namespaceObject.openBrowser)(`file:///${outputFilePath}`);
                } else await this.sdk.server.openClientPage('homepage');
                if (this.options.disableClientServer) await this.sdk.dispose();
            } finally{
                (0, logger_namespaceObject.timeEnd)('RsdoctorRspackPlugin.done');
            }
        });
        this.options = (0, plugins_namespaceObject.normalizeRspackUserOptions)(Object.assign(options || {}, {
            supports: {
                ...null == options ? void 0 : options.supports
            }
        }));
        this.sdk = this.options.sdkInstance ?? new sdk_namespaceObject.RsdoctorSDK({
            port: this.options.port,
            name: external_constants_js_namespaceObject.pluginTapName,
            root: process.cwd(),
            type: this.options.output.reportCodeType,
            config: {
                innerClientPath: this.options.innerClientPath,
                printLog: this.options.printLog,
                mode: this.options.mode ? this.options.mode : void 0,
                brief: this.options.brief,
                compressData: this.options.output.compressData
            }
        });
        this.outsideInstance = Boolean(this.options.sdkInstance);
        this.modulesGraph = new graph_namespaceObject.ModuleGraph();
        this.isRsdoctorPlugin = true;
    }
}
exports.RsdoctorRspackPlugin = __webpack_exports__.RsdoctorRspackPlugin;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "RsdoctorRspackPlugin"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
