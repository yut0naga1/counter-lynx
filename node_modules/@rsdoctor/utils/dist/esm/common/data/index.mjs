import { Constants, Rule, SDK } from "@rsdoctor/types";
import { getDirectoriesLoaders, getLoaderChartData, getLoaderFileDetails, getLoaderFileFirstInput, getLoaderFileTree, getLoaderFolderStatistics, getLoaderNames } from "../loader.mjs";
import { getResolverFileDetails, getResolverFileTree } from "../resolver.mjs";
import { getPluginData, getPluginSummary } from "../plugin.mjs";
import { getAllBundleData, getAssetDetails, getAssetsSummary, getChunksByModuleId, getEntryPoints, getModuleDetails, getModuleIdsByModulesIds } from "../graph/index.mjs";
import { getPackageRelationAlertDetails } from "../alerts.mjs";
import { relative } from "path";
import { checkSourceMapSupport } from "../rspack.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class APIDataLoader {
    log(...args) {
        console.log(`[${this.constructor.name}]`, ...args);
    }
    loadAPI(...args) {
        const [api, body] = args;
        switch(api){
            case SDK.ServerAPI.API.LoadDataByKey:
                return this.loader.loadData(body.key);
            case SDK.ServerAPI.API.GetProjectInfo:
                return Promise.all([
                    this.loader.loadData('root'),
                    this.loader.loadData('pid'),
                    this.loader.loadData('hash'),
                    this.loader.loadData('summary'),
                    this.loader.loadData('configs'),
                    this.loader.loadData('envinfo'),
                    this.loader.loadData('errors')
                ]).then(([root, pid, hash, summary, configs, envinfo, errors])=>({
                        root,
                        pid,
                        hash,
                        summary,
                        configs,
                        envinfo,
                        errors
                    }));
            case SDK.ServerAPI.API.GetClientRoutes:
                var _window;
                if ('undefined' != typeof window && (null == (_window = window) ? void 0 : _window[Constants.WINDOW_RSDOCTOR_TAG])) return window[Constants.WINDOW_RSDOCTOR_TAG].enableRoutes;
                return this.loader.loadManifest().then((res)=>{
                    const { enableRoutes = [] } = res.client || {};
                    return enableRoutes;
                });
            case SDK.ServerAPI.API.GetLoaderNames:
                return this.loader.loadData('loader').then((res)=>getLoaderNames(res || []));
            case SDK.ServerAPI.API.GetLayers:
                return this.loader.loadData('moduleGraph').then((res)=>{
                    const { layers } = res || {};
                    return layers;
                });
            case SDK.ServerAPI.API.GetLoaderChartData:
                return this.loader.loadData('loader').then((res)=>getLoaderChartData(res || []));
            case SDK.ServerAPI.API.GetLoaderFileTree:
                return this.loader.loadData('loader').then((res)=>getLoaderFileTree(res || []));
            case SDK.ServerAPI.API.GetLoaderFileDetails:
                return this.loader.loadData('loader').then((res)=>getLoaderFileDetails(body.path, res || []));
            case SDK.ServerAPI.API.GetLoaderFolderStatistics:
                return this.loader.loadData('loader').then((res)=>getLoaderFolderStatistics(body.folder, res || []));
            case SDK.ServerAPI.API.GetLoaderFileFirstInput:
                return this.loader.loadData('loader').then((res)=>getLoaderFileFirstInput(body.file, res || []));
            case SDK.ServerAPI.API.GetLoaderFileInputAndOutput:
                return this.loader.loadData('loader').then((res)=>getLoaderFileFirstInput(body.file, res || []));
            case SDK.ServerAPI.API.GetResolverFileTree:
                return this.loader.loadData('resolver').then((res)=>getResolverFileTree(res || []));
            case SDK.ServerAPI.API.GetResolverFileDetails:
                return Promise.all([
                    this.loader.loadData('resolver'),
                    this.loader.loadData('moduleGraph.modules'),
                    this.loader.loadData('moduleCodeMap')
                ]).then((res)=>{
                    const resolverData = res[0];
                    const modules = res[1];
                    const moduleCodeMap = res[2];
                    return getResolverFileDetails(body.filepath, resolverData || [], modules || [], moduleCodeMap || {});
                });
            case SDK.ServerAPI.API.GetPluginSummary:
                return this.loader.loadData('plugin').then((res)=>getPluginSummary(res || {}));
            case SDK.ServerAPI.API.GetPluginData:
                return this.loader.loadData('plugin').then((res)=>{
                    const { hooks, tapNames } = body;
                    return getPluginData(res || {}, hooks, tapNames);
                });
            case SDK.ServerAPI.API.GetAssetsSummary:
                return this.loader.loadData('chunkGraph').then((res)=>{
                    const { withFileContent = true } = body;
                    const { assets = [], chunks = [] } = res || {};
                    return getAssetsSummary(assets, chunks, {
                        withFileContent
                    });
                });
            case SDK.ServerAPI.API.GetAssetDetails:
                return Promise.all([
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph'),
                    this.loader.loadData('configs')
                ]).then((res)=>{
                    const { assetPath } = body;
                    const configs = res[2] || [];
                    const { isRspack, hasSourceMap } = checkSourceMapSupport(configs);
                    const { assets = [], chunks = [] } = res[0] || {};
                    const { modules = [] } = res[1] || {};
                    const checkModules = (_module)=>true;
                    return getAssetDetails(assetPath, assets, chunks, modules, isRspack || hasSourceMap ? checkModules : ()=>true);
                });
            case SDK.ServerAPI.API.GetSummaryBundles:
                return Promise.all([
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph')
                ]).then((res)=>{
                    const { assets = [], chunks = [] } = res[0] || {};
                    const { modules = [] } = res[1] || {};
                    return getAllBundleData(assets, chunks, modules, [
                        'id',
                        'path',
                        'size',
                        'kind'
                    ]);
                });
            case SDK.ServerAPI.API.GetChunksByModuleId:
                return Promise.all([
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph')
                ]).then((res)=>{
                    const { moduleId } = body;
                    const { chunks = [] } = res[0] || {};
                    const { modules = [] } = res[1] || {};
                    return getChunksByModuleId(moduleId, modules, chunks);
                });
            case SDK.ServerAPI.API.GetModuleDetails:
                return Promise.all([
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph')
                ]).then((res)=>{
                    const { moduleId } = body;
                    const { modules = [], dependencies = [] } = res[1] || {};
                    return getModuleDetails(moduleId, modules, dependencies);
                });
            case SDK.ServerAPI.API.GetModulesByModuleIds:
                return this.loader.loadData('moduleGraph').then((res)=>{
                    const { moduleIds } = body;
                    const { modules = [] } = res || {};
                    return getModuleIdsByModulesIds(moduleIds, modules);
                });
            case SDK.ServerAPI.API.GetEntryPoints:
                return Promise.all([
                    this.loader.loadData('chunkGraph')
                ]).then((res)=>{
                    const [chunkGraph] = res;
                    const { entrypoints = [] } = chunkGraph || {};
                    return getEntryPoints(entrypoints);
                });
            case SDK.ServerAPI.API.GetModuleCodeByModuleId:
                return this.loader.loadData('moduleCodeMap').then((moduleCodeMap)=>{
                    const { moduleId } = body;
                    if (moduleCodeMap) return moduleCodeMap[moduleId];
                    return {
                        source: '',
                        transformed: '',
                        parsedSource: ''
                    };
                });
            case SDK.ServerAPI.API.GetModuleCodeByModuleIds:
                return this.loader.loadData('moduleCodeMap').then((moduleCodeMap)=>{
                    const { moduleIds } = body;
                    const _moduleCodeData = {};
                    if (moduleCodeMap) {
                        moduleIds.forEach((id)=>{
                            _moduleCodeData[id] = moduleCodeMap[id];
                        });
                        return _moduleCodeData;
                    }
                    return [];
                });
            case SDK.ServerAPI.API.GetAllModuleGraph:
                return this.loader.loadData('moduleGraph').then((moduleGraph)=>null == moduleGraph ? void 0 : moduleGraph.modules);
            case SDK.ServerAPI.API.GetSearchModules:
                return Promise.all([
                    this.loader.loadData('moduleGraph'),
                    this.loader.loadData('chunkGraph')
                ]).then((res)=>{
                    const [moduleGraph, chunkGraph] = res;
                    const { moduleName } = body;
                    if (!moduleName) return [];
                    const assetMap = chunkGraph.chunks.reduce((acc, chunk)=>{
                        chunk.assets.forEach((asset)=>{
                            if (!acc[chunk.id]) acc[chunk.id] = [];
                            acc[chunk.id].push(asset);
                        });
                        return acc;
                    }, {});
                    const searchedChunksMap = new Map();
                    null == moduleGraph || moduleGraph.modules.filter((module)=>{
                        if (module.webpackId.includes(moduleName)) module.chunks.forEach((chunk)=>{
                            if (searchedChunksMap.has(chunk)) return;
                            const assets = assetMap[chunk] || [];
                            assets.forEach((asset)=>{
                                if (asset.endsWith('.js')) searchedChunksMap.set(chunk, asset);
                            });
                        });
                    });
                    return Object.fromEntries(searchedChunksMap);
                });
            case SDK.ServerAPI.API.GetSearchModuleInChunk:
                return Promise.all([
                    this.loader.loadData('moduleGraph'),
                    this.loader.loadData('root')
                ]).then((res)=>{
                    const [moduleGraph, root] = res;
                    const { moduleName, chunk } = body;
                    if (!moduleName) return [];
                    const filteredModules = null == moduleGraph ? void 0 : moduleGraph.modules.filter((module)=>module.webpackId.includes(moduleName) && module.chunks.includes(chunk)).map((filteredModule)=>({
                            id: filteredModule.id,
                            path: filteredModule.path,
                            relativePath: relative(root, filteredModule.path)
                        }));
                    return filteredModules;
                });
            case SDK.ServerAPI.API.GetAllChunkGraph:
                return this.loader.loadData('chunkGraph').then((chunkGraph)=>null == chunkGraph ? void 0 : chunkGraph.chunks);
            case SDK.ServerAPI.API.GetPackageRelationAlertDetails:
                return Promise.all([
                    this.loader.loadData('moduleGraph'),
                    this.loader.loadData('errors'),
                    this.loader.loadData('root'),
                    this.loader.loadData('moduleCodeMap')
                ]).then((res)=>{
                    const { id, target } = body;
                    const [moduleGraph, errors = [], root = '', moduleCodeMap] = res;
                    const { modules = [], dependencies = [] } = moduleGraph || {};
                    const { packages = [] } = errors.find((e)=>e.id === id) || {};
                    const { dependencies: pkgDependencies = [] } = packages.find((e)=>e.target.name === target.name && e.target.root === target.root && e.target.version === target.version) || {};
                    return getPackageRelationAlertDetails(modules, dependencies, root, pkgDependencies, moduleCodeMap || {});
                });
            case SDK.ServerAPI.API.GetOverlayAlerts:
                return this.loader.loadData('errors').then((res)=>(res || []).filter((e)=>e.code === Rule.RuleMessageCodeEnumerated.Overlay));
            case SDK.ServerAPI.API.BundleDiffManifest:
                return this.loader.loadManifest();
            case SDK.ServerAPI.API.GetBundleDiffSummary:
                return Promise.all([
                    this.loader.loadManifest(),
                    this.loader.loadData('root'),
                    this.loader.loadData('hash'),
                    this.loader.loadData('errors'),
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph'),
                    this.loader.loadData('moduleCodeMap'),
                    this.loader.loadData('packageGraph'),
                    this.loader.loadData('configs')
                ]).then(([_manifest, root = '', hash = '', errors = {}, chunkGraph = {}, moduleGraph = {}, moduleCodeMap = {}, packageGraph = {}, configs = []])=>{
                    var _configs__config_output, _configs__config, _configs_;
                    let outputFilename = '';
                    if ('string' == typeof (null == (_configs_ = configs[0]) ? void 0 : null == (_configs__config = _configs_.config) ? void 0 : null == (_configs__config_output = _configs__config.output) ? void 0 : _configs__config_output.chunkFilename)) {
                        var _configs_1;
                        outputFilename = null == (_configs_1 = configs[0]) ? void 0 : _configs_1.config.output.chunkFilename;
                    }
                    return {
                        root,
                        hash,
                        errors,
                        chunkGraph,
                        moduleGraph,
                        packageGraph,
                        outputFilename,
                        moduleCodeMap
                    };
                });
            case SDK.ServerAPI.API.GetChunkGraph:
                return this.loader.loadData('chunkGraph').then((res)=>{
                    const { chunks = [] } = res || {};
                    return chunks;
                });
            case SDK.ServerAPI.API.GetAllModuleGraphFilter:
                return this.loader.loadData('moduleGraph').then((moduleGraph)=>null == moduleGraph ? void 0 : moduleGraph.modules.map((m)=>({
                            id: m.id,
                            webpackId: m.webpackId,
                            path: m.path,
                            size: m.size,
                            chunks: m.chunks,
                            kind: m.kind
                        })));
            case SDK.ServerAPI.API.GetModuleByName:
                return this.loader.loadData('moduleGraph').then((moduleGraph)=>{
                    const { moduleName } = body;
                    const { modules = [] } = moduleGraph || {};
                    return modules.filter((m)=>m.path.includes(moduleName)).map((m)=>({
                            id: m.id,
                            path: m.path
                        })) || [];
                });
            case SDK.ServerAPI.API.GetModuleIssuerPath:
                return this.loader.loadData('moduleGraph').then((moduleGraph)=>{
                    var _modules_find;
                    const { moduleId } = body;
                    const modules = (null == moduleGraph ? void 0 : moduleGraph.modules) || [];
                    const issuerPath = (null == (_modules_find = modules.find((m)=>String(m.id) === moduleId)) ? void 0 : _modules_find.issuerPath) || [];
                    if (Array.isArray(issuerPath) && issuerPath.length > 0 && 'number' == typeof issuerPath[0]) return issuerPath.map((id)=>{
                        var _modules_find;
                        return null == (_modules_find = modules.find((m)=>m.id === id)) ? void 0 : _modules_find.path;
                    }).filter(Boolean);
                    return issuerPath;
                });
            case SDK.ServerAPI.API.GetPackageInfo:
                return this.loader.loadData('packageGraph').then((packageGraph)=>null == packageGraph ? void 0 : packageGraph.packages);
            case SDK.ServerAPI.API.GetPackageDependency:
                return this.loader.loadData('packageGraph').then((packageGraph)=>(null == packageGraph ? void 0 : packageGraph.dependencies) || []);
            case SDK.ServerAPI.API.GetChunkGraphAI:
                return this.loader.loadData('chunkGraph').then((res)=>{
                    const { chunks = [] } = res || {};
                    const filteredChunks = chunks.map(({ modules, ...rest })=>rest);
                    return filteredChunks;
                });
            case SDK.ServerAPI.API.GetChunkByIdAI:
                return Promise.all([
                    this.loader.loadData('chunkGraph'),
                    this.loader.loadData('moduleGraph')
                ]).then(([chunkGraph, moduleGraph])=>{
                    const { chunks = [] } = chunkGraph || {};
                    const { modules = [] } = moduleGraph || {};
                    const { chunkId } = body;
                    const chunkInfo = chunks.find((c)=>c.id === chunkId);
                    if (!chunkInfo) return null;
                    const chunkModules = modules.filter((m)=>chunkInfo.modules.includes(m.id)).map((module)=>({
                            id: module.id,
                            path: module.path,
                            size: module.size,
                            chunks: module.chunks,
                            kind: module.kind,
                            issuerPath: module.issuerPath
                        }));
                    chunkInfo.modulesInfo = chunkModules;
                    return chunkInfo;
                });
            case SDK.ServerAPI.API.GetDirectoriesLoaders:
                return Promise.all([
                    this.loader.loadData('root'),
                    this.loader.loadData('loader')
                ]).then(([root, loaders])=>getDirectoriesLoaders(loaders || [], root || ''));
            default:
                throw new Error(`API not implement: "${api}"`);
        }
    }
    constructor(loader){
        _define_property(this, "loader", void 0);
        this.loader = loader;
        this.loadAPI = this.loadAPI.bind(this);
    }
}
export { APIDataLoader };
