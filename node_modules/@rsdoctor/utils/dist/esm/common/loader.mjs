import { mergeIntervals } from "./algorithm.mjs";
function findLoaderTotalTiming(loaders) {
    let start = 1 / 0;
    let end = -1 / 0;
    for(let i = 0; i < loaders.length; i++){
        const loader = loaders[i];
        if (loader.startAt <= start) start = loader.startAt;
        if (loader.endAt >= end) end = loader.endAt;
    }
    return {
        start,
        end
    };
}
function getLoadersCosts(filter, loaders) {
    const match = {};
    const others = {};
    loaders.forEach((e)=>{
        if (filter(e)) {
            if (!match[e.pid]) match[e.pid] = [];
            match[e.pid].push([
                e.startAt,
                e.endAt
            ]);
        } else {
            if (!others[e.pid]) others[e.pid] = [];
            others[e.pid].push([
                e.startAt,
                e.endAt
            ]);
        }
    });
    let costs = 0;
    const pids = Object.keys(match);
    for(let i = 0; i < pids.length; i++){
        const pid = pids[i];
        const _match = mergeIntervals(match[pid]);
        const _others = mergeIntervals(others[pid] || []).filter(([s, e])=>_match.some((el)=>s >= el[0] && e <= el[1]));
        const matchSum = _match.length ? _match.reduce((t, c)=>t += c[1] - c[0], 0) : 0;
        const othersSum = _others.length ? _others.reduce((t, c)=>t += c[1] - c[0], 0) : 0;
        costs += matchSum - othersSum;
    }
    return costs;
}
function getLoaderCosts(loader, loaders) {
    const blocked = loaders.filter((e)=>{
        if (e.loader.includes('builtin')) return false;
        if (e !== loader && e.pid === loader.pid) {
            if (e.startAt >= loader.startAt) {
                if (e.endAt <= loader.endAt) return true;
            }
        }
        return false;
    });
    let costs = loader.endAt - loader.startAt;
    if (blocked.length) {
        const intervals = blocked.map((e)=>[
                Math.max(e.startAt, loader.startAt),
                Math.min(e.endAt, loader.endAt)
            ]);
        mergeIntervals(intervals).forEach((e)=>{
            const sub = e[1] - e[0];
            costs -= sub;
        });
    }
    return costs;
}
function getLoaderNames(loaders) {
    const names = new Set();
    loaders.forEach((e)=>e.loaders.forEach((l)=>names.add(getLoadrName(l.loader))));
    return [
        ...names
    ];
}
function getLoadersTransformData(loaders) {
    const res = [];
    for(let i = 0; i < loaders.length; i++){
        const item = loaders[i];
        for(let j = 0; j < item.loaders.length; j++){
            const loader = item.loaders[j];
            res.push(loader);
        }
    }
    return res;
}
function getLoaderChartData(loaders) {
    const res = [];
    const list = getLoadersTransformData(loaders);
    loaders.forEach((item)=>{
        item.loaders.forEach((el)=>{
            res.push({
                layer: item.resource.layer,
                loader: getLoadrName(el.loader),
                isPitch: el.isPitch,
                startAt: el.startAt,
                endAt: el.endAt,
                pid: el.pid,
                sync: el.sync,
                resource: item.resource.path,
                costs: getLoaderCosts(el, list)
            });
        });
    });
    return res;
}
function getLoaderFileTree(loaders) {
    const list = getLoadersTransformData(loaders);
    return loaders.map((data)=>{
        const { loaders: arr, resource } = data;
        return {
            path: resource.path,
            layer: resource.layer,
            loaders: arr.map((l)=>({
                    key: l.path,
                    loader: getLoadrName(l.loader),
                    path: l.path,
                    errors: l.errors,
                    costs: getLoaderCosts(l, list)
                }))
        };
    });
}
function getLoaderFileDetails(path, loaders) {
    const data = loaders.find((e)=>e.resource.path === path);
    if (!data) throw new Error(`"${path}" not match any loader data`);
    const list = getLoadersTransformData(loaders);
    return {
        ...data,
        loaders: data.loaders.map((el)=>({
                ...el,
                loader: getLoadrName(el.loader),
                costs: getLoaderCosts(el, list)
            }))
    };
}
function getLoaderFolderStatistics(folder, loaders) {
    const datas = loaders.filter((data)=>{
        const { path } = data.resource;
        return path.startsWith(folder);
    });
    const filteredLoaders = [];
    const uniqueLoaders = new Map();
    datas.forEach((data)=>{
        data.loaders.forEach((fl)=>{
            const uniqueLoader = uniqueLoaders.get(fl.loader);
            if (uniqueLoader) uniqueLoaders.set(fl.loader, {
                files: uniqueLoader.files + 1,
                path: fl.path
            });
            else uniqueLoaders.set(fl.loader, {
                files: 1,
                path: fl.path
            });
            return filteredLoaders.push({
                loader: fl.loader,
                startAt: fl.startAt,
                endAt: fl.endAt,
                pid: fl.pid
            });
        });
    });
    const loaderCosts = Array.from(uniqueLoaders).map((uniqueLoader)=>{
        const filter = (l)=>l.loader === uniqueLoader[0];
        const costs = getLoadersCosts(filter, filteredLoaders);
        return {
            loader: uniqueLoader[0],
            files: uniqueLoader[1].files,
            path: uniqueLoader[1].path,
            costs
        };
    });
    return loaderCosts;
}
function collectResourceDirectories(loaders, root) {
    const directories = new Set();
    loaders.forEach((item)=>{
        if (item.resource.path.startsWith(root)) {
            const pathParts = item.resource.path.split(root).slice(1).join('/').split('/');
            if (pathParts.length >= 2) {
                const twoLevelDir = pathParts.slice(0, 2).join('/');
                directories.add(`${root}/${twoLevelDir}`);
            }
        } else {
            const pathParts = item.resource.path.split('/');
            const twoLevelDir = pathParts.slice(0, pathParts.length - 1).join('/');
            directories.add(twoLevelDir);
        }
    });
    return Array.from(directories);
}
function getDirectoriesLoaders(loaders, root) {
    const rootPath = root || process.cwd();
    const directories = collectResourceDirectories(loaders, rootPath);
    return directories.map((directory)=>{
        const stats = getLoaderFolderStatistics(directory, loaders);
        return {
            directory,
            stats
        };
    });
}
function getLoaderFileFirstInput(file, loaders) {
    for(let i = 0; i < loaders.length; i++){
        const item = loaders[i];
        if (item.resource.path === file) {
            const nonPitchLoaders = item.loaders.filter((e)=>!e.isPitch);
            if (!nonPitchLoaders.length) return '';
            return nonPitchLoaders[0].input || '';
        }
    }
    return '';
}
function getLoaderFileInputAndOutput(file, loader, loaderIndex, loaders) {
    for(let i = 0; i < loaders.length; i++){
        const item = loaders[i];
        if (item.resource.path === file) for(let j = 0; j < item.loaders.length; j++){
            const l = item.loaders[j];
            if (l.loader === loader && l.loaderIndex === loaderIndex) return {
                input: l.input || '',
                output: l.result || ''
            };
            return {
                input: '',
                output: ''
            };
        }
    }
    return {
        input: '',
        output: ''
    };
}
const LoaderInternalPropertyName = '__l__';
const isVue = (compiler)=>{
    const rules = 'module' in compiler.options && compiler.options.module.rules || [];
    const hasVueRule = rules.some((rule)=>{
        var _rule_test;
        if (rule && 'object' == typeof rule && rule.test instanceof RegExp && (null == (_rule_test = rule.test) ? void 0 : _rule_test.test('.vue'))) return true;
        return false;
    });
    return hasVueRule;
};
const getLoadrName = (loader)=>{
    const regResults = loader.includes('node_modules') ? loader.split('node_modules') : null;
    return regResults ? regResults[regResults.length - 1] : loader;
};
export { LoaderInternalPropertyName, findLoaderTotalTiming, getDirectoriesLoaders, getLoaderChartData, getLoaderCosts, getLoaderFileDetails, getLoaderFileFirstInput, getLoaderFileInputAndOutput, getLoaderFileTree, getLoaderFolderStatistics, getLoaderNames, getLoadersCosts, getLoadersTransformData, isVue };
