import fs_extra from "fs-extra";
import fs from "fs";
import path from "path";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class FileSharding {
    createVirtualShardingFiles(ext = '', index = 0) {
        const bf = Buffer.from(this.content, this.encoding);
        const res = [];
        const threshold = this.limitBytes;
        let tmpBytes = 0;
        while(bf.byteLength > tmpBytes){
            res.push(bf.subarray(tmpBytes, tmpBytes + threshold));
            tmpBytes += threshold;
        }
        return res.map((e, i)=>({
                filename: `${i + index}${ext}`,
                content: e
            }));
    }
    async writeStringToFolder(folder, ext = '', index) {
        const dist = path.resolve(folder);
        await fs_extra.ensureDir(dist);
        const res = this.createVirtualShardingFiles(ext, index);
        await Promise.all(res.map((e)=>new Promise((resolve, reject)=>{
                const stream = fs.createWriteStream(path.join(dist, e.filename), this.encoding);
                stream.end(e.content);
                stream.once('close', ()=>resolve(void 0));
                stream.once('error', (err)=>reject(err));
            })));
        return res;
    }
    constructor(content, limitBytes = 10485760, encoding = 'utf-8'){
        _define_property(this, "content", void 0);
        _define_property(this, "limitBytes", void 0);
        _define_property(this, "encoding", void 0);
        this.content = content;
        this.limitBytes = limitBytes;
        this.encoding = encoding;
    }
}
export { FileSharding };
