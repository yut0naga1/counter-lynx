"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    isES6: ()=>isES6,
    getIdentifierInDeclaration: ()=>getIdentifierInDeclaration,
    getIdentifierInExport: ()=>getIdentifierInExport,
    isSameSemantics: ()=>isSameSemantics,
    getIdentifierInImport: ()=>getIdentifierInImport,
    canParse: ()=>canParse,
    getIdentifierInPattern: ()=>getIdentifierInPattern,
    getDefaultImports: ()=>getDefaultImports,
    isES5: ()=>isES5,
    detectECMAVersion: ()=>detectECMAVersion
});
const external_acorn_namespaceObject = require("acorn");
const external_types_js_namespaceObject = require("./types.js");
const external_asserts_js_namespaceObject = require("./asserts.js");
function isSameSemantics(node1, node2) {
    if (node1.type !== node2.type) return false;
    switch(node1.type){
        case 'CallExpression':
            {
                const next = node2;
                return node1.arguments.length === next.arguments.length && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.callee, next.callee) && node1.arguments.every((node, i)=>isSameSemantics(node, next.arguments[i]));
            }
        case 'MemberExpression':
            {
                const next = node2;
                return node1.computed === next.computed && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.object, next.object) && isSameSemantics(node1.property, next.property);
            }
        case 'Identifier':
            return node1.name === node2.name;
        case 'Literal':
            if (external_asserts_js_namespaceObject.asserts.isSimpleLiteral(node1) && external_asserts_js_namespaceObject.asserts.isSimpleLiteral(node2)) return node1.value === node2.value;
            return node1.raw === node2.raw;
        case 'ObjectExpression':
            {
                const next = node2;
                return node1.properties.length === next.properties.length && node1.properties.every((prop, i)=>isSameSemantics(prop, next.properties[i]));
            }
        case 'Property':
            {
                const next = node2;
                return node1.computed === next.computed && node1.kind === next.kind && node1.method === next.method && isSameSemantics(node1.key, next.key) && isSameSemantics(node1.value, next.value);
            }
        default:
            throw new Error(`Unknown node type: ${node1.type}`);
    }
}
function getDefaultImports(node) {
    return node.body.filter((statement)=>{
        var _statement_specifiers;
        if ('ImportDeclaration' !== statement.type) return false;
        const specifier = null == statement ? void 0 : null == (_statement_specifiers = statement.specifiers) ? void 0 : _statement_specifiers[0];
        if ((null == specifier ? void 0 : specifier.type) === 'ImportDefaultSpecifier') return true;
        return false;
    });
}
function getIdentifierInPattern(name, node) {
    if (external_asserts_js_namespaceObject.asserts.isIdentifier(node) && node.name === name) return node;
    if (external_asserts_js_namespaceObject.asserts.isObjectPattern(node)) for (const prop of node.properties){
        if (external_asserts_js_namespaceObject.asserts.isAssignmentProperty(prop)) return getIdentifierInPattern(name, prop.value);
        if (external_asserts_js_namespaceObject.asserts.isRestElement(prop)) return getIdentifierInPattern(name, prop);
    }
    if (external_asserts_js_namespaceObject.asserts.isArrayPattern(node)) {
        for (const el of node.elements)if (el) {
            const result = getIdentifierInPattern(name, el);
            if (result) return result;
        }
    }
    if (external_asserts_js_namespaceObject.asserts.isRestElement(node)) return getIdentifierInPattern(name, node.argument);
    if (external_asserts_js_namespaceObject.asserts.isAssignmentPattern(node)) return getIdentifierInPattern(name, node.left);
}
function getIdentifierInDeclaration(name, node) {
    function getId(node) {
        return external_asserts_js_namespaceObject.asserts.isIdentifier(node.id) && node.id.name === name ? node.id : void 0;
    }
    if (external_asserts_js_namespaceObject.asserts.isFunctionDeclaration(node)) return getId(node);
    if (external_asserts_js_namespaceObject.asserts.isClassDeclaration(node)) return getId(node);
    if (external_asserts_js_namespaceObject.asserts.isVariableDeclaration(node)) {
        var _node_declarations_find;
        return null == (_node_declarations_find = node.declarations.find((item)=>getIdentifierInPattern(name, item.id))) ? void 0 : _node_declarations_find.id;
    }
}
function getIdentifierInImport(name, node) {
    if (external_asserts_js_namespaceObject.asserts.isImportDeclaration(node)) {
        for (const specifier of node.specifiers ?? [])if (specifier.local.name === name) return specifier.local;
    }
}
function getIdentifierInExport(name, node) {
    if (external_asserts_js_namespaceObject.asserts.isExportNamedDeclaration(node)) {
        if (node.declaration) return getIdentifierInDeclaration(name, node.declaration);
        for (const specifier of node.specifiers ?? [])if (specifier.exported.name === name) return specifier.exported;
    }
    if (external_asserts_js_namespaceObject.asserts.isExportAllDeclaration(node) && node.exported) {
        if (node.exported.name === name) return node.exported;
    }
}
function canParse(code, ecmaVersion) {
    try {
        (0, external_acorn_namespaceObject.parse)(code, {
            ecmaVersion,
            sourceType: 'number' == typeof ecmaVersion && ecmaVersion <= 5 ? "script" : 'module'
        });
        return true;
    } catch (err) {
        return false;
    }
}
function isES5(code) {
    return canParse(code, 5);
}
function isES6(code) {
    return canParse(code, 6);
}
function detectECMAVersion(code) {
    if (isES6(code)) {
        if (isES5(code)) return external_types_js_namespaceObject.ECMAVersion.ES5;
        return external_types_js_namespaceObject.ECMAVersion.ES6;
    }
    return external_types_js_namespaceObject.ECMAVersion.ES7P;
}
exports.canParse = __webpack_exports__.canParse;
exports.detectECMAVersion = __webpack_exports__.detectECMAVersion;
exports.getDefaultImports = __webpack_exports__.getDefaultImports;
exports.getIdentifierInDeclaration = __webpack_exports__.getIdentifierInDeclaration;
exports.getIdentifierInExport = __webpack_exports__.getIdentifierInExport;
exports.getIdentifierInImport = __webpack_exports__.getIdentifierInImport;
exports.getIdentifierInPattern = __webpack_exports__.getIdentifierInPattern;
exports.isES5 = __webpack_exports__.isES5;
exports.isES6 = __webpack_exports__.isES6;
exports.isSameSemantics = __webpack_exports__.isSameSemantics;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "canParse",
    "detectECMAVersion",
    "getDefaultImports",
    "getIdentifierInDeclaration",
    "getIdentifierInExport",
    "getIdentifierInImport",
    "getIdentifierInPattern",
    "isES5",
    "isES6",
    "isSameSemantics"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
