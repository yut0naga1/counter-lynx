"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    createGetPortSyncFunctionString: ()=>createGetPortSyncFunctionString,
    defaultPort: ()=>defaultPort,
    getPort: ()=>getPort,
    createApp: ()=>createApp,
    getPortSync: ()=>getPortSync,
    createServer: ()=>createServer
});
const external_connect_namespaceObject = require("connect");
var external_connect_default = /*#__PURE__*/ __webpack_require__.n(external_connect_namespaceObject);
const external_http_namespaceObject = require("http");
var external_http_default = /*#__PURE__*/ __webpack_require__.n(external_http_namespaceObject);
const external_os_namespaceObject = require("os");
var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_namespaceObject);
const external_get_port_namespaceObject = require("get-port");
var external_get_port_default = /*#__PURE__*/ __webpack_require__.n(external_get_port_namespaceObject);
const external_child_process_namespaceObject = require("child_process");
const algorithm_js_namespaceObject = require("../common/algorithm.js");
const RESTRICTED_PORTS = [
    3659,
    4045,
    6000,
    6665,
    6666,
    6667,
    6668,
    6669
];
function getRandomPort(min, max) {
    let port;
    do port = (0, algorithm_js_namespaceObject.random)(min, max);
    while (RESTRICTED_PORTS.includes(port));
    return port;
}
const defaultPort = getRandomPort(3000, 8999);
async function getPort(expectPort) {
    return external_get_port_default()({
        port: expectPort
    });
}
const createGetPortSyncFunctionString = (expectPort)=>`
(() => {
const net = require('net');

function getPort(expectPort) {
  return new Promise((resolve, reject) => {
    const server = net.createServer();
    server.unref();
    server.on('error', reject);
    server.listen(expectPort, () => {
      const { port } = server.address();
      server.close(() => {
        resolve(port);
      });
    });
  });
}

async function getAvailablePort(expectPort) {
  let port = expectPort;
  while (true) {
    try {
      const res = await getPort(port);
      return res;
    } catch (error) {
      port += Math.floor(Math.random() * 100 + 1);
    }
  }
}

getAvailablePort(${expectPort}).then(port => process.stdout.write(port.toString()));
})();
`.trim();
function getPortSync(expectPort) {
    const statement = '\n' === external_os_default().EOL ? createGetPortSyncFunctionString(expectPort) : createGetPortSyncFunctionString(expectPort).replace(/\n/g, '');
    const port = (0, external_child_process_namespaceObject.execSync)(`node -e "${statement}"`, {
        encoding: 'utf-8'
    });
    return Number(port);
}
function createApp() {
    return external_connect_default()();
}
async function createServer(port) {
    const app = createApp();
    const server = external_http_default().createServer(app);
    const res = {
        app,
        server,
        port,
        close () {
            return new Promise((resolve, reject)=>{
                if ('closeAllConnections' in server) server.closeAllConnections();
                if ('closeIdleConnections' in server) server.closeIdleConnections();
                server.close((err)=>{
                    if (err) reject(err);
                    resolve();
                });
            });
        }
    };
    return new Promise((resolve)=>{
        server.listen(port, ()=>{
            resolve(res);
        });
    });
}
exports.createApp = __webpack_exports__.createApp;
exports.createGetPortSyncFunctionString = __webpack_exports__.createGetPortSyncFunctionString;
exports.createServer = __webpack_exports__.createServer;
exports.defaultPort = __webpack_exports__.defaultPort;
exports.getPort = __webpack_exports__.getPort;
exports.getPortSync = __webpack_exports__.getPortSync;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "createApp",
    "createGetPortSyncFunctionString",
    "createServer",
    "defaultPort",
    "getPort",
    "getPortSync"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
