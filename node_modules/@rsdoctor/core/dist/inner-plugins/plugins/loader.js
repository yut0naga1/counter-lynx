"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    InternalLoaderPlugin: ()=>InternalLoaderPlugin
});
const types_namespaceObject = require("@rsdoctor/types");
const common_namespaceObject = require("@rsdoctor/utils/common");
const external_lodash_namespaceObject = require("lodash");
const index_js_namespaceObject = require("../utils/index.js");
const external_base_js_namespaceObject = require("./base.js");
const logger_namespaceObject = require("@rsdoctor/utils/logger");
class InternalLoaderPlugin extends external_base_js_namespaceObject.InternalBasePlugin {
    apply(compiler) {
        (0, logger_namespaceObject.time)('InternalLoaderPlugin.apply');
        try {
            compiler.hooks.afterPlugins.tap(this.tapPostOptions, this.afterPlugins.bind(this, compiler));
            compiler.hooks.compilation.tap(this.tapPreOptions, (compilation)=>this.compilation(compiler, compilation));
        } finally{
            (0, logger_namespaceObject.timeEnd)('InternalLoaderPlugin.apply');
        }
    }
    compilation(compiler, compilation) {
        (0, logger_namespaceObject.time)('InternalLoaderPlugin.compilation');
        try {
            if (compiler.isChild()) return;
            const wrapper = (callback)=>(loaderContext, module)=>{
                    const proxyLoaders = (null == module ? void 0 : module.loaders) || (null == loaderContext ? void 0 : loaderContext.loaders) || [];
                    const originLoaders = proxyLoaders.map((loader)=>{
                        const opts = loader.options || {};
                        if (opts[common_namespaceObject.Loader.LoaderInternalPropertyName]) return {
                            ...loader,
                            loader: opts[common_namespaceObject.Loader.LoaderInternalPropertyName].loader,
                            options: (0, external_lodash_namespaceObject.omit)(opts, common_namespaceObject.Loader.LoaderInternalPropertyName)
                        };
                        return loader;
                    });
                    const newLoaders = (0, external_lodash_namespaceObject.cloneDeep)(originLoaders);
                    if ('object' == typeof compiler.options.cache && 'version' in compiler.options.cache && 'string' == typeof compiler.options.cache.version && compiler.options.cache.version.indexOf('next/dist/build') > -1) callback(loaderContext, module || {});
                    else {
                        const proxyModule = new Proxy(module || {}, {
                            get (target, p, receiver) {
                                if ('loaders' === p) return newLoaders;
                                return Reflect.get(target, p, receiver);
                            },
                            set (target, p, newValue, receiver) {
                                const _newValue = (0, external_lodash_namespaceObject.cloneDeep)(newValue);
                                if ('loaders' === p) {
                                    if (Array.isArray(_newValue)) {
                                        newLoaders.length = 0;
                                        _newValue.forEach((e)=>{
                                            newLoaders.push(e);
                                        });
                                    }
                                }
                                return Reflect.set(target, p, _newValue, receiver);
                            },
                            deleteProperty (target, p) {
                                return Reflect.deleteProperty(target, p);
                            }
                        });
                        callback(loaderContext, proxyModule);
                    }
                    if (!(0, external_lodash_namespaceObject.isEqual)(originLoaders, newLoaders)) {
                        const rules = this.getInterceptRules(compiler, newLoaders.map((e)=>({
                                loader: e.loader,
                                options: e.options
                            })));
                        module.loaders = rules.map((e, i)=>({
                                ...newLoaders[i],
                                loader: e.loader,
                                options: e.options
                            }));
                    }
                };
            const interceptor = {
                register (tap) {
                    const originFn = tap.fn;
                    if ('function' == typeof originFn) tap.fn = wrapper(originFn);
                    return tap;
                }
            };
            compiler.webpack.NormalModule.getCompilationHooks(compilation).loader.intercept(interceptor);
        } finally{
            (0, logger_namespaceObject.timeEnd)('InternalLoaderPlugin.compilation');
        }
    }
    getInterceptRules(compiler, rules) {
        return (0, index_js_namespaceObject.interceptLoader)(rules, this.internalLoaderPath, {
            cwd: compiler.context || process.cwd(),
            host: this.sdk.server.origin,
            skipLoaders: this.options.loaderInterceptorOptions.skipLoaders
        }, this.sdk.root, 'resolveLoader' in compiler.options ? compiler.options.resolveLoader : {});
    }
    constructor(...args){
        super(...args), this.name = 'loader', this.internalLoaderPath = require.resolve('../loaders/proxy'), this.afterPlugins = (compiler)=>{
            (0, logger_namespaceObject.time)('InternalLoaderPlugin.afterPlugins');
            try {
                if (compiler.isChild()) return;
                compiler.options.module.rules = this.getInterceptRules(compiler, compiler.options.module.rules);
                this.sdk.addClientRoutes([
                    types_namespaceObject.Manifest.RsdoctorManifestClientRoutes.WebpackLoaders
                ]);
            } finally{
                (0, logger_namespaceObject.timeEnd)('InternalLoaderPlugin.afterPlugins');
            }
        };
    }
}
exports.InternalLoaderPlugin = __webpack_exports__.InternalLoaderPlugin;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "InternalLoaderPlugin"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
