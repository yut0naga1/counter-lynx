"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    UNASSIGNED: ()=>UNASSIGNED,
    collectSourceMaps: ()=>collectSourceMaps,
    bindContextCache: ()=>bindContextCache,
    handleAfterEmitAssets: ()=>handleAfterEmitAssets,
    handleEmitAssets: ()=>handleEmitAssets
});
const common_namespaceObject = require("@rsdoctor/utils/common");
const logger_namespaceObject = require("@rsdoctor/utils/logger");
const external_path_namespaceObject = require("path");
const external_source_map_namespaceObject = require("source-map");
const UNASSIGNED = '[unassigned]';
function bindContextCache(context, namespace, cache) {
    cache = cache || new Map();
    return (source, sourceMapFilenameRegex)=>{
        if (cache.has(source)) return cache.get(source);
        let resolved = UNASSIGNED;
        if (source.startsWith('file://')) resolved = (0, external_path_namespaceObject.resolve)(context, source.replace(/^file:\/\//, ''));
        else if (source.startsWith('webpack://')) {
            const match = source.match(sourceMapFilenameRegex);
            const filePath = null == match ? void 0 : match[1];
            const hasNamespace = namespace && source.startsWith(`webpack://${namespace}`) || namespace && source.startsWith(`file://${namespace}`);
            const baseDir = hasNamespace ? process.cwd() : context;
            resolved = filePath ? (0, external_path_namespaceObject.resolve)(baseDir, `./${filePath}`) : UNASSIGNED;
        } else resolved = (0, external_path_namespaceObject.resolve)(context, source);
        cache.set(source, resolved);
        return resolved;
    };
}
async function collectSourceMaps(map, assetLinesCodeList, _compilation, _this, sourceMapFilenameRegex, namespace) {
    if (map) {
        const consumer = await new external_source_map_namespaceObject.SourceMapConsumer(map);
        const getRealSourcePath = bindContextCache(_this.sdk._root || process.cwd(), namespace, _this._realSourcePathCache);
        const lineMappings = new Map();
        consumer.eachMapping((m)=>{
            if (!lineMappings.has(m.generatedLine)) lineMappings.set(m.generatedLine, []);
            lineMappings.get(m.generatedLine).push(m);
        });
        for (const [lineNum, mappings] of lineMappings.entries()){
            mappings.sort((a, b)=>a.generatedColumn - b.generatedColumn);
            const lineIdx = lineNum - 1;
            if (lineIdx < 0 || lineIdx >= assetLinesCodeList.length) continue;
            const line = assetLinesCodeList[lineIdx];
            for(let i = 0; i < mappings.length; i++){
                const m = mappings[i];
                if (!m.source) continue;
                let realSource = m.source.split('!').pop();
                if (((null == realSource ? void 0 : realSource.startsWith('webpack://')) || (null == realSource ? void 0 : realSource.startsWith('file://'))) && sourceMapFilenameRegex) realSource = getRealSourcePath(realSource, sourceMapFilenameRegex);
                if (!realSource) continue;
                const next = mappings[i + 1];
                const start = m.generatedColumn;
                const end = next ? next.generatedColumn : line.length;
                const codeSegment = line.slice(start, end);
                const prev = _this.sourceMapSets.get(realSource) || '';
                _this.sourceMapSets.set(realSource, prev.concat(codeSegment));
            }
        }
    }
}
async function handleAfterEmitAssets(compilation, _this, sourceMapFilenameRegex, namespace) {
    if ('rspack' in compilation.compiler) {
        _this.sourceMapSets = new Map();
        (0, logger_namespaceObject.time)('ensureModulesChunkGraph.afterEmit.start');
        const assets = [
            ...compilation.getAssets()
        ];
        for (const asset of assets){
            const { assetLinesCodeList, map: mapFromAsset } = parseAsset(asset, assets, 'js/css');
            let map = mapFromAsset;
            if (!map) {
                var _asset_info_related;
                let sourceMapFile = null == (_asset_info_related = asset.info.related) ? void 0 : _asset_info_related.sourceMap;
                let sourceMapFileAssetName = null == sourceMapFile ? void 0 : sourceMapFile.replace(/(\.[^.]+)(\.[^.]+)?$/, '$1');
                if (!sourceMapFile) continue;
                {
                    let sourceMapAsset = assets.find((asset)=>asset.name === sourceMapFile);
                    if (!sourceMapAsset && sourceMapFileAssetName) {
                        const baseNameWithoutHash = common_namespaceObject.Graph.formatAssetName(sourceMapFileAssetName, 'string' == typeof compilation.options.output.filename ? compilation.options.output.filename : void 0);
                        sourceMapAsset = assets.find((asset)=>{
                            const assetBaseName = common_namespaceObject.Graph.formatAssetName(asset.name, 'string' == typeof compilation.options.output.filename ? compilation.options.output.filename : void 0);
                            return assetBaseName.includes(baseNameWithoutHash) && asset.name.endsWith('.map');
                        });
                    }
                    if (sourceMapAsset) map = JSON.parse(sourceMapAsset.source.source().toString());
                }
            }
            try {
                await collectSourceMaps(map, assetLinesCodeList, compilation, _this, sourceMapFilenameRegex, namespace);
            } catch (e) {
                logger_namespaceObject.logger.debug(e);
            }
        }
        (0, logger_namespaceObject.timeEnd)('ensureModulesChunkGraph.afterEmit.start');
    }
}
async function handleEmitAssets(options) {
    const { compilation, pluginInstance, sourceMapFilenameRegex, namespace } = options;
    if (!('rspack' in compilation.compiler)) {
        pluginInstance.sourceMapSets = new Map();
        (0, logger_namespaceObject.time)('ensureModulesChunkGraph.afterEmit.start');
        const assets = Object.values(compilation.getAssets()).map((asset, index)=>({
                name: index.toString(),
                source: asset,
                info: asset.info || {}
            }));
        for (const asset of assets){
            const { assetLinesCodeList, map } = parseAsset(asset, assets, 'map');
            if (map) try {
                await collectSourceMaps(map, assetLinesCodeList, compilation, pluginInstance, sourceMapFilenameRegex, namespace);
            } catch (e) {
                logger_namespaceObject.logger.debug(e);
            }
        }
        (0, logger_namespaceObject.timeEnd)('ensureModulesChunkGraph.afterEmit.start');
    }
}
function parseAsset(asset, assets, type) {
    var _asset_source;
    const assetName = (null == (_asset_source = asset.source) ? void 0 : _asset_source.name) || asset.name;
    let assetContent = '';
    let assetLinesCodeList = [];
    let map = null;
    try {
        if ('map' === type && assetName.endsWith('.map') && !asset.name.includes('d.ts')) {
            var _asset_source_source_source, _asset_source_source, _asset_source1, _bundledAsset_source_source_source, _bundledAsset_source_source, _bundledAsset_source;
            assetContent = (null == (_asset_source1 = asset.source) ? void 0 : null == (_asset_source_source = _asset_source1.source) ? void 0 : null == (_asset_source_source_source = _asset_source_source.source) ? void 0 : _asset_source_source_source.call(_asset_source_source)) || '';
            if (!assetContent) {
                logger_namespaceObject.logger.debug(`Failed to get source content for asset: ${assetName}`);
                return {
                    assetName,
                    assetContent: '',
                    assetLinesCodeList: [],
                    map: null
                };
            }
            map = JSON.parse(assetContent);
            const bundledAsset = assets.find((asset2)=>{
                var _asset2_source;
                return (null == (_asset2_source = asset2.source) ? void 0 : _asset2_source.name) === map.file;
            });
            const bundledCode = (null == bundledAsset ? void 0 : null == (_bundledAsset_source = bundledAsset.source) ? void 0 : null == (_bundledAsset_source_source = _bundledAsset_source.source) ? void 0 : null == (_bundledAsset_source_source_source = _bundledAsset_source_source.source) ? void 0 : _bundledAsset_source_source_source.call(_bundledAsset_source_source)) || '';
            if (!bundledCode) {
                logger_namespaceObject.logger.debug(`Failed to get bundled code for asset: ${map.file}`);
                return {
                    assetName,
                    assetContent,
                    assetLinesCodeList: [],
                    map
                };
            }
            assetLinesCodeList = bundledCode.split(/\r?\n/);
        } else if ('js/css' === type && (assetName.endsWith('.js') || assetName.endsWith('.css'))) {
            var _asset_source_source1, _asset_source2, _asset_source_sourceAndMap, _asset_source_sourceAndMap1, _asset_source3;
            assetContent = (null == (_asset_source2 = asset.source) ? void 0 : null == (_asset_source_source1 = _asset_source2.source) ? void 0 : _asset_source_source1.call(_asset_source2)) || '';
            assetLinesCodeList = assetContent.split(/\r?\n/);
            map = (null == (_asset_source3 = asset.source) ? void 0 : null == (_asset_source_sourceAndMap1 = _asset_source3.sourceAndMap) ? void 0 : null == (_asset_source_sourceAndMap = _asset_source_sourceAndMap1.call(_asset_source3)) ? void 0 : _asset_source_sourceAndMap.map) || null;
        }
    } catch (error) {
        logger_namespaceObject.logger.debug(`Error parsing asset ${assetName}:`, error);
        return {
            assetName,
            assetContent: '',
            assetLinesCodeList: [],
            map: null
        };
    }
    return {
        assetName,
        assetContent,
        assetLinesCodeList,
        map
    };
}
exports.UNASSIGNED = __webpack_exports__.UNASSIGNED;
exports.bindContextCache = __webpack_exports__.bindContextCache;
exports.collectSourceMaps = __webpack_exports__.collectSourceMaps;
exports.handleAfterEmitAssets = __webpack_exports__.handleAfterEmitAssets;
exports.handleEmitAssets = __webpack_exports__.handleEmitAssets;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "UNASSIGNED",
    "bindContextCache",
    "collectSourceMaps",
    "handleAfterEmitAssets",
    "handleEmitAssets"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
