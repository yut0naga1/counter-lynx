"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    interceptLoader: ()=>interceptLoader,
    reportLoader: ()=>reportLoader,
    shouldSkipLoader: ()=>shouldSkipLoader,
    getOriginLoaderModule: ()=>getOriginLoaderModule,
    getInternalLoaderOptions: ()=>getInternalLoaderOptions,
    getLoaderOptionsWithoutInternalKeys: ()=>getLoaderOptionsWithoutInternalKeys
});
const external_axios_namespaceObject = require("axios");
var external_axios_default = /*#__PURE__*/ __webpack_require__.n(external_axios_namespaceObject);
const external_enhanced_resolve_namespaceObject = require("enhanced-resolve");
const external_fs_namespaceObject = require("fs");
var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_namespaceObject);
const external_lodash_namespaceObject = require("lodash");
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
const logger_namespaceObject = require("@rsdoctor/utils/logger");
const common_namespaceObject = require("@rsdoctor/utils/common");
const types_namespaceObject = require("@rsdoctor/types");
const error_namespaceObject = require("@rsdoctor/utils/error");
const external_sdk_js_namespaceObject = require("./sdk.js");
const external_circleDetect_js_namespaceObject = require("./circleDetect.js");
const index_js_namespaceObject = require("../../build-utils/build/index.js");
const utils_index_js_namespaceObject = require("../../build-utils/build/utils/index.js");
function getInternalLoaderOptions(loaderContext) {
    const options = loaderContext.getOptions();
    return options[common_namespaceObject.Loader.LoaderInternalPropertyName];
}
function getLoaderOptionsWithoutInternalKeys(loaderContext) {
    const options = loaderContext.getOptions();
    const circlePaths = [];
    const loaderOptions = (0, external_lodash_namespaceObject.omit)(options, [
        common_namespaceObject.Loader.LoaderInternalPropertyName
    ]);
    (0, external_circleDetect_js_namespaceObject.checkCirclePath)(loaderOptions, [], circlePaths, 0);
    if (circlePaths.length > 0) circlePaths.forEach((_path)=>{
        if ((null == _path ? void 0 : _path.length) > 0 && '[Circular]' !== loaderOptions[_path[0]]) loaderOptions[_path[0]] = '[Circular]';
    });
    return loaderOptions;
}
function getOriginLoaderModule(loaderContext) {
    const { loader, cwd } = getInternalLoaderOptions(loaderContext);
    return index_js_namespaceObject.Utils.loadLoaderModule(loader, cwd);
}
function shouldSkipLoader(loaderContext) {
    const { skipLoaders, cwd, loader } = getInternalLoaderOptions(loaderContext) || {};
    if (!loader) return true;
    if (Array.isArray(skipLoaders) && skipLoaders.length) {
        if (skipLoaders.includes(loader)) return true;
        const loaderName = index_js_namespaceObject.Utils.extractLoaderName(loader, cwd);
        if (skipLoaders.includes(loaderName)) return true;
    }
    return false;
}
function interceptLoader(rules, loaderPath, options, cwd = process.cwd(), resolveLoader) {
    const loaderResolver = external_enhanced_resolve_namespaceObject.create.sync({
        fileSystem: new external_enhanced_resolve_namespaceObject.CachedInputFileSystem(external_fs_default(), 4000),
        conditionNames: [
            'loader',
            'require',
            'node'
        ],
        exportsFields: [
            'exports'
        ],
        mainFiles: [
            'index'
        ],
        mainFields: [
            'loader',
            'main'
        ],
        extensions: [
            'js',
            '.json'
        ],
        modules: [
            'node_modules'
        ],
        ...resolveLoader
    });
    const resolve = (target)=>{
        try {
            const result = loaderResolver({}, cwd, target);
            if ('string' == typeof result) return result;
        } catch (e) {}
        return target;
    };
    return index_js_namespaceObject.Utils.mapEachRules(rules, (rule)=>{
        var _rule_loader, _rule_loader1;
        if ((null == (_rule_loader = rule.loader) ? void 0 : _rule_loader.startsWith('builtin:')) || (null == (_rule_loader1 = rule.loader) ? void 0 : _rule_loader1.endsWith('.mjs')) || (0, utils_index_js_namespaceObject.isESMLoader)(rule)) return rule;
        const opts = {
            ...'options' in rule ? 'string' == typeof rule.options ? JSON.parse(rule.options) : rule.options : {}
        };
        opts[common_namespaceObject.Loader.LoaderInternalPropertyName] = rule.loader && /proxy.js/.test(rule.loader) && 'options' in rule && 'object' == typeof rule.options ? rule.options[common_namespaceObject.Loader.LoaderInternalPropertyName] : {
            ...options,
            hasOptions: 'options' in rule && Boolean(rule.options),
            loader: 'loader' in rule ? resolve(rule.loader) : ''
        };
        return {
            ...rule,
            loader: loaderPath,
            options: opts
        };
    });
}
async function reportLoader(ctx, start, startHRTime, isPitch, sync, code, err, res, sourceMap) {
    var _ctx__module, _ctx__module1, _ctx__compilation;
    const end = common_namespaceObject.Time.getCurrentTimestamp(start, startHRTime);
    const { loader, host } = getInternalLoaderOptions(ctx);
    const loaderData = [
        {
            resource: {
                path: (null == (_ctx__module = ctx._module) ? void 0 : _ctx__module.layer) ? `${ctx.resourcePath}[${ctx._module.layer}]` : ctx.resourcePath,
                query: (0, utils_index_js_namespaceObject.parseQuery)(ctx.resourceQuery || '?'),
                queryRaw: ctx.resourceQuery,
                ext: external_path_default().extname(ctx.resourcePath).slice(1),
                ...(null == (_ctx__module1 = ctx._module) ? void 0 : _ctx__module1.layer) ? {
                    layer: ctx._module.layer
                } : {}
            },
            loaders: [
                {
                    loader: index_js_namespaceObject.Utils.extractLoaderName(loader),
                    loaderIndex: ctx.loaderIndex,
                    path: loader,
                    input: code,
                    result: 'string' == typeof res || Buffer.isBuffer(res) ? res.toString() : res,
                    startAt: start,
                    endAt: end,
                    options: getLoaderOptionsWithoutInternalKeys(ctx),
                    isPitch,
                    sync,
                    errors: err ? [
                        new error_namespaceObject.DevToolError(code, err.message, {
                            controller: {
                                noStack: false,
                                noColor: true
                            },
                            stack: err.stack
                        })
                    ] : [],
                    pid: process.pid,
                    ppid: process.ppid
                }
            ]
        }
    ];
    const data = sourceMap ? common_namespaceObject.Lodash.isString(sourceMap) ? JSON.parse(sourceMap) : sourceMap : {};
    const sourceMapData = {
        version: data.version ?? -1,
        sources: data.sources ?? [],
        names: data.names ?? [],
        sourceRoot: data.sourceRoot,
        sourcesContent: data.sourcesContent,
        mappings: data.mappings,
        file: loaderData[0].resource.path
    };
    const sdk = (0, external_sdk_js_namespaceObject.getSDK)(null == (_ctx__compilation = ctx._compilation) ? void 0 : _ctx__compilation.name);
    if ((null == sdk ? void 0 : sdk.reportLoader) && !('parent' in sdk && sdk.parent)) {
        sdk.reportLoader(loaderData);
        sdk.reportSourceMap(sourceMapData);
        return loaderData;
    }
    await Promise.all([
        external_axios_default().post(`${host}${types_namespaceObject.SDK.ServerAPI.API.ReportLoader}`, loaderData, {
            timeout: 8888
        }).catch((err)=>{
            logger_namespaceObject.logger.debug(`${err.message}`, '[WebpackPlugin.ReportLoader][error]');
        }),
        external_axios_default().post(`${host}${types_namespaceObject.SDK.ServerAPI.API.ReportSourceMap}`, sourceMapData, {
            timeout: 8888
        }).catch((err)=>{
            logger_namespaceObject.logger.debug(`${err.message}`, '[WebpackPlugin.ReportSourceMap][error]');
        })
    ]);
    return loaderData;
}
exports.getInternalLoaderOptions = __webpack_exports__.getInternalLoaderOptions;
exports.getLoaderOptionsWithoutInternalKeys = __webpack_exports__.getLoaderOptionsWithoutInternalKeys;
exports.getOriginLoaderModule = __webpack_exports__.getOriginLoaderModule;
exports.interceptLoader = __webpack_exports__.interceptLoader;
exports.reportLoader = __webpack_exports__.reportLoader;
exports.shouldSkipLoader = __webpack_exports__.shouldSkipLoader;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "getInternalLoaderOptions",
    "getLoaderOptionsWithoutInternalKeys",
    "getOriginLoaderModule",
    "interceptLoader",
    "reportLoader",
    "shouldSkipLoader"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
