"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    chunkTransform: ()=>chunkTransform
});
const graph_namespaceObject = require("@rsdoctor/graph");
const FILTER_ASSETS_TYPE = 'assets by status';
function chunkTransform(assetMap, bundleStats) {
    var _bundleStats_chunks, _bundleStats_assets;
    const chunkGraph = new graph_namespaceObject.ChunkGraph();
    null == (_bundleStats_chunks = bundleStats.chunks) || _bundleStats_chunks.forEach((_chunk)=>{
        var _chunk_names, _chunk_files;
        const parsedSize = 0;
        const chunk = new graph_namespaceObject.Chunk(String(_chunk.id), (null == (_chunk_names = _chunk.names) ? void 0 : _chunk_names.join('')) || (null == (_chunk_files = _chunk.files) ? void 0 : _chunk_files.join('| ')) || '', _chunk.size, _chunk.initial, _chunk.entry);
        chunk.setParsedSize(parsedSize);
        chunkGraph.addChunk(chunk);
    });
    null == (_bundleStats_assets = bundleStats.assets) || _bundleStats_assets.forEach((_asset)=>{
        var _asset_chunks;
        if (_asset.type === FILTER_ASSETS_TYPE) return;
        const chunks = (null == (_asset_chunks = _asset.chunks) ? void 0 : _asset_chunks.map((ck)=>{
            const chunk = chunkGraph.getChunkById(String(ck));
            return chunk;
        }).filter((chunk)=>!!chunk)) || [];
        const { content = '' } = assetMap.get(_asset.name) || {};
        const asset = new graph_namespaceObject.Asset(_asset.name, _asset.size, chunks, content);
        chunks.forEach((chunk)=>null == chunk ? void 0 : chunk.addAsset(asset));
        chunkGraph.addAsset(asset);
    });
    if (bundleStats.entrypoints) for (const [key, _entrypoint] of Object.entries(bundleStats.entrypoints)){
        var _entrypoint_chunks, _entrypoint_assets;
        const entrypoint = new graph_namespaceObject.EntryPoint(_entrypoint.name || key);
        null == (_entrypoint_chunks = _entrypoint.chunks) || _entrypoint_chunks.forEach((chunkId)=>{
            const ck = chunkGraph.getChunkById(`${chunkId}`);
            if (ck) entrypoint.addChunk(ck);
        });
        null == (_entrypoint_assets = _entrypoint.assets) || _entrypoint_assets.forEach((_asset)=>{
            const asset = chunkGraph.getAssetByPath(_asset.name);
            if (asset) entrypoint.addAsset(asset);
        });
        chunkGraph.addEntryPoint(entrypoint);
    }
    return chunkGraph;
}
exports.chunkTransform = __webpack_exports__.chunkTransform;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "chunkTransform"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
