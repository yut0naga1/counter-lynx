"use strict";
var __webpack_modules__ = {
    "node:zlib?70ed": function(module) {
        module.exports = require("node:zlib");
    },
    "node:zlib?768f": function(module) {
        module.exports = import("node:zlib").then(function(module) {
            return module;
        });
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
(()=>{
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        getAssetsModulesData: ()=>getAssetsModulesData,
        transformAssetsModulesData: ()=>transformAssetsModulesData
    });
    const external_path_namespaceObject = require("path");
    var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
    const logger_namespaceObject = require("@rsdoctor/utils/logger");
    const common_namespaceObject = require("@rsdoctor/utils/common");
    async function getAssetsModulesData(moduleGraph, chunkGraph, bundleDir, opts, sourceMapSets = new Map()) {
        if (opts.parseBundle && sourceMapSets.size < 1) {
            (0, logger_namespaceObject.time)("Start Parse bundle by AST.");
            const { parseBundle = ()=>({}) } = opts || {};
            const assets = chunkGraph.getAssets();
            const modules = moduleGraph.getModules();
            let bundlesSources = null;
            let parsedModules = null;
            if (bundleDir && assets.length) {
                bundlesSources = {};
                parsedModules = {};
                for (const asset of assets){
                    const assetFile = external_path_default().join(bundleDir, asset.path);
                    let bundleInfo;
                    try {
                        bundleInfo = parseBundle(assetFile, modules);
                    } catch (err) {
                        const { code = '', message } = err;
                        const msg = 'ENOENT' === code ? 'no such file' : message;
                        '1' === process.env.DEVTOOLS_NODE_DEV && logger_namespaceObject.logger.warn(`Error parsing bundle asset "${assetFile}": ${msg}`);
                        continue;
                    }
                    bundlesSources[asset.path] = common_namespaceObject.Lodash.pick(bundleInfo, [
                        'src',
                        'runtimeSrc'
                    ]);
                    Object.assign(parsedModules, (null == bundleInfo ? void 0 : bundleInfo.modules) || {});
                }
                if (common_namespaceObject.Lodash.isEmpty(bundlesSources)) {
                    bundlesSources = null;
                    parsedModules = null;
                    process.env.DEVTOOLS_DEV && logger_namespaceObject.logger.warn('\nNo bundles were parsed. Analyzer will show only original module sizes from stats file.\n');
                }
                if (parsedModules) transformAssetsModulesData(parsedModules, moduleGraph);
            }
            (0, logger_namespaceObject.timeEnd)("Start Parse bundle by AST.");
        } else {
            (0, logger_namespaceObject.time)("Start Parse bundle by sourcemap.");
            for (const [modulePath, codes] of sourceMapSets.entries()){
                const module = moduleGraph.getModuleByFile(modulePath);
                if (!module) continue;
                let gzipSize;
                try {
                    if (codes && 'string' == typeof codes && codes.length > 0) {
                        const { gzipSync } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "node:zlib?768f"));
                        gzipSize = gzipSync(codes, {
                            level: 9
                        }).length;
                    }
                } catch  {}
                null == module || module.setSize({
                    parsedSize: codes.length,
                    gzipSize
                });
                null == module || module.setSource({
                    parsedSource: codes
                });
            }
            (0, logger_namespaceObject.timeEnd)("Start Parse bundle by sourcemap.");
        }
    }
    function transformAssetsModulesData(parsedModulesData, moduleGraph) {
        if (!moduleGraph) return;
        Object.entries(parsedModulesData).forEach(([moduleId, parsedData])=>{
            const module = moduleGraph.getModuleByWebpackId(moduleId ?? '');
            let gzipSize;
            try {
                if ((null == parsedData ? void 0 : parsedData.content) && 'string' == typeof parsedData.content && parsedData.content.length > 0) {
                    const { gzipSync } = __webpack_require__("node:zlib?70ed");
                    gzipSize = gzipSync(parsedData.content, {
                        level: 9
                    }).length;
                }
            } catch  {}
            null == module || module.setSize({
                parsedSize: null == parsedData ? void 0 : parsedData.size,
                gzipSize
            });
            null == module || module.setSource({
                parsedSource: (null == parsedData ? void 0 : parsedData.content) || ''
            });
        });
    }
})();
exports.getAssetsModulesData = __webpack_exports__.getAssetsModulesData;
exports.transformAssetsModulesData = __webpack_exports__.transformAssetsModulesData;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "getAssetsModulesData",
    "transformAssetsModulesData"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
