"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    getModuleGraphByStats: ()=>getModuleGraphByStats,
    getModulesFromArray: ()=>getModulesFromArray
});
const types_namespaceObject = require("@rsdoctor/types");
const external_path_browserify_namespaceObject = require("path-browserify");
var external_path_browserify_default = /*#__PURE__*/ __webpack_require__.n(external_path_browserify_namespaceObject);
const graph_namespaceObject = require("@rsdoctor/graph");
const external_utils_js_namespaceObject = require("./utils.js");
const external_compatible_js_namespaceObject = require("./compatible.js");
function getCanSkip(data) {
    var _data_name;
    if (!data.identifier || !((null == data ? void 0 : data.nameForCondition) || data.name) || data.identifier.startsWith('webpack/runtime') || (null == data ? void 0 : null == (_data_name = data.name) ? void 0 : _data_name.startsWith('(webpack)'))) return true;
}
function getGetModuleName(root, data) {
    if (data.nameForCondition) return data.nameForCondition.replace('\x00', '');
    const name = data.name.replace(/ ?\+ ?\d+ ?modules$/, '');
    return external_path_browserify_default().isAbsolute(name) ? name : external_path_browserify_default().join(root, name);
}
function getModuleFromChildren(module, collectedModules) {
    if ('module' === module.type || void 0 === module.type) collectedModules.push(module);
    else if ('children' in module && module.children) getModulesFromArray(module.children, collectedModules);
}
function getModulesFromArray(modules, collectedModules) {
    modules.forEach((module)=>{
        getModuleFromChildren(module, collectedModules);
    });
}
function getModulesFromChunks(chunks, collectedModules) {
    null == chunks || chunks.forEach((chunk)=>{
        var _chunk_modules;
        if (null == (_chunk_modules = chunk.modules) ? void 0 : _chunk_modules.length) collectedModules.push(...chunk.modules);
    });
}
function getModuleGraphByStats({ modules, chunks }, root, chunkGraph) {
    graph_namespaceObject.ModuleGraph.init();
    const moduleGraph = new graph_namespaceObject.ModuleGraph();
    const allModules = [];
    const collectedModules = [];
    getModulesFromArray(modules ?? [], collectedModules);
    getModulesFromChunks(chunks ?? [], collectedModules);
    for (const data of collectedModules ?? []){
        var _data_chunks;
        if (getCanSkip(data)) continue;
        if (moduleGraph.getModuleByWebpackId(data.identifier)) continue;
        allModules.push(data);
        const isConcatenated = Boolean(data.modules && data.modules.length > 0);
        const concatenatedModule = new graph_namespaceObject.Module(data.identifier, getGetModuleName(root, data), 0 === data.depth, isConcatenated ? types_namespaceObject.SDK.ModuleKind.Concatenation : types_namespaceObject.SDK.ModuleKind.Normal, data.id ? String(data.id) : void 0, data.layer);
        if (data.optimizationBailout) data.optimizationBailout.forEach((reason)=>concatenatedModule.addBailoutReason(reason));
        if (data.issuerPath) concatenatedModule.addIssuerPath(data.issuerPath);
        null == (_data_chunks = data.chunks) || _data_chunks.forEach((_chunkId)=>{
            const chunk = chunkGraph.getChunkById(String(_chunkId));
            chunk && concatenatedModule.addChunk(chunk);
        });
        moduleGraph.addModule(concatenatedModule);
        if (data.source) concatenatedModule.setSource({
            transformed: Buffer.isBuffer(data.source) ? data.source.toString() : data.source
        });
        if ('number' == typeof data.size) concatenatedModule.setSize({
            sourceSize: data.size,
            transformedSize: data.size
        });
        for (const normal of data.modules ?? []){
            var _normal_chunks;
            if (getCanSkip(normal)) continue;
            allModules.push(normal);
            const webpackId = normal.identifier;
            const registeredModule = moduleGraph.getModuleByWebpackId(webpackId);
            let normalModule;
            normalModule = registeredModule ? registeredModule : moduleGraph.getModuleByWebpackId(webpackId) ?? new graph_namespaceObject.Module(webpackId, getGetModuleName(root, normal), 0 === normal.depth, types_namespaceObject.SDK.ModuleKind.Normal, normal.id ? String(normal.id) : void 0, normal.layer);
            if (normal.optimizationBailout) normal.optimizationBailout.forEach((reason)=>normalModule.addBailoutReason(reason));
            if (normal.issuerPath) normalModule.addIssuerPath(normal.issuerPath);
            if (null == (_normal_chunks = normal.chunks) ? void 0 : _normal_chunks.length) {
                var _normal_chunks1;
                null == (_normal_chunks1 = normal.chunks) || _normal_chunks1.forEach((_chunkId)=>{
                    const chunk = chunkGraph.getChunkById(String(_chunkId));
                    chunk && normalModule.addChunk(chunk);
                });
            } else {
                var _data_chunks1;
                null == (_data_chunks1 = data.chunks) || _data_chunks1.forEach((_chunkId)=>{
                    const chunk = chunkGraph.getChunkById(String(_chunkId));
                    chunk && normalModule.addChunk(chunk);
                });
            }
            if (normal.source) normalModule.setSource({
                transformed: Buffer.isBuffer(normal.source) ? normal.source.toString() : normal.source
            });
            if ('number' == typeof normal.size) normalModule.setSize({
                sourceSize: normal.size,
                transformedSize: normal.size
            });
            moduleGraph.addModule(normalModule);
            concatenatedModule.addNormalModule(normalModule);
        }
    }
    for (const module of allModules){
        const currentModule = moduleGraph.getModuleByWebpackId(module.identifier ?? '');
        if (!currentModule) continue;
        const dependencies = (module.reasons ?? []).filter(external_utils_js_namespaceObject.isImportDependency).filter((item)=>Boolean(item.moduleIdentifier && item.userRequest));
        (module.reasons ?? []).filter((item)=>'from origin' === item.type).forEach((dep)=>{
            var _dep_children;
            return null == dep ? void 0 : null == (_dep_children = dep.children) ? void 0 : _dep_children.forEach((_d)=>dependencies.push({
                    ...dep,
                    ..._d,
                    children: void 0
                }));
        });
        for (const dep of dependencies){
            const rawRequest = dep.userRequest;
            const requestModule = moduleGraph.getModuleByWebpackId(dep.moduleIdentifier);
            if (!requestModule) continue;
            if (!requestModule.getDependencyByRequest(rawRequest)) {
                const data = requestModule.addDependency(rawRequest, currentModule, (0, external_utils_js_namespaceObject.getImportKind)(dep));
                if (data) moduleGraph.addDependency(data);
            }
            const dependency = requestModule.getDependencyByRequest(rawRequest);
            if (dependency && (null == dep ? void 0 : dep.loc)) {
                const position = (0, external_compatible_js_namespaceObject.getPositionByStatsLocation)(dep.loc);
                if (position) dependency.addStatement(new graph_namespaceObject.Statement(requestModule, {
                    transformed: position
                }));
            }
        }
    }
    const moduleCache = new Map();
    moduleGraph.getModules().forEach((module)=>{
        if (module.issuerPath) module.issuerPath.forEach((issuer)=>{
            let moduleInstance = moduleCache.get(issuer.identifier);
            if (!moduleInstance) {
                moduleInstance = moduleGraph.getModuleByWebpackId(issuer.identifier);
                if (moduleInstance) moduleCache.set(issuer.identifier, moduleInstance);
            }
            if (moduleInstance) issuer.moduleId = moduleInstance.id;
        });
    });
    return moduleGraph;
}
exports.getModuleGraphByStats = __webpack_exports__.getModuleGraphByStats;
exports.getModulesFromArray = __webpack_exports__.getModulesFromArray;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "getModuleGraphByStats",
    "getModulesFromArray"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
