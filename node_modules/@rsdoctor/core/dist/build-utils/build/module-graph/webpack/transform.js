"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    appendModuleGraphByCompilation: ()=>appendModuleGraphByCompilation,
    getModuleExportsType: ()=>getModuleExportsType
});
const build_namespaceObject = require("@rsdoctor/utils/build");
const compatible_js_namespaceObject = require("../../../common/webpack/compatible.js");
const index_js_namespaceObject = require("../../../common/module-graph/index.js");
const external_parser_js_namespaceObject = require("../parser.js");
const external_lodash_namespaceObject = require("lodash");
async function readFile(target, wbFs) {
    var _wbFs_fs;
    if (null == wbFs ? void 0 : null == (_wbFs_fs = wbFs.fs) ? void 0 : _wbFs_fs.readFile) {
        const result = new Promise((resolve, reject)=>{
            wbFs.fs.readFile(target, (err, content)=>{
                if (err) return void reject(err);
                content ? resolve(Buffer.from(content)) : resolve();
            });
        }).catch(()=>{});
        if (result) return result;
    }
    return build_namespaceObject.File.fse.readFile(target).catch(()=>{});
}
function getModuleExportsType(module, moduleGraph, strict = false) {
    if (moduleGraph && 'getExportsType' in module) return module.getExportsType(moduleGraph, strict);
    return strict ? 'default-with-named' : 'dynamic';
}
function appendDependency(webpackDep, module, webpackGraph, graph) {
    const resolvedWebpackModule = (null == webpackGraph ? void 0 : webpackGraph.getResolvedModule) ? webpackGraph.getResolvedModule(webpackDep) : void 0;
    if (!resolvedWebpackModule) return;
    const rawRequest = (0, compatible_js_namespaceObject.getWebpackDependencyRequest)(webpackDep, resolvedWebpackModule);
    const resolveRequest = (0, compatible_js_namespaceObject.getWebpackModulePath)(resolvedWebpackModule);
    const request = rawRequest ?? resolveRequest;
    if (!module.getDependencyByRequest(request)) {
        const depModule = graph.getModuleByFile(resolveRequest);
        if (depModule) {
            const dep = module.addDependency(request, depModule, (0, index_js_namespaceObject.getImportKind)(webpackDep));
            if (dep) graph.addDependency(dep);
        }
    }
    const dependency = module.getDependencyByRequest(request);
    if (dependency) {
        dependency.setBuildMeta({
            exportsType: getModuleExportsType(resolvedWebpackModule, webpackGraph, module.meta.strictHarmonyModule)
        });
        const statement = (0, compatible_js_namespaceObject.getDependencyPosition)(webpackDep, module, false);
        if (statement) dependency.addStatement(statement);
        dependency.statements.forEach((state)=>{
            state.position.source = state.module.getSourceRange(state.position.transformed);
        });
    }
}
function getModuleSource(modulePath, wbFs, sourceMap) {
    if (sourceMap) try {
        const contentFromSourceMap = sourceMap.sourceContentFor(modulePath);
        if (contentFromSourceMap) return Buffer.from(contentFromSourceMap);
    } catch (e) {}
    return readFile(modulePath, wbFs);
}
async function appendModuleData(origin, webpackGraph, graph, wbFs, features, context) {
    const module = graph.getModuleByWebpackId((0, compatible_js_namespaceObject.getWebpackModuleId)(origin));
    if (!origin || !module) return;
    const { getSourceMap, astCache, packagePathMap } = context ?? {};
    try {
        var _origin_originalSource_source, _origin_originalSource, _origin_buildMeta;
        const sourceMap = await (null == getSourceMap ? void 0 : getSourceMap(module.path));
        const source = await getModuleSource(module.path, wbFs, sourceMap) ?? Buffer.from('');
        if (sourceMap) module.setSourceMap(sourceMap);
        if (null == astCache ? void 0 : astCache.has(origin)) {
            const program = astCache.get(origin);
            module.setProgram(program);
            module.meta.hasSetEsModuleStatement = (0, external_parser_js_namespaceObject.hasSetEsModuleStatement)(program);
        }
        const transformed = (0, compatible_js_namespaceObject.isExternalModule)(origin) ? '' : module.getSource().transformed.length > 0 ? module.getSource().transformed : (0, external_lodash_namespaceObject.isFunction)(null == origin ? void 0 : origin.originalSource) ? (null == (_origin_originalSource = origin.originalSource()) ? void 0 : null == (_origin_originalSource_source = _origin_originalSource.source()) ? void 0 : _origin_originalSource_source.toString()) ?? '' : '';
        const transformedSize = (0, compatible_js_namespaceObject.isExternalModule)(origin) ? 0 : module.getSize().transformedSize > 0 ? module.getSize().transformedSize : Buffer.from(transformed).byteLength;
        module.setSource({
            transformed,
            source: source.toString()
        });
        module.setSize({
            transformedSize,
            sourceSize: source.byteLength
        });
        let packageData;
        if (packagePathMap && origin.resourceResolveData) {
            let { descriptionFileRoot: root } = origin.resourceResolveData;
            const { descriptionFileData: data } = origin.resourceResolveData;
            if (root && data.name && data.version) {
                if (packagePathMap.has(root)) root = packagePathMap.get(root);
                else {
                    const realpath = await build_namespaceObject.File.fse.realpath(root);
                    root = realpath;
                    packagePathMap.set(root, realpath);
                }
                packageData = {
                    ...origin.resourceResolveData.descriptionFileData,
                    root
                };
            }
        }
        module.meta.strictHarmonyModule = (null == (_origin_buildMeta = origin.buildMeta) ? void 0 : _origin_buildMeta.strictHarmonyModule) ?? false;
        module.meta.packageData = packageData;
        if (!(null == features ? void 0 : features.lite) && (null == origin ? void 0 : origin.dependencies)) Array.from(origin.dependencies).filter((item)=>(0, index_js_namespaceObject.isImportDependency)(item)).concat(origin.blocks.reduce((ans, item)=>ans.concat(item.dependencies), [])).forEach((dep)=>appendDependency(dep, module, webpackGraph, graph));
    } catch (e) {
        console.error(`module ${module.path} transform has error:`, e);
    }
}
async function appendModuleGraphByCompilation(compilation, graph, features, context) {
    try {
        const webpackCompilation = compilation;
        const { moduleGraph: webpackGraph, fileSystemInfo } = webpackCompilation;
        const allModules = (0, compatible_js_namespaceObject.getAllModules)(webpackCompilation);
        await Promise.all(allModules.map((module)=>appendModuleData(module, webpackGraph, graph, fileSystemInfo, features, context)));
        (0, index_js_namespaceObject.removeNoImportStyle)(graph);
        return graph;
    } catch (e) {
        return graph;
    }
}
exports.appendModuleGraphByCompilation = __webpack_exports__.appendModuleGraphByCompilation;
exports.getModuleExportsType = __webpack_exports__.getModuleExportsType;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "appendModuleGraphByCompilation",
    "getModuleExportsType"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
