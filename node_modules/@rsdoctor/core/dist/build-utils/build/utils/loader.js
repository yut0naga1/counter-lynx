"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    extractLoaderName: ()=>extractLoaderName,
    addProbeLoader2Rules: ()=>addProbeLoader2Rules,
    isESMLoader: ()=>isESMLoader,
    getLoaderNameMatch: ()=>getLoaderNameMatch,
    parseQuery: ()=>parseQuery,
    createLoaderContextTrap: ()=>createLoaderContextTrap,
    loadLoaderModule: ()=>loadLoaderModule,
    mapEachRules: ()=>mapEachRules,
    parsePathQueryFragment: ()=>parsePathQueryFragment
});
const external_node_path_namespaceObject = require("node:path");
var external_node_path_default = /*#__PURE__*/ __webpack_require__.n(external_node_path_namespaceObject);
const external_fs_extra_namespaceObject = require("fs-extra");
var external_fs_extra_default = /*#__PURE__*/ __webpack_require__.n(external_fs_extra_namespaceObject);
const external_lodash_namespaceObject = require("lodash");
const common_namespaceObject = require("@rsdoctor/utils/common");
const graph_namespaceObject = require("@rsdoctor/graph");
const logger_namespaceObject = require("@rsdoctor/utils/logger");
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
    const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
    return {
        path: (null == match ? void 0 : match[1].replace(/\0(.)/g, '$1')) || '',
        query: (null == match ? void 0 : match[2]) ? match[2].replace(/\0(.)/g, '$1') : '',
        fragment: (null == match ? void 0 : match[3]) || ''
    };
}
function loadLoaderModule(loaderPath, cwd = process.cwd()) {
    var _mod_default, _mod_default1;
    const cleanLoaderPath = parsePathQueryFragment(loaderPath).path;
    const mod = require(process.env.DOCTOR_TEST ? external_node_path_default().resolve(cwd, cleanLoaderPath) : require.resolve(cleanLoaderPath, {
        paths: [
            cwd,
            external_node_path_default().resolve(cwd, 'node_modules')
        ]
    }));
    const isESM = mod.__esModule && 'function' == typeof mod.default;
    return {
        default: isESM ? mod.default : 'function' == typeof mod ? mod : null,
        pitch: (null == (_mod_default = mod.default) ? void 0 : _mod_default.pitch) || mod.pitch,
        raw: (null == (_mod_default1 = mod.default) ? void 0 : _mod_default1.raw) || mod.raw || false
    };
}
function extractLoaderName(loaderPath, cwd = '') {
    let res = loaderPath.replace(cwd, '');
    if (!external_node_path_default().isAbsolute(res)) return res;
    const nms = '/node_modules/';
    const idx = res.lastIndexOf(nms);
    if (-1 !== idx) {
        res = res.slice(idx + nms.length);
        const ln = 'loader';
        const lnIdx = res.lastIndexOf(ln);
        if (lnIdx > -1) res = res.slice(0, lnIdx + ln.length);
    }
    return res;
}
function mapEachRules(rules, callback) {
    return rules.filter(Boolean).map((rule)=>{
        if ('string' == typeof rule) return callback({
            loader: rule
        });
        if (rule.loader && 'string' == typeof rule.loader) return callback(rule);
        if (Array.isArray(rule.loaders)) {
            const { loaders, ...rest } = rule;
            return {
                ...rest,
                use: mapEachRules(loaders, callback)
            };
        }
        if (rule.use && (!Array.isArray(rule.use) || 0 !== rule.use.length)) {
            if ('string' == typeof rule.use) return {
                ...rule,
                use: mapEachRules([
                    {
                        loader: rule.use,
                        options: rule.options
                    }
                ], callback)
            };
            if ('function' == typeof rule.use) {
                const funcUse = rule.use;
                const newRule = {
                    ...rule,
                    use: (...args)=>{
                        const rules = funcUse.apply(null, args);
                        return mapEachRules(rules, callback);
                    }
                };
                return newRule;
            }
            if (Array.isArray(rule.use)) return {
                ...rule,
                use: mapEachRules(rule.use, callback)
            };
            return {
                ...rule,
                use: mapEachRules([
                    rule.use
                ], callback)
            };
        }
        if ('rules' in rule && Array.isArray(rule.rules)) return {
            ...rule,
            rules: mapEachRules(rule.rules, callback)
        };
        if (Array.isArray(rule.oneOf)) return {
            ...rule,
            oneOf: mapEachRules(rule.oneOf, callback)
        };
        return rule;
    });
}
function isESMLoader(r) {
    let _loaderName = 'object' == typeof r && 'string' == typeof (null == r ? void 0 : r.loader) ? r.loader : 'string' == typeof r ? r : '';
    if (!_loaderName) return false;
    const isPath = external_node_path_default().isAbsolute(_loaderName) || _loaderName.startsWith('./') || _loaderName.startsWith('../');
    if (isPath) {
        const packageJsonData = (0, graph_namespaceObject.readPackageJson)(_loaderName, (file)=>{
            try {
                return external_fs_extra_default().readJsonSync(file, {
                    encoding: 'utf8'
                });
            } catch (e) {
                logger_namespaceObject.logger.debug(`isESMLoader function error\u{FF1A}${e}`);
            }
        });
        if ((null == packageJsonData ? void 0 : packageJsonData.type) === 'module') return true;
    }
    return false;
}
function appendProbeLoaders(compiler, loaderConfig) {
    const _options = 'object' == typeof loaderConfig ? 'string' == typeof loaderConfig.options ? {
        options: loaderConfig.options
    } : loaderConfig.options : {};
    const loaderPath = external_node_path_default().join(__dirname, '../loader/probeLoader.js');
    const loader = 'string' == typeof loaderConfig ? loaderConfig : 'object' == typeof loaderConfig && loaderConfig.loader;
    const createProbeLoader = (type)=>({
            loader: loaderPath,
            options: {
                ..._options,
                loader,
                ident: void 0,
                type,
                builderName: compiler.options.name
            }
        });
    return [
        createProbeLoader('end'),
        loaderConfig,
        createProbeLoader('start')
    ];
}
function getLoaderNameMatch(r, loaderName, strict = true) {
    if (!strict) return 'object' == typeof r && 'string' == typeof (null == r ? void 0 : r.loader) && r.loader.includes(loaderName) || 'string' == typeof r && r.includes(loaderName);
    return 'object' == typeof r && 'string' == typeof (null == r ? void 0 : r.loader) && r.loader === loaderName || 'string' == typeof r && r === loaderName;
}
function addProbeLoader2Rules(rules, compiler, fn) {
    return rules.map((rule)=>{
        if (!rule || 'string' == typeof rule) return rule;
        if (fn(rule) && !rule.use) {
            const loaderConfig = {
                loader: rule.loader ?? '',
                options: rule.options,
                ident: 'ident' in rule && 'string' == typeof rule.ident ? rule.ident : void 0
            };
            return {
                ...rule,
                use: appendProbeLoaders(compiler, loaderConfig),
                loader: void 0,
                options: void 0
            };
        }
        if (rule.use) {
            if (Array.isArray(rule.use)) rule.use = rule.use.flatMap((loaderConfig)=>{
                if ('string' == typeof loaderConfig || 'object' == typeof loaderConfig && loaderConfig && 'loader' in loaderConfig) return fn(loaderConfig) ? appendProbeLoaders(compiler, loaderConfig) : [
                    loaderConfig
                ];
                return [
                    loaderConfig
                ];
            });
            else if ('object' != typeof rule.use || Array.isArray(rule.use) || 'function' == typeof rule.use) {
                if ('string' == typeof rule.use) rule.use = fn(rule.use) ? appendProbeLoaders(compiler, {
                    loader: rule.use
                }) : [
                    {
                        loader: rule.use
                    }
                ];
            } else if ('loader' in rule.use) rule.use = fn(rule.use) ? appendProbeLoaders(compiler, rule.use) : [
                rule.use
            ];
        }
        if ('oneOf' in rule && rule.oneOf) return {
            ...rule,
            oneOf: addProbeLoader2Rules(rule.oneOf, compiler, fn)
        };
        if ('rules' in rule && rule.rules) return {
            ...rule,
            rules: addProbeLoader2Rules(rule.rules, compiler, fn)
        };
        return rule;
    });
}
function createLoaderContextTrap(final) {
    const cb = this.callback;
    let callback = (...args)=>{
        final(args[0], args[1] ?? null, args[2]);
        return cb.call(this, ...args);
    };
    const ac = this.async;
    let async = (...args)=>{
        const cb = ac(...args);
        return (...args)=>{
            final(args[0], args[1] ?? null, args[2]);
            return cb(...args);
        };
    };
    const trap = new Proxy(this, {
        get (target, key, receiver) {
            switch(key){
                case 'async':
                    return async;
                case 'callback':
                    return callback;
                case 'query':
                    if (target.query) {
                        if ('string' == typeof target.query) {
                            const res = target.query.replace(new RegExp(`"${common_namespaceObject.Loader.LoaderInternalPropertyName}":\{[^\}]*\},{0,1}`), '');
                            return res;
                        }
                        if ('object' == typeof target.query) {
                            const options = target.query[common_namespaceObject.Loader.LoaderInternalPropertyName];
                            if (options.hasOptions) return (0, external_lodash_namespaceObject.omit)(target.query, [
                                common_namespaceObject.Loader.LoaderInternalPropertyName
                            ]);
                            const innerLoaderPath = null == options ? void 0 : options.loader;
                            const loaderQuery = parsePathQueryFragment(innerLoaderPath).query;
                            return loaderQuery;
                        }
                    }
                    return Reflect.get(target, key, receiver);
                case 'getOptions':
                    return 'function' == typeof target.getOptions ? ()=>(0, external_lodash_namespaceObject.omit)(target.getOptions(), [
                            common_namespaceObject.Loader.LoaderInternalPropertyName
                        ]) : Reflect.get(target, key, receiver);
                default:
                    const _target = target;
                    return _target[key];
            }
        },
        set (target, key, value, receiver) {
            switch(key){
                case 'async':
                    async = value;
                    return true;
                case 'callback':
                    callback = value;
                    return true;
                default:
                    return Reflect.set(target, key, value, receiver);
            }
        },
        defineProperty (target, p, attrs) {
            return Reflect.defineProperty(target, p, attrs);
        }
    });
    return trap;
}
function parseQuery(query) {
    if (query.startsWith('?')) query = query.slice(1);
    const searchParams = new URLSearchParams(query);
    return Object.fromEntries(searchParams.entries());
}
exports.addProbeLoader2Rules = __webpack_exports__.addProbeLoader2Rules;
exports.createLoaderContextTrap = __webpack_exports__.createLoaderContextTrap;
exports.extractLoaderName = __webpack_exports__.extractLoaderName;
exports.getLoaderNameMatch = __webpack_exports__.getLoaderNameMatch;
exports.isESMLoader = __webpack_exports__.isESMLoader;
exports.loadLoaderModule = __webpack_exports__.loadLoaderModule;
exports.mapEachRules = __webpack_exports__.mapEachRules;
exports.parsePathQueryFragment = __webpack_exports__.parsePathQueryFragment;
exports.parseQuery = __webpack_exports__.parseQuery;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "addProbeLoader2Rules",
    "createLoaderContextTrap",
    "extractLoaderName",
    "getLoaderNameMatch",
    "isESMLoader",
    "loadLoaderModule",
    "mapEachRules",
    "parsePathQueryFragment",
    "parseQuery"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
