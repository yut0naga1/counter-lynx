import * as __WEBPACK_EXTERNAL_MODULE_json_cycle_87a8e8e6__ from "json-cycle";
import { Constants, Manifest } from "@rsdoctor/types";
import { EnvInfo, File, Json } from "@rsdoctor/utils/build";
import { Algorithm } from "@rsdoctor/utils/common";
import path from "path";
import { createHash } from "crypto";
import process from "process";
import { AsyncSeriesHook } from "tapable";
import { logger } from "@rsdoctor/utils/logger";
import { transformDataUrls } from "../utils/index.mjs";
var __webpack_modules__ = {
    "json-cycle": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_json_cycle_87a8e8e6__;
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
const jc = __webpack_require__("json-cycle");
class SDKCore {
    get outputDir() {
        return this._outputDir;
    }
    get name() {
        return this._name;
    }
    async bootstrap() {
        const [cpu, memory, nodeVersion, yarnVersion, npmVersion, pnpmVersion] = await Promise.all([
            EnvInfo.getCPUInfo(),
            EnvInfo.getMemoryInfo(),
            EnvInfo.getNodeVersion(),
            EnvInfo.getYarnVersion(),
            EnvInfo.getNpmVersion(),
            EnvInfo.getPnpmVersion()
        ]);
        this._envinfo = {
            ...this._envinfo,
            cpu,
            memory,
            nodeVersion,
            yarnVersion,
            npmVersion,
            pnpmVersion
        };
        const hash = createHash('md5').update([
            this.name,
            this.root,
            JSON.stringify(this._envinfo),
            Date.now()
        ].join('_')).digest('hex');
        this.setHash(hash);
    }
    async dispose() {}
    setOutputDir(outputDir) {
        this._outputDir = outputDir;
    }
    setName(name) {
        this._name = name;
    }
    setHash(hash) {
        this.hash = hash;
    }
    getHash() {
        return this.hash;
    }
    getClientRoutes() {
        return [
            ...this._clientRoutes
        ];
    }
    addClientRoutes(routes) {
        routes.forEach((route)=>{
            this._clientRoutes.add(route);
        });
        this.onDataReport();
    }
    async writePieces(storeData, _options) {
        const { outputDir } = this;
        const manifest = path.resolve(outputDir, Constants.RsdoctorOutputManifest);
        this.diskManifestPath = manifest;
        await File.fse.ensureDir(outputDir);
        const urlsPromiseList = [];
        for (let key of Object.keys(storeData)){
            const data = storeData[key];
            if ('object' != typeof data) {
                urlsPromiseList.push({
                    name: key,
                    files: data
                });
                continue;
            }
            const jsonStr = await (async ()=>{
                try {
                    if ('configs' === key) return JSON.stringify(jc.decycle(data));
                    return JSON.stringify(data);
                } catch (error) {
                    return Json.stringify(data);
                }
            })();
            if (Array.isArray(jsonStr)) {
                const urls = jsonStr.map((str, index)=>this.writeToFolder(str, outputDir, key, this.extraConfig, index + 1));
                urlsPromiseList.push(...urls);
            } else urlsPromiseList.push(this.writeToFolder(jsonStr, outputDir, key, this.extraConfig));
        }
        const dataUrls = await Promise.all(urlsPromiseList);
        logger.debug(`SDKCore.writePieces extraConfig: ${JSON.stringify(this.extraConfig)}`, '[SDKCore.writePieces]');
        this.cloudData = {
            client: {
                enableRoutes: this.getClientRoutes()
            },
            data: transformDataUrls(dataUrls)
        };
    }
    async writeManifest() {
        const { cloudData: data, diskManifestPath } = this;
        const dataStr = JSON.stringify(data, null, 2);
        logger.debug(`SDKCore.writeManifest extraConfig: ${this.extraConfig}`, '[SDKCore.writeManifest]');
        await Promise.all([
            File.fse.writeFile(diskManifestPath, dataStr)
        ]);
        return diskManifestPath;
    }
    async saveManifest(data, options) {
        await this.writePieces(data, options);
        const manifestDiskPath = await this.writeManifest();
        await this.hooks.afterSaveManifest.promise({
            manifestWithShardingFiles: this.cloudData,
            manifestDiskPath
        });
        return manifestDiskPath;
    }
    writeToFolder(jsonStr, dir, key, extraConfig, index) {
        const { compressData } = extraConfig || {
            compressData: true
        };
        const sharding = compressData ? new File.FileSharding(Algorithm.compressText(jsonStr)) : new File.FileSharding(jsonStr);
        const folder = path.resolve(dir, key);
        const writer = sharding.writeStringToFolder(folder, '', index);
        return writer.then((item)=>{
            const res = {
                name: key,
                files: item.map((el)=>({
                        path: path.resolve(folder, el.filename),
                        basename: el.filename,
                        content: el.content
                    }))
            };
            return res;
        });
    }
    constructor({ name, root }){
        this.hooks = {
            afterSaveManifest: new AsyncSeriesHook([
                'result'
            ])
        };
        this._envinfo = {};
        this._clientRoutes = new Set([
            Manifest.RsdoctorManifestClientRoutes.Overall
        ]);
        this.diskManifestPath = '';
        this._name = name;
        this.root = root;
        this.pid = process.pid;
        this._outputDir = path.join(this.outputDir || this.root, Constants.RsdoctorOutputFolder);
    }
}
export { SDKCore };
