import * as __WEBPACK_EXTERNAL_MODULE__server_fakeServer_mjs_179969cf__ from "../server/fakeServer.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__server_index_mjs_ad27270e__ from "../server/index.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__utils_index_mjs_be7570d9__ from "../utils/index.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__utils_openBrowser_mjs_06d7bf6d__ from "../utils/openBrowser.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__core_mjs_165c2562__ from "./core.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_graph_0dbfec78__ from "@rsdoctor/graph";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_types_d1991c3b__ from "@rsdoctor/types";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_build_f62ed182__ from "@rsdoctor/utils/build";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_common_f9f17f84__ from "@rsdoctor/utils/common";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_error_c16cc6f1__ from "@rsdoctor/utils/error";
import * as __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_logger_39923349__ from "@rsdoctor/utils/logger";
import * as __WEBPACK_EXTERNAL_MODULE_fs_extra_ce68a66b__ from "fs-extra";
import * as __WEBPACK_EXTERNAL_MODULE_json_cycle_87a8e8e6__ from "json-cycle";
import * as __WEBPACK_EXTERNAL_MODULE_path__ from "path";
import * as __WEBPACK_EXTERNAL_MODULE_source_map_c2f0c629__ from "source-map";
export * from "../utils/base.mjs";
var __webpack_modules__ = {
    "../server/fakeServer": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__server_fakeServer_mjs_179969cf__;
    },
    "../server": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__server_index_mjs_ad27270e__;
    },
    "../utils": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__utils_index_mjs_be7570d9__;
    },
    "@/sdk/utils/openBrowser": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__utils_openBrowser_mjs_06d7bf6d__;
    },
    "./core": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__core_mjs_165c2562__;
    },
    "@rsdoctor/graph": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_graph_0dbfec78__;
    },
    "@rsdoctor/types": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_types_d1991c3b__;
    },
    "@rsdoctor/utils/build": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_build_f62ed182__;
    },
    "@rsdoctor/utils/common": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_common_f9f17f84__;
    },
    "@rsdoctor/utils/error": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_error_c16cc6f1__;
    },
    "@rsdoctor/utils/logger": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rsdoctor_utils_logger_39923349__;
    },
    "fs-extra": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_fs_extra_ce68a66b__;
    },
    "json-cycle": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_json_cycle_87a8e8e6__;
    },
    path: function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_path__;
    },
    "source-map": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_source_map_c2f0c629__;
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
var external_fs_extra_ = __webpack_require__("fs-extra");
var external_path_ = __webpack_require__("path");
var error_ = __webpack_require__("@rsdoctor/utils/error");
var types_ = __webpack_require__("@rsdoctor/types");
var build_ = __webpack_require__("@rsdoctor/utils/build");
var external_source_map_ = __webpack_require__("source-map");
var graph_ = __webpack_require__("@rsdoctor/graph");
var logger_ = __webpack_require__("@rsdoctor/utils/logger");
var index_mjs_ = __webpack_require__("../server");
var fakeServer_mjs_ = __webpack_require__("../server/fakeServer");
var external_core_mjs_ = __webpack_require__("./core");
var common_ = __webpack_require__("@rsdoctor/utils/common");
var external_utils_index_mjs_ = __webpack_require__("../utils");
__webpack_require__("@/sdk/utils/openBrowser");
const jc = __webpack_require__("json-cycle");
class RsdoctorSDK extends external_core_mjs_.SDKCore {
    async bootstrap() {
        logger_.logger.debug(`${Date.now()}`, '[RsdoctorSDK][bootstrap start]');
        this.server && await this.server.bootstrap();
        await super.bootstrap();
        logger_.logger.debug(`${Date.now()} ${this.server.origin}`, '[RsdoctorSDK][bootstrap end]');
    }
    async dispose() {
        logger_.logger.debug(`${Date.now()}`, '[RsdoctorSDK][dispose start]');
        this.server && await this.server.dispose();
        await super.dispose();
        logger_.logger.debug(`${Date.now()}`, '[RsdoctorSDK][dispose end]');
    }
    async applyErrorFix(id) {
        const { _errors: errors } = this;
        const error = errors.find((err)=>err.id === id);
        if (!error || !error.path || !error.fixData || error.fixData.isFixed) return;
        const { path: filePath, fixData } = error;
        const sameFileErrors = errors.filter((item)=>item.path === filePath && item !== error);
        let content = (await build_.File.fse.readFile(filePath, 'utf-8')).toString();
        const startTxt = content.substring(0, fixData.start);
        const endTxt = content.substring(fixData.end, content.length);
        const offset = (fixData.newText ?? '').length - (fixData.end - fixData.start);
        content = startTxt + fixData.newText + endTxt;
        for (const other of sameFileErrors){
            const { fixData: otherFixData } = other;
            if (otherFixData) {
                if (otherFixData.start >= fixData.end) {
                    otherFixData.start += offset;
                    otherFixData.end += offset;
                }
            }
        }
        await build_.File.fse.writeFile(filePath, content);
    }
    clear() {
        this._errors = [];
        this._loader = [];
        this._resolver = [];
        this._plugin = {};
        this._moduleGraph = new graph_.ModuleGraph();
        this._chunkGraph = new graph_.ChunkGraph();
    }
    clearSourceMapCache() {
        this._rawSourceMapCache = new Map();
        this._sourceMap = new Map();
    }
    async getSourceMap(file) {
        var _rawData_sourcesContent;
        const { _sourceMap: sourceMap, _rawSourceMapCache: rawMap } = this;
        if (sourceMap.has(file)) return sourceMap.get(file);
        const rawData = rawMap.get(file);
        if (!rawData || rawData.version < 0 || !(null == (_rawData_sourcesContent = rawData.sourcesContent) ? void 0 : _rawData_sourcesContent[0]) || !rawData.mappings) return Promise.resolve(void 0);
        try {
            const result = await new external_source_map_.SourceMapConsumer(rawData);
            sourceMap.set(file, result);
            return result;
        } catch (e) {
            return Promise.resolve(void 0);
        }
    }
    reportSourceMap(data) {
        this._rawSourceMapCache.set(data.file, data);
    }
    reportConfiguration(config) {
        config.root ??= this._root;
        this._configs.push(config);
        this.onDataReport();
    }
    reportError(errors) {
        errors.forEach((item)=>{
            this._errors.push(error_.DevToolError.from(item, {
                code: this.name
            }));
        });
        this.onDataReport();
    }
    reportLoader(data) {
        data.forEach((item)=>{
            var _this_extraConfig;
            if ((null == (_this_extraConfig = this.extraConfig) ? void 0 : _this_extraConfig.mode) === types_.SDK.IMode[types_.SDK.IMode.brief]) item.loaders.forEach((_loader)=>{
                _loader.input = '';
                _loader.result = '';
            });
            let match = this._loader.find((e)=>e.resource.path === item.resource.path);
            if (match) match.loaders.push(...item.loaders);
            else {
                match = item;
                this._loader.push(item);
            }
            match.loaders.sort((a, b)=>{
                if (a.startAt !== b.startAt) return a.startAt - b.startAt;
                if (a.isPitch) {
                    if (b.isPitch) return a.loaderIndex - b.loaderIndex;
                    return -1;
                }
                if (b.isPitch) return 1;
                return b.loaderIndex - a.loaderIndex;
            });
        });
        this.onDataReport();
    }
    reportLoaderStartOrEnd(data) {
        const _builtinLoader = data.loaders[0];
        if (_builtinLoader.startAt) this._loaderStart.push(data);
        else if (_builtinLoader.endAt) {
            const matchLoaderStart = this._loaderStart.find((e)=>e.resource.path === data.resource.path && e.loaders[0].loader === _builtinLoader.loader);
            if (matchLoaderStart) {
                matchLoaderStart.loaders[0].result = _builtinLoader.result;
                matchLoaderStart.loaders[0].endAt = _builtinLoader.endAt;
                this.reportLoader([
                    matchLoaderStart
                ]);
            }
        }
    }
    reportResolver(data) {
        data.forEach((item)=>this._resolver.push(item));
        this.onDataReport();
    }
    reportPlugin(data) {
        Object.keys(data).forEach((hook)=>{
            if (this._plugin[hook]) data[hook].forEach((item)=>{
                this._plugin[hook].push(item);
            });
            else this._plugin[hook] = data[hook];
        });
        this.onDataReport();
    }
    reportModuleGraph(data) {
        logger_.logger.debug(`data size: ${data.size()}`, '[SDK.reportModuleGraph][start]');
        this._moduleGraph.fromInstance(data);
        this.createPackageGraph();
        this.onDataReport();
        logger_.logger.debug(`sdk._moduleGraph size: ${this._moduleGraph.size()}`, '[SDK reportModuleGraph][end]');
    }
    reportPackageGraph(data) {
        logger_.logger.debug('[SDK.reportPackageGraph][start]');
        if (!this._packageGraph) this._packageGraph = data;
        this.onDataReport();
        logger_.logger.debug(`sdk._moduleGraph size: ${this._moduleGraph.size()}`, '[SDK reportPackageGraph][end]');
    }
    reportChunkGraph(data) {
        this._chunkGraph.addAsset(...data.getAssets());
        this._chunkGraph.addChunk(...data.getChunks());
        this._chunkGraph.addEntryPoint(...data.getEntryPoints());
        this.onDataReport();
    }
    reportSummaryData(part) {
        const keys = [
            'costs'
        ];
        for (const key of keys){
            const v = part[key];
            if (v) if ('object' == typeof v) if (Array.isArray(v)) this._summary[key] = [
                ...this._summary[key] || [],
                ...v
            ];
            else this._summary[key] = {
                ...this._summary[key] || {},
                ...v
            };
            else this._summary[key] = v;
        }
        this.onDataReport();
    }
    createPackageGraph() {
        logger_.logger.debug(`sdk._moduleGraph size: ${this._moduleGraph.size()}`, '[SDK.createPackageGraph][start]');
        if (!this._packageGraph) {
            const pkgGraph = graph_.PackageGraph.fromModuleGraph(this._moduleGraph, this.root, (path)=>{
                try {
                    const exists = build_.File.fse.existsSync(path);
                    if (exists) return build_.File.fse.readJSONSync(path);
                } catch (error) {
                    const { message, stack } = error;
                    logger_.logger.debug(()=>`sdk.createPackageGraph error, path: ${path}, error message: ${stack || message}`, '[SDK.createPackageGraph][error]');
                }
            });
            this._packageGraph = pkgGraph;
            logger_.logger.debug(`sdk._packageGraph packages: ${this._packageGraph.getPackages().length}`, '[SDK.createPackageGraph][end]');
        }
    }
    async writeStore(options) {
        var _this_extraConfig;
        logger_.logger.debug("sdk.writeStore has run.", '[SDK.writeStore][end]');
        if ((null == (_this_extraConfig = this.extraConfig) ? void 0 : _this_extraConfig.mode) === types_.SDK.IMode[types_.SDK.IMode.brief]) {
            var _this_extraConfig_brief;
            const clientHtmlPath = this.extraConfig.innerClientPath ? this.extraConfig.innerClientPath : require.resolve('@rsdoctor/client');
            if (null == (_this_extraConfig_brief = this.extraConfig.brief) ? void 0 : _this_extraConfig_brief.writeDataJson) await this.saveManifest(this.getStoreData(), options || {});
            return this.inlineScriptsAndStyles(clientHtmlPath);
        }
        return this.saveManifest(this.getStoreData(), options || {});
    }
    getStoreData() {
        const ctx = this;
        return {
            get hash () {
                return ctx.hash;
            },
            get root () {
                return ctx.root;
            },
            get envinfo () {
                return ctx._envinfo;
            },
            get pid () {
                return ctx.pid;
            },
            get errors () {
                return ctx._errors.map((err)=>err.toData());
            },
            get configs () {
                return ctx._configs.slice();
            },
            get summary () {
                return {
                    ...ctx._summary
                };
            },
            get resolver () {
                return ctx._resolver.slice();
            },
            get loader () {
                return ctx._loader.slice();
            },
            get moduleGraph () {
                var _ctx__configs__config, _ctx__configs_, _ctx__configs;
                return ctx._moduleGraph.toData({
                    contextPath: (null == (_ctx__configs = ctx._configs) ? void 0 : null == (_ctx__configs_ = _ctx__configs[0]) ? void 0 : null == (_ctx__configs__config = _ctx__configs_.config) ? void 0 : _ctx__configs__config.context) || ''
                });
            },
            get chunkGraph () {
                return ctx._chunkGraph.toData(ctx.type);
            },
            get moduleCodeMap () {
                return ctx._moduleGraph.toCodeData(ctx.type);
            },
            get plugin () {
                return {
                    ...ctx._plugin
                };
            },
            get packageGraph () {
                return ctx._packageGraph ? ctx._packageGraph.toData() : {
                    packages: [],
                    dependencies: []
                };
            },
            get otherReports () {
                return {
                    treemapReportHtml: ''
                };
            }
        };
    }
    getManifestData() {
        const dataValue = this.getStoreData();
        const data = {
            client: {
                enableRoutes: this.getClientRoutes()
            },
            data: Object.keys(dataValue).reduce((t, e)=>{
                const _e = e;
                if (dataValue[_e] && 'object' == typeof dataValue[_e]) t[e] = [
                    `${this.server.origin}${types_.SDK.ServerAPI.API.LoadDataByKey}/${e}`
                ];
                else t[e] = dataValue[_e];
                return t;
            }, {}),
            __LOCAL__SERVER__: true,
            __SOCKET__PORT__: this.server.socketUrl.port.toString(),
            __SOCKET__URL__: this.server.socketUrl.socketUrl
        };
        return data;
    }
    getRuleContext(_options) {
        this.createPackageGraph();
        return {
            root: this.root,
            errors: this._errors.slice(),
            configs: this._configs.slice(),
            moduleGraph: this._moduleGraph,
            chunkGraph: this._chunkGraph,
            packageGraph: this._packageGraph,
            loader: this._loader.slice(),
            otherReports: {
                treemapReportHtml: ''
            }
        };
    }
    onDataReport() {
        this.server.broadcast();
    }
    addRsdoctorDataToHTML(storeData, htmlContent) {
        let compressTextScripts = `<script>window.${types_.Constants.WINDOW_RSDOCTOR_TAG}={}</script>`;
        for (let key of Object.keys(storeData)){
            const data = storeData[key];
            const jsonStrFn = ()=>{
                try {
                    if ('configs' === key) return JSON.stringify(jc.decycle(data));
                    return JSON.stringify(data);
                } catch (error) {
                    console.error(error);
                    return '';
                }
            };
            const compressText = common_.Algorithm.compressText(jsonStrFn());
            compressTextScripts = `${compressTextScripts} <script>window.${types_.Constants.WINDOW_RSDOCTOR_TAG}.${key}=${JSON.stringify(compressText)}</script>`;
        }
        compressTextScripts = `${compressTextScripts} <script>window.${types_.Constants.WINDOW_RSDOCTOR_TAG}.enableRoutes=${JSON.stringify(this.getClientRoutes())}</script>`;
        htmlContent = htmlContent.replace('<body>', `<body>${compressTextScripts}`);
        return htmlContent;
    }
    inlineScriptsAndStyles(htmlFilePath) {
        var _this_extraConfig_brief, _this_extraConfig;
        function inlineScripts(basePath, scripts) {
            return scripts.map((src)=>{
                const scriptPath = external_path_["default"].resolve(basePath, src);
                try {
                    const scriptContent = external_fs_extra_["default"].readFileSync(scriptPath, 'utf-8');
                    return `<script>${scriptContent}</script>`;
                } catch (error) {
                    console.error(`Could not read script at ${scriptPath}:`, error);
                    return '';
                }
            }).join('');
        }
        function inlineCss(basePath, cssFiles) {
            return cssFiles.map((href)=>{
                const cssPath = external_path_["default"].resolve(basePath, href);
                try {
                    const cssContent = external_fs_extra_["default"].readFileSync(cssPath, 'utf-8');
                    return `<style>${cssContent}</style>`;
                } catch (error) {
                    console.error(`Could not read CSS at ${cssPath}:`, error);
                    return '';
                }
            }).join('');
        }
        let htmlContent = external_fs_extra_["default"].readFileSync(htmlFilePath, 'utf-8');
        const basePath = external_path_["default"].dirname(htmlFilePath);
        const scriptSrcs = Array.from(htmlContent.matchAll(/<script\s+(?:defer="defer"|defer)\s+src=["'](.+?)["']><\/script>/g), (m)=>m[1]);
        const cssHrefs = Array.from(htmlContent.matchAll(/<link\s+href=["'](.+?)["']\s+rel="stylesheet">/g), (m)=>m[1]);
        htmlContent = htmlContent.replace(/<script\s+.*?src=["'].*?["']><\/script>/g, '');
        htmlContent = htmlContent.replace(/<link\s+.*?rel=["']stylesheet["'].*?>/g, '');
        const inlinedScripts = inlineScripts(basePath, scriptSrcs);
        const inlinedCss = inlineCss(basePath, cssHrefs);
        const index = htmlContent.indexOf('</body>');
        htmlContent = htmlContent.slice(0, index) + inlinedCss + inlinedScripts + htmlContent.slice(index);
        htmlContent = this.addRsdoctorDataToHTML(this.getStoreData(), htmlContent);
        const outputFilePath = external_path_["default"].resolve(this.outputDir, (null == (_this_extraConfig = this.extraConfig) ? void 0 : null == (_this_extraConfig_brief = _this_extraConfig.brief) ? void 0 : _this_extraConfig_brief.reportHtmlName) || 'rsdoctor-report.html');
        external_fs_extra_["default"].outputFileSync(outputFilePath, htmlContent, {
            encoding: 'utf-8',
            flag: 'w'
        });
        return outputFilePath;
    }
    constructor(options){
        var _options_config, _options_config1, _options_config_printLog, _options_config2;
        super(options), this._summary = {
            costs: []
        }, this._configs = [], this._errors = [], this._loader = [], this._loaderStart = [], this._resolver = [], this._plugin = {}, this._moduleGraph = new graph_.ModuleGraph(), this._chunkGraph = new graph_.ChunkGraph(), this._rawSourceMapCache = new Map(), this._sourceMap = new Map();
        this.server = (null == (_options_config = options.config) ? void 0 : _options_config.noServer) ? new fakeServer_mjs_.RsdoctorFakeServer(this, void 0) : new index_mjs_.RsdoctorServer(this, options.port, {
            innerClientPath: (null == (_options_config1 = options.config) ? void 0 : _options_config1.innerClientPath) || '',
            printServerUrl: null == (_options_config2 = options.config) ? void 0 : null == (_options_config_printLog = _options_config2.printLog) ? void 0 : _options_config_printLog.serverUrls
        });
        this.type = common_.Lodash.isNumber(options.type) ? options.type : types_.SDK.ToDataType.Normal;
        this.extraConfig = options.config;
        this._root = (0, external_utils_index_mjs_.findRoot)() ?? '';
    }
}
export { RsdoctorSDK };
