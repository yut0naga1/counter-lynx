import { Client, SDK } from "@rsdoctor/types";
import { Server } from "@rsdoctor/utils/build";
import sirv from "sirv";
import { Bundle, GlobalConfig, Lodash } from "@rsdoctor/utils/common";
import assert from "assert";
import body_parser from "body-parser";
import cors from "cors";
import { PassThrough } from "stream";
import { Socket } from "./socket/index.mjs";
import { Router } from "./router.mjs";
import { chalk, logger } from "@rsdoctor/utils/logger";
import { openBrowser } from "../utils/openBrowser.mjs";
import path from "path";
import { getLocalIpAddress } from "./utils.mjs";
export * from "./utils.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__apis_index_mjs_fde2a3c6__ from "./apis/index.mjs";
class RsdoctorServer {
    get app() {
        return this._server.app;
    }
    get host() {
        const host = getLocalIpAddress();
        return host;
    }
    get origin() {
        return `http://${this.host}:${this.port}`;
    }
    get socketUrl() {
        return {
            port: this.port,
            socketUrl: `ws://localhost:${this.port}`
        };
    }
    get innerClientPath() {
        return this._innerClientPath;
    }
    async bootstrap() {
        if (!this.disposed) return;
        const port = Server.getPortSync(this.port);
        this.port = port;
        this._server = await Server.createServer(port);
        this._socket = new Socket({
            sdk: this.sdk,
            server: this._server.server,
            port: this.port
        });
        await this._socket.bootstrap();
        GlobalConfig.writeMcpPort(this.port, this.sdk.name);
        logger.debug(`Successfully wrote mcp.json for ${chalk.cyan(this.sdk.name)} builder`);
        this.disposed = false;
        this.app.use(cors());
        this.app.use(body_parser.json({
            limit: '500mb'
        }));
        const clientHtmlPath = this._innerClientPath ? this._innerClientPath : require.resolve('@rsdoctor/client');
        const clientDistPath = path.resolve(clientHtmlPath, '..');
        this.app.use(sirv(clientDistPath, {
            dev: true
        }));
        await this._router.setup();
        process.once('exit', this.dispose);
        process.once('SIGINT', this.dispose);
        process.once('SIGTERM', this.dispose);
        process.once('unhandledRejection', this.dispose);
        process.once('uncaughtException', this.dispose);
    }
    wrapNextHandleFunction(method, cb) {
        return async (req, res, next)=>{
            var _req_method;
            const m = null == (_req_method = req.method) ? void 0 : _req_method.toUpperCase();
            if (m === method) {
                try {
                    const body = await cb(req, res, next);
                    res.setHeader('Access-Control-Allow-Origin', '*');
                    res.setHeader('Access-Control-Allow-Credentials', 'true');
                    res.statusCode = 200;
                    if (Buffer.isBuffer(body)) {
                        res.setHeader('Content-Length', body.byteLength);
                        const ps = new PassThrough();
                        ps.write(body);
                        ps.end();
                        ps.pipe(res);
                    } else if (body && 'object' == typeof body) {
                        res.writeHead(200, {
                            'Content-Type': 'application/json;utf-8'
                        });
                        res.write(JSON.stringify(body));
                        res.end();
                    } else res.writeHead(200).end(body);
                } catch (error) {
                    res.statusCode = 500;
                    res.end(error.message);
                    return next(error);
                }
                return;
            }
            await next();
        };
    }
    proxy(api, method, cb) {
        let idx = this.app.stack.findIndex((e)=>e.route === api);
        if (-1 === idx) idx = this.app.stack.length - 1;
        this.app.stack.splice(idx, 0, {
            route: api,
            handle: this.wrapNextHandleFunction(method, cb)
        });
    }
    getClientUrl(route = 'homepage', ...args) {
        const relativeUrl = SDK.ServerAPI.API.EntryHtml;
        switch(route){
            case Client.RsdoctorClientRoutes.BundleDiff:
                {
                    const [baseline, current] = args;
                    const qs = Bundle.getBundleDiffPageQueryString([
                        baseline,
                        current
                    ]);
                    return `${relativeUrl}${qs}#${Client.RsdoctorClientRoutes.BundleDiff}`;
                }
            default:
                return relativeUrl;
        }
    }
    async openClientPage(...args) {
        const relativeUrl = this.getClientUrl(...args);
        const needEncodeURI = arguments[0] === Client.RsdoctorClientRoutes.BundleDiff;
        const url = `http://${this.host}:${this.port}${relativeUrl}`;
        const localhostUrl = `http://localhost:${this.port}${relativeUrl}`;
        await openBrowser(localhostUrl, !needEncodeURI);
        if (this._printServerUrl) logger.info(`${chalk.green(`${this.sdk.name} compiler's`)} analyzer running on: ${chalk.cyan(url)}`);
    }
    sendAPIDataToClient(api, msg) {
        var _this__socket;
        null == (_this__socket = this._socket) || _this__socket.sendAPIData(api, msg);
    }
    async broadcast() {
        var _this__socket;
        await (null == (_this__socket = this._socket) ? void 0 : _this__socket.broadcast());
    }
    constructor(sdk, port = Server.defaultPort, config){
        this.sdk = sdk;
        this.disposed = true;
        this.get = (route, cb)=>{
            const { app } = this;
            app.use(route, this.wrapNextHandleFunction('GET', cb));
            return app;
        };
        this.post = (route, cb)=>{
            const { app } = this;
            app.use(route, this.wrapNextHandleFunction('POST', cb));
            return app;
        };
        this.dispose = async ()=>{
            if (this.disposed) return;
            this.disposed = true;
            if (this._server) await this._server.close();
            if (this._socket) this._socket.dispose();
        };
        assert('number' == typeof port);
        this.port = port;
        this._router = new Router({
            sdk,
            server: this,
            apis: Object.values(__WEBPACK_EXTERNAL_MODULE__apis_index_mjs_fde2a3c6__)
        });
        this._innerClientPath = (null == config ? void 0 : config.innerClientPath) || '';
        this._printServerUrl = Lodash.isUndefined(null == config ? void 0 : config.printServerUrl) ? true : null == config ? void 0 : config.printServerUrl;
    }
}
export { RsdoctorServer };
