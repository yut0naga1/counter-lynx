"use strict";
var __webpack_modules__ = {
    "json-cycle": function(module) {
        module.exports = require("json-cycle");
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
(()=>{
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        SDKCore: ()=>SDKCore
    });
    const types_namespaceObject = require("@rsdoctor/types");
    const build_namespaceObject = require("@rsdoctor/utils/build");
    const common_namespaceObject = require("@rsdoctor/utils/common");
    const external_path_namespaceObject = require("path");
    var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
    const external_crypto_namespaceObject = require("crypto");
    const external_process_namespaceObject = require("process");
    var external_process_default = /*#__PURE__*/ __webpack_require__.n(external_process_namespaceObject);
    const external_tapable_namespaceObject = require("tapable");
    const logger_namespaceObject = require("@rsdoctor/utils/logger");
    const index_js_namespaceObject = require("../utils/index.js");
    const jc = __webpack_require__("json-cycle");
    class SDKCore {
        get outputDir() {
            return this._outputDir;
        }
        get name() {
            return this._name;
        }
        async bootstrap() {
            const [cpu, memory, nodeVersion, yarnVersion, npmVersion, pnpmVersion] = await Promise.all([
                build_namespaceObject.EnvInfo.getCPUInfo(),
                build_namespaceObject.EnvInfo.getMemoryInfo(),
                build_namespaceObject.EnvInfo.getNodeVersion(),
                build_namespaceObject.EnvInfo.getYarnVersion(),
                build_namespaceObject.EnvInfo.getNpmVersion(),
                build_namespaceObject.EnvInfo.getPnpmVersion()
            ]);
            this._envinfo = {
                ...this._envinfo,
                cpu,
                memory,
                nodeVersion,
                yarnVersion,
                npmVersion,
                pnpmVersion
            };
            const hash = (0, external_crypto_namespaceObject.createHash)('md5').update([
                this.name,
                this.root,
                JSON.stringify(this._envinfo),
                Date.now()
            ].join('_')).digest('hex');
            this.setHash(hash);
        }
        async dispose() {}
        setOutputDir(outputDir) {
            this._outputDir = outputDir;
        }
        setName(name) {
            this._name = name;
        }
        setHash(hash) {
            this.hash = hash;
        }
        getHash() {
            return this.hash;
        }
        getClientRoutes() {
            return [
                ...this._clientRoutes
            ];
        }
        addClientRoutes(routes) {
            routes.forEach((route)=>{
                this._clientRoutes.add(route);
            });
            this.onDataReport();
        }
        async writePieces(storeData, _options) {
            const { outputDir } = this;
            const manifest = external_path_default().resolve(outputDir, types_namespaceObject.Constants.RsdoctorOutputManifest);
            this.diskManifestPath = manifest;
            await build_namespaceObject.File.fse.ensureDir(outputDir);
            const urlsPromiseList = [];
            for (let key of Object.keys(storeData)){
                const data = storeData[key];
                if ('object' != typeof data) {
                    urlsPromiseList.push({
                        name: key,
                        files: data
                    });
                    continue;
                }
                const jsonStr = await (async ()=>{
                    try {
                        if ('configs' === key) return JSON.stringify(jc.decycle(data));
                        return JSON.stringify(data);
                    } catch (error) {
                        return build_namespaceObject.Json.stringify(data);
                    }
                })();
                if (Array.isArray(jsonStr)) {
                    const urls = jsonStr.map((str, index)=>this.writeToFolder(str, outputDir, key, this.extraConfig, index + 1));
                    urlsPromiseList.push(...urls);
                } else urlsPromiseList.push(this.writeToFolder(jsonStr, outputDir, key, this.extraConfig));
            }
            const dataUrls = await Promise.all(urlsPromiseList);
            logger_namespaceObject.logger.debug(`SDKCore.writePieces extraConfig: ${JSON.stringify(this.extraConfig)}`, '[SDKCore.writePieces]');
            this.cloudData = {
                client: {
                    enableRoutes: this.getClientRoutes()
                },
                data: (0, index_js_namespaceObject.transformDataUrls)(dataUrls)
            };
        }
        async writeManifest() {
            const { cloudData: data, diskManifestPath } = this;
            const dataStr = JSON.stringify(data, null, 2);
            logger_namespaceObject.logger.debug(`SDKCore.writeManifest extraConfig: ${this.extraConfig}`, '[SDKCore.writeManifest]');
            await Promise.all([
                build_namespaceObject.File.fse.writeFile(diskManifestPath, dataStr)
            ]);
            return diskManifestPath;
        }
        async saveManifest(data, options) {
            await this.writePieces(data, options);
            const manifestDiskPath = await this.writeManifest();
            await this.hooks.afterSaveManifest.promise({
                manifestWithShardingFiles: this.cloudData,
                manifestDiskPath
            });
            return manifestDiskPath;
        }
        writeToFolder(jsonStr, dir, key, extraConfig, index) {
            const { compressData } = extraConfig || {
                compressData: true
            };
            const sharding = compressData ? new build_namespaceObject.File.FileSharding(common_namespaceObject.Algorithm.compressText(jsonStr)) : new build_namespaceObject.File.FileSharding(jsonStr);
            const folder = external_path_default().resolve(dir, key);
            const writer = sharding.writeStringToFolder(folder, '', index);
            return writer.then((item)=>{
                const res = {
                    name: key,
                    files: item.map((el)=>({
                            path: external_path_default().resolve(folder, el.filename),
                            basename: el.filename,
                            content: el.content
                        }))
                };
                return res;
            });
        }
        constructor({ name, root }){
            this.hooks = {
                afterSaveManifest: new external_tapable_namespaceObject.AsyncSeriesHook([
                    'result'
                ])
            };
            this._envinfo = {};
            this._clientRoutes = new Set([
                types_namespaceObject.Manifest.RsdoctorManifestClientRoutes.Overall
            ]);
            this.diskManifestPath = '';
            this._name = name;
            this.root = root;
            this.pid = external_process_default().pid;
            this._outputDir = external_path_default().join(this.outputDir || this.root, types_namespaceObject.Constants.RsdoctorOutputFolder);
        }
    }
})();
exports.SDKCore = __webpack_exports__.SDKCore;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "SDKCore"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
