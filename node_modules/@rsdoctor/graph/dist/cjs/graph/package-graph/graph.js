"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    PackageGraph: ()=>PackageGraph,
    readPackageJson: ()=>external_utils_js_namespaceObject.readPackageJson
});
const external_lodash_unionby_namespaceObject = require("lodash.unionby");
var external_lodash_unionby_default = /*#__PURE__*/ __webpack_require__.n(external_lodash_unionby_namespaceObject);
const external_path_namespaceObject = require("path");
const types_namespaceObject = require("@rsdoctor/types");
const external_package_js_namespaceObject = require("./package.js");
const external_dependency_js_namespaceObject = require("./dependency.js");
const external_utils_js_namespaceObject = require("./utils.js");
class PackageGraph {
    static fromModuleGraph(graph, root, getPackageFile) {
        const pkgGraph = new PackageGraph(root);
        const modules = graph.getModules().filter((item)=>item.kind === types_namespaceObject.SDK.ModuleKind.Normal);
        for (const item of modules){
            const itemChunks = item.getChunks();
            if (!itemChunks) continue;
            const pkg = pkgGraph.getPackageByModule(item, getPackageFile);
            if (pkg) {
                pkgGraph.addPackage(pkg);
                pkg.addModule(item);
            }
        }
        for (const dep of graph.getDependencies()){
            const modulePkg = pkgGraph.getPackageByFile(dep.module.path);
            const dependencyPkg = pkgGraph.getPackageByFile(dep.dependency.path);
            if (modulePkg && dependencyPkg && !modulePkg.isSame(dependencyPkg)) {
                const pkgDep = new external_dependency_js_namespaceObject.PackageDependency(modulePkg, dependencyPkg, dep);
                pkgGraph.addDependency(pkgDep);
                modulePkg.addDependency(pkgDep);
            }
        }
        return pkgGraph;
    }
    getPackages() {
        return this._packages.slice();
    }
    getPackageByModule(module, readFile) {
        const { path: file, meta } = module;
        const { _pkgFileMap: pkgsMap } = this;
        const getPackageByData = (data)=>this.getPackageByData(data) ?? new external_package_js_namespaceObject.Package(data.name, data.root, data.version);
        if (pkgsMap.has(file)) return pkgsMap.get(file);
        if (meta.packageData) {
            const pkg = getPackageByData(meta.packageData);
            this.setDuplicates(module, pkg);
            pkgsMap.set(file, pkg);
            return pkg;
        }
        const cache = this.getPackageContainFile(file);
        if (cache) {
            pkgsMap.set(file, cache);
            return cache;
        }
        const data = (0, external_utils_js_namespaceObject.readPackageJson)(file, readFile);
        if (!data) return;
        if (data.root.startsWith('.')) data.root = (0, external_path_namespaceObject.resolve)(this._root, data.root);
        const pkg = getPackageByData(data);
        this.setDuplicates(module, pkg);
        this.addPackage(pkg);
        pkgsMap.set(file, pkg);
        return pkg;
    }
    getPackageByFile(file) {
        return this._pkgFileMap.get(file);
    }
    getPackageContainFile(file) {
        return this._packages.find((pkg)=>pkg.contain(file));
    }
    getPackagesByName(name) {
        return this._pkgNameMap.get(name) ?? [];
    }
    getPackageByData(data) {
        var _this__pkgNameMap_get;
        return null == (_this__pkgNameMap_get = this._pkgNameMap.get(data.name)) ? void 0 : _this__pkgNameMap_get.find((item)=>item.version === data.version && item.root === data.root);
    }
    addPackage(pkg) {
        if (this._packages.every((item)=>!item.isSame(pkg))) {
            this._packages.push(pkg);
            const { _pkgNameMap: map } = this;
            const arr = map.get(pkg.name) ?? [];
            if (arr.every((item)=>!item.isSame(pkg))) {
                arr.push(pkg);
                map.set(pkg.name, arr);
            }
        }
    }
    setDuplicates(module, pkg) {
        const assetsList = [];
        const chunksList = module.getChunks();
        chunksList.forEach((chunk)=>assetsList.push(...chunk.getAssets().filter((asset)=>asset.path.endsWith('.js'))));
        if (chunksList.length > 1) pkg.setDuplicates({
            module: {
                id: module.id,
                path: module.path
            },
            chunks: assetsList.map((asset)=>({
                    name: asset.path
                }))
        });
    }
    getDependenciesFromPackage(pkg) {
        return this._dependencies.filter((dep)=>dep.dependency === pkg);
    }
    addDependency(dep) {
        if (this._dependencies.every((item)=>!item.isSame(dep))) this._dependencies.push(dep);
    }
    getDependenciesFromOrigin() {
        return this._dependencies.filter((item)=>!item.package);
    }
    getDuplicatePackages() {
        return external_lodash_unionby_default()(Array.from(this._pkgNameMap.values()).map((pkgs)=>external_lodash_unionby_default()(pkgs, 'version')).filter((pkgs)=>pkgs.length > 1), (pkgs)=>pkgs[0].name);
    }
    toData() {
        return {
            packages: this._packages.map((e)=>e.toData()),
            dependencies: this._dependencies.map((d)=>d.toData())
        };
    }
    constructor(root){
        this._dependencies = [];
        this._packages = [];
        this._pkgNameMap = new Map();
        this._pkgFileMap = new Map();
        this._root = root;
    }
}
exports.PackageGraph = __webpack_exports__.PackageGraph;
exports.readPackageJson = __webpack_exports__.readPackageJson;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "PackageGraph",
    "readPackageJson"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
