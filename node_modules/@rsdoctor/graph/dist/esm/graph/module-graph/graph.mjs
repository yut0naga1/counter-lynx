import { SDK } from "@rsdoctor/types";
import { Dependency } from "./dependency.mjs";
import { Module } from "./module.mjs";
import { Statement } from "./statement.mjs";
import { ExportInfo, ModuleGraphModule, SideEffect, Variable } from "./tree-shaking/index.mjs";
class ModuleGraph {
    static init() {
        Module.init();
        Dependency.init();
        ModuleGraphModule.init();
    }
    static fromData(data) {
        const moduleGraph = new ModuleGraph();
        const getStatement = (data)=>new Statement(moduleGraph.getModuleById(data.module), data.position);
        for (const item of data.modules ?? []){
            var _item_meta, _item_meta1;
            const module = new Module(String(item.id), item.path, item.isEntry, item.kind, item.renderId, item.layer);
            module.id = item.id;
            module.setSize(item.size);
            module.meta = {
                strictHarmonyModule: (null == (_item_meta = item.meta) ? void 0 : _item_meta.strictHarmonyModule) ?? false,
                hasSetEsModuleStatement: (null == (_item_meta1 = item.meta) ? void 0 : _item_meta1.hasSetEsModuleStatement) ?? false
            };
            module._isPreferSource = item.isPreferSource;
            module.chunks = item.chunks;
            moduleGraph.addModule(module);
        }
        for (const moduleData of data.modules ?? []){
            const module = moduleGraph.getModuleById(moduleData.id);
            for (const depId of moduleData.dependencies){
                const depData = (data.dependencies ?? []).find((item)=>item.id === depId);
                const depModule = depData && moduleGraph.getModuleById(depData.originDependency);
                if (!depData || !depModule) {
                    console.warn(`The connection data ID is empty: ${depId}`);
                    continue;
                }
                const dep = module.addDependency(depData.request, depModule, depData.kind, depData.statements.map(getStatement));
                if (dep) {
                    dep.id = depData.id;
                    moduleGraph.addDependency(dep);
                }
            }
            for (const normalModuleId of moduleData.modules ?? []){
                const normalModule = moduleGraph.getModuleById(normalModuleId);
                if (!normalModule) {
                    console.warn(`Add the ordinary module ID as empty: ${normalModuleId}`);
                    continue;
                }
                module.addNormalModule(normalModule);
            }
            for (const concatenationModuleId of moduleData.concatenationModules ?? []){
                const concatenationModule = moduleGraph.getModuleById(concatenationModuleId);
                if (!concatenationModule) {
                    console.warn(`The aggregation module ID is empty: ${concatenationModule}`);
                    continue;
                }
                module.addConcatenationModule(concatenationModule);
            }
        }
        for (const exportData of data.exports ?? []){
            const info = new ExportInfo(exportData.name, exportData.identifier ? getStatement(exportData.identifier) : void 0);
            info.id = exportData.id;
            moduleGraph.addExportInfo(info);
        }
        for (const exportData of data.exports ?? [])if (exportData.from) {
            const current = moduleGraph._exportIdMap.get(exportData.id);
            const from = moduleGraph._exportIdMap.get(exportData.from);
            if (current && from) current.setFromExport(from);
        }
        for (const varData of data.variables ?? []){
            const module = moduleGraph.getModuleById(varData.module);
            if (!module) {
                console.warn(`The module ID in the variable is empty\u{FF1A}${varData.module}`);
                continue;
            }
            const info = new Variable(varData.name, module, varData.usedInfo, getStatement(varData.identifier));
            const exportInfo = moduleGraph._exportIdMap.get(varData.exported ?? -1);
            if (exportInfo) info.setExportInfo(exportInfo);
            info.id = varData.id;
            moduleGraph.addVariable(info);
        }
        for (const sideData of data.sideEffects ?? []){
            const module = moduleGraph.getModuleById(sideData.module);
            if (!module) {
                console.warn(`The module ID in the side effects is empty\u{FF1A}${sideData.module}`);
                continue;
            }
            const info = new SideEffect(sideData.name, module, getStatement(sideData.identifier), sideData.originName);
            info.isNameSpace = sideData.isNameSpace;
            info.id = sideData.id;
            for (const exportId of sideData.exports ?? []){
                const exportInfo = moduleGraph._exportIdMap.get(exportId);
                if (exportInfo) exportInfo.addSideEffect(info);
            }
            if (sideData.variable) {
                const varInfo = moduleGraph._varIdMap.get(sideData.variable);
                if (varInfo) info._variable = varInfo;
            }
            moduleGraph.addSideEffect(info);
        }
        for (const mgmData of data.moduleGraphModules ?? []){
            const module = moduleGraph.getModuleById(mgmData.module);
            if (!module) {
                console.warn(`The module ID in ModuleGraphModule is empty: ${mgmData.module}`);
                continue;
            }
            const mgm = new ModuleGraphModule(module, moduleGraph, mgmData.dynamic);
            moduleGraph.addModuleGraphModule(mgm);
            mgmData.exports.forEach((id)=>{
                const info = moduleGraph._exportIdMap.get(id);
                if (info) mgm.addExportInfo(info);
            });
            mgmData.sideEffects.forEach((id)=>{
                const info = moduleGraph._sideEffectIdMap.get(id);
                if (info) mgm.addSideEffect(info);
            });
            mgmData.variables.forEach((id)=>{
                const info = moduleGraph._varIdMap.get(id);
                if (info) mgm.addVariable(info);
            });
        }
        ModuleGraph.init();
        return moduleGraph;
    }
    clear() {
        this._dependenciesIdMap = new Map();
        this._moduleWebpackIdMap = new Map();
        this._moduleIdMap = new Map();
        this._moduleGraphModules = new Map();
        this._exportIdMap = new Map();
        this._sideEffectIdMap = new Map();
        this._varIdMap = new Map();
        this._layers = new Map();
    }
    size() {
        return this._moduleIdMap.size;
    }
    fromInstance(data) {
        this._dependenciesIdMap = new Map(data._dependenciesIdMap);
        this._moduleWebpackIdMap = new Map(data._moduleWebpackIdMap);
        this._moduleIdMap = new Map(data._moduleIdMap);
        this._moduleGraphModules = new Map(data._moduleGraphModules);
        this._exportIdMap = new Map(data._exportIdMap);
        this._sideEffectIdMap = new Map(data._sideEffectIdMap);
        this._varIdMap = new Map(data._varIdMap);
        this._layers = new Map(data._layers);
    }
    getSubGraphByModule(module) {
        const map = new Set();
        const result = [
            module
        ];
        map.add(module);
        for(let i = 0; i < result.length; i++){
            const current = result[i];
            for (const { dependency: depModule } of current.getDependencies())if (!map.has(depModule)) {
                map.add(depModule);
                result.push(depModule);
            }
        }
        return result;
    }
    getModules() {
        return Array.from(this._moduleWebpackIdMap.values());
    }
    getDependencies() {
        return Array.from(this._dependenciesIdMap.values());
    }
    getEntryModules() {
        return this.getModules().filter((item)=>item.isEntry && item.kind !== SDK.ModuleKind.Concatenation);
    }
    getModuleById(id) {
        return this._moduleIdMap.get(id);
    }
    getDependencyById(id) {
        return this._dependenciesIdMap.get(id);
    }
    getModuleByWebpackId(id) {
        return this._moduleWebpackIdMap.get(id);
    }
    getModuleByFile(file) {
        return this.getModules().find((item)=>item.path === file);
    }
    addModule(...modules) {
        for (const module of modules)if (!this._moduleIdMap.has(module.id)) {
            this._moduleWebpackIdMap.set(module.webpackId, module);
            this._moduleIdMap.set(module.id, module);
            module.layer && this.addLayer(module.layer);
        }
    }
    addDependency(...deps) {
        for (const dep of deps)if (!this._dependenciesIdMap.has(dep.id)) {
            this._dependenciesIdMap.set(dep.id, dep);
            this.addModule(dep.module);
            this.addModule(dep.dependency);
        }
    }
    removeModule(module) {
        this._moduleIdMap.delete(module.id);
        this._moduleWebpackIdMap.delete(module.webpackId);
        for (const dep of module.getDependencies()){
            this.removeDependency(dep);
            this._dependenciesIdMap.delete(dep.id);
        }
        for (const imported of module.getImported())imported.removeDependencyByModule(imported);
    }
    removeDependency(dep) {
        dep.module.removeDependency(dep);
        dep.dependency.removeImported(dep.module);
        this._dependenciesIdMap.delete(dep.id);
    }
    addModuleGraphModule(mgm) {
        if (!this._moduleGraphModules.has(mgm.module)) this._moduleGraphModules.set(mgm.module, mgm);
    }
    getModuleGraphModule(module) {
        return this._moduleGraphModules.get(module);
    }
    getModuleGraphModules() {
        return Array.from(this._moduleGraphModules.values());
    }
    addExportInfo(data) {
        this._exportIdMap.set(data.id, data);
    }
    addSideEffect(data) {
        this._sideEffectIdMap.set(data.id, data);
    }
    addVariable(data) {
        this._varIdMap.set(data.id, data);
    }
    addLayer(layer) {
        if (!this._layers.get(layer)) this._layers.set(layer, 1);
    }
    getLayers() {
        return this._layers;
    }
    toData(configs) {
        return {
            dependencies: this.getDependencies().map((item)=>item.toData()),
            modules: this.getModules().map((item)=>item.toData(null == configs ? void 0 : configs.contextPath)),
            moduleGraphModules: Array.from(this._moduleGraphModules.values()).map((item)=>item.toData()),
            exports: Array.from(this._exportIdMap.values()).map((item)=>item.toData()),
            sideEffects: Array.from(this._sideEffectIdMap.values()).map((item)=>item.toData()),
            variables: Array.from(this._varIdMap.values()).map((item)=>item.toData()),
            layers: Array.from(this._layers.keys())
        };
    }
    toCodeData(type = SDK.ToDataType.Normal) {
        const codeMap = {};
        this.getModules().forEach((item)=>{
            codeMap[item.id] = item.getSource(type);
        });
        return codeMap;
    }
    setModules(modules) {
        this._moduleIdMap = new Map(modules.map((m)=>[
                m.id,
                m
            ]));
        this._moduleWebpackIdMap = new Map(modules.map((m)=>[
                m.webpackId,
                m
            ]));
        this._layers = new Map(modules.filter((m)=>m.layer).map((m)=>[
                m.layer,
                1
            ]));
    }
    setDependencies(dependencies) {
        this._dependenciesIdMap = new Map(dependencies.map((d)=>[
                d.id,
                d
            ]));
    }
    constructor(){
        this._dependenciesIdMap = new Map();
        this._moduleWebpackIdMap = new Map();
        this._moduleIdMap = new Map();
        this._moduleGraphModules = new Map();
        this._exportIdMap = new Map();
        this._sideEffectIdMap = new Map();
        this._varIdMap = new Map();
        this._layers = new Map();
    }
}
export { ModuleGraph };
