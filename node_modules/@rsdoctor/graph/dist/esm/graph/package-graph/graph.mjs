import lodash_unionby from "lodash.unionby";
import { resolve } from "path";
import { SDK } from "@rsdoctor/types";
import { Package } from "./package.mjs";
import { PackageDependency } from "./dependency.mjs";
import { readPackageJson } from "./utils.mjs";
class PackageGraph {
    static fromModuleGraph(graph, root, getPackageFile) {
        const pkgGraph = new PackageGraph(root);
        const modules = graph.getModules().filter((item)=>item.kind === SDK.ModuleKind.Normal);
        for (const item of modules){
            const itemChunks = item.getChunks();
            if (!itemChunks) continue;
            const pkg = pkgGraph.getPackageByModule(item, getPackageFile);
            if (pkg) {
                pkgGraph.addPackage(pkg);
                pkg.addModule(item);
            }
        }
        for (const dep of graph.getDependencies()){
            const modulePkg = pkgGraph.getPackageByFile(dep.module.path);
            const dependencyPkg = pkgGraph.getPackageByFile(dep.dependency.path);
            if (modulePkg && dependencyPkg && !modulePkg.isSame(dependencyPkg)) {
                const pkgDep = new PackageDependency(modulePkg, dependencyPkg, dep);
                pkgGraph.addDependency(pkgDep);
                modulePkg.addDependency(pkgDep);
            }
        }
        return pkgGraph;
    }
    getPackages() {
        return this._packages.slice();
    }
    getPackageByModule(module, readFile) {
        const { path: file, meta } = module;
        const { _pkgFileMap: pkgsMap } = this;
        const getPackageByData = (data)=>this.getPackageByData(data) ?? new Package(data.name, data.root, data.version);
        if (pkgsMap.has(file)) return pkgsMap.get(file);
        if (meta.packageData) {
            const pkg = getPackageByData(meta.packageData);
            this.setDuplicates(module, pkg);
            pkgsMap.set(file, pkg);
            return pkg;
        }
        const cache = this.getPackageContainFile(file);
        if (cache) {
            pkgsMap.set(file, cache);
            return cache;
        }
        const data = readPackageJson(file, readFile);
        if (!data) return;
        if (data.root.startsWith('.')) data.root = resolve(this._root, data.root);
        const pkg = getPackageByData(data);
        this.setDuplicates(module, pkg);
        this.addPackage(pkg);
        pkgsMap.set(file, pkg);
        return pkg;
    }
    getPackageByFile(file) {
        return this._pkgFileMap.get(file);
    }
    getPackageContainFile(file) {
        return this._packages.find((pkg)=>pkg.contain(file));
    }
    getPackagesByName(name) {
        return this._pkgNameMap.get(name) ?? [];
    }
    getPackageByData(data) {
        var _this__pkgNameMap_get;
        return null == (_this__pkgNameMap_get = this._pkgNameMap.get(data.name)) ? void 0 : _this__pkgNameMap_get.find((item)=>item.version === data.version && item.root === data.root);
    }
    addPackage(pkg) {
        if (this._packages.every((item)=>!item.isSame(pkg))) {
            this._packages.push(pkg);
            const { _pkgNameMap: map } = this;
            const arr = map.get(pkg.name) ?? [];
            if (arr.every((item)=>!item.isSame(pkg))) {
                arr.push(pkg);
                map.set(pkg.name, arr);
            }
        }
    }
    setDuplicates(module, pkg) {
        const assetsList = [];
        const chunksList = module.getChunks();
        chunksList.forEach((chunk)=>assetsList.push(...chunk.getAssets().filter((asset)=>asset.path.endsWith('.js'))));
        if (chunksList.length > 1) pkg.setDuplicates({
            module: {
                id: module.id,
                path: module.path
            },
            chunks: assetsList.map((asset)=>({
                    name: asset.path
                }))
        });
    }
    getDependenciesFromPackage(pkg) {
        return this._dependencies.filter((dep)=>dep.dependency === pkg);
    }
    addDependency(dep) {
        if (this._dependencies.every((item)=>!item.isSame(dep))) this._dependencies.push(dep);
    }
    getDependenciesFromOrigin() {
        return this._dependencies.filter((item)=>!item.package);
    }
    getDuplicatePackages() {
        return lodash_unionby(Array.from(this._pkgNameMap.values()).map((pkgs)=>lodash_unionby(pkgs, 'version')).filter((pkgs)=>pkgs.length > 1), (pkgs)=>pkgs[0].name);
    }
    toData() {
        return {
            packages: this._packages.map((e)=>e.toData()),
            dependencies: this._dependencies.map((d)=>d.toData())
        };
    }
    constructor(root){
        this._dependencies = [];
        this._packages = [];
        this._pkgNameMap = new Map();
        this._pkgFileMap = new Map();
        this._root = root;
    }
}
export { PackageGraph, readPackageJson };
